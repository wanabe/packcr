class Packcr
  class Context
    def get_header_code(lang, stream)
      case lang
      when :c
        erbout = +""
        erbout << "/* A packrat parser generated by PackCR #{Packcr::VERSION} */\n\n".freeze

        code(:eheader).each do |code|
          erbout << "#{stream.get_code_block(code, 0, @iname)}".freeze
        end
        if !code(:eheader).empty?
          erbout << "\n".freeze
        end
        erbout << "#ifndef PCC_INCLUDED_#{@hid}\n#define PCC_INCLUDED_#{@hid}\n\n".freeze

        code(:header).each do |code|
          erbout << "#{stream.get_code_block(code, 0, @iname)}".freeze
        end
        erbout << "#ifdef __cplusplus\nextern \"C\" {\n#endif\n\ntypedef struct #{prefix}_context_tag #{prefix}_context_t;\n\n#{prefix}_context_t *#{prefix}_create(#{auxil_def}auxil);\nint #{prefix}_parse(#{prefix}_context_t *ctx, #{value_def}*ret);\nvoid #{prefix}_destroy(#{prefix}_context_t *ctx);\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif /* !PCC_INCLUDED_#{@hid} */\n".freeze

        erbout
      end
    end

    def get_source_code(lang, stream)
      case lang
      when :c
        erbout = +""
        erbout << "/* A packrat parser generated by PackCR #{Packcr::VERSION} */\n\n".freeze

        code(:esource).each do |code|
          erbout << "#{stream.get_code_block(code, 0, @iname)}".freeze
        end
        if !code(:esource).empty?
          erbout << "\n".freeze
        end
        erbout << "#ifdef _MSC_VER\n#undef _CRT_SECURE_NO_WARNINGS\n#define _CRT_SECURE_NO_WARNINGS\n#endif /* _MSC_VER */\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#ifndef _MSC_VER\n#if defined __GNUC__ && defined _WIN32 /* MinGW */\n#ifndef PCC_USE_SYSTEM_STRNLEN\n#define strnlen(str, maxlen) pcc_strnlen(str, maxlen)\nstatic size_t pcc_strnlen(const char *str, size_t maxlen) {\n    size_t i;\n    for (i = 0; i < maxlen && str[i]; i++);\n    return i;\n}\n#endif /* !PCC_USE_SYSTEM_STRNLEN */\n#endif /* defined __GNUC__ && defined _WIN32 */\n#endif /* !_MSC_VER */\n\n#include \"#{@hname}\"\n".freeze

        if !code(:location).empty?
          erbout << "\n".freeze

          code(:location).each do |code|
            erbout << "#{stream.get_code_block(code, 4, @iname)}".freeze
          end
        end
        erbout << "\n".freeze

        code(:source).each do |code|
          erbout << "#{stream.get_code_block(code, 0, @iname)}".freeze
        end
        erbout << "#if !defined __has_attribute || defined _MSC_VER\n#define __attribute__(x)\n#endif\n\n#ifdef _MSC_VER\n#define MARK_FUNC_AS_USED __pragma(warning(suppress:4505))\n#else\n#define MARK_FUNC_AS_USED __attribute__((__unused__))\n#endif\n\n#ifndef PCC_BUFFER_MIN_SIZE\n#define PCC_BUFFER_MIN_SIZE 256\n#endif /* !PCC_BUFFER_MIN_SIZE */\n\n#ifndef PCC_ARRAY_MIN_SIZE\n#define PCC_ARRAY_MIN_SIZE 2\n#endif /* !PCC_ARRAY_MIN_SIZE */\n\n#ifndef PCC_POOL_MIN_SIZE\n#define PCC_POOL_MIN_SIZE 65536\n#endif /* !PCC_POOL_MIN_SIZE */\n\n#define PCC_DBG_EVALUATE 0\n#define PCC_DBG_MATCH    1\n#define PCC_DBG_NOMATCH  2\n\n#define PCC_VOID_VALUE (~(size_t)0)\n\ntypedef enum pcc_bool_tag {\n    PCC_FALSE = 0,\n    PCC_TRUE\n} pcc_bool_t;\n\ntypedef struct pcc_char_array_tag {\n    char *buf;\n    size_t max;\n    size_t len;\n} pcc_char_array_t;\n\ntypedef struct pcc_range_tag {\n    size_t start;\n    size_t end;\n".freeze

        if @location
          erbout << "    pcc_location_t start_loc;\n    pcc_location_t end_loc;\n".freeze
        end
        erbout << "} pcc_range_t;\n\ntypedef #{value_def}pcc_value_t;\n\ntypedef #{auxil_def}pcc_auxil_t;\n\n".freeze

        if prefix != "pcc"
          erbout << "typedef #{prefix}_context_t pcc_context_t;\n\n".freeze
        end
        erbout << "typedef struct pcc_value_table_tag {\n    pcc_value_t *buf;\n    size_t max;\n    size_t len;\n} pcc_value_table_t;\n\ntypedef struct pcc_value_refer_table_tag {\n    pcc_value_t **buf;\n    size_t max;\n    size_t len;\n} pcc_value_refer_table_t;\n\ntypedef struct pcc_capture_tag {\n    pcc_range_t range;\n    char *string; /* mutable */\n} pcc_capture_t;\n\ntypedef struct pcc_capture_table_tag {\n    pcc_capture_t *buf;\n    size_t max;\n    size_t len;\n} pcc_capture_table_t;\n\ntypedef struct pcc_capture_const_table_tag {\n    const pcc_capture_t **buf;\n    size_t max;\n    size_t len;\n} pcc_capture_const_table_t;\n\ntypedef struct pcc_thunk_tag pcc_thunk_t;\ntypedef struct pcc_thunk_array_tag pcc_thunk_array_t;\n\ntypedef void (*pcc_action_t)(pcc_context_t *, pcc_thunk_t *, pcc_value_t *);\n\ntypedef enum pcc_thunk_type_tag {\n    PCC_THUNK_LEAF,\n    PCC_THUNK_NODE\n} pcc_thunk_type_t;\n\ntypedef struct pcc_thunk_leaf_tag {\n    pcc_value_refer_table_t values;\n    pcc_capture_const_table_t capts;\n    pcc_capture_t capt0;\n    pcc_action_t action;\n} pcc_thunk_leaf_t;\n\ntypedef struct pcc_thunk_node_tag {\n    const pcc_thunk_array_t *thunks; /* just a reference */\n    pcc_value_t *value; /* just a reference */\n} pcc_thunk_node_t;\n\ntypedef union pcc_thunk_data_tag {\n    pcc_thunk_leaf_t leaf;\n    pcc_thunk_node_t node;\n} pcc_thunk_data_t;\n\nstruct pcc_thunk_tag {\n    pcc_thunk_type_t type;\n    pcc_thunk_data_t data;\n};\n\nstruct pcc_thunk_array_tag {\n    pcc_thunk_t **buf;\n    size_t max;\n    size_t len;\n};\n\ntypedef struct pcc_thunk_chunk_tag {\n    pcc_value_table_t values;\n    pcc_capture_table_t capts;\n    pcc_thunk_array_t thunks;\n    size_t pos; /* the starting position in the character buffer */\n".freeze

        if @location
          erbout << "    pcc_location_t pos_loc;\n".freeze
        end
        erbout << "} pcc_thunk_chunk_t;\n\ntypedef struct pcc_lr_answer_tag pcc_lr_answer_t;\n\nstruct pcc_lr_answer_tag {\n    size_t offset;\n".freeze

        if @location
          erbout << "    pcc_location_t offset_loc;\n".freeze
        end
        erbout << "    pcc_lr_answer_t *hold;\n    pcc_thunk_chunk_t *chunk;\n    pcc_bool_t fail;\n    pcc_bool_t grow;\n};\n\ntypedef struct pcc_rule_set_tag pcc_rule_set_t;\n\ntypedef pcc_thunk_chunk_t *(*pcc_rule_t)(pcc_context_t *, size_t".freeze
        if @location
          erbout << ", pcc_location_t".freeze
        end
        erbout << ", pcc_rule_set_t*);\n\ntypedef struct pcc_rule_set_tag {\n    pcc_rule_t *buf;\n    size_t max;\n    size_t len;\n} pcc_rule_set_t;\n\ntypedef struct pcc_lr_memo_tag {\n    pcc_rule_t rule;\n    pcc_lr_answer_t *answer;\n} pcc_lr_memo_t;\n\ntypedef struct pcc_lr_memo_map_tag {\n    pcc_lr_memo_t *buf;\n    size_t max;\n    size_t len;\n} pcc_lr_memo_map_t;\n\ntypedef struct pcc_lr_table_entry_tag {\n    pcc_lr_memo_map_t memos;\n    pcc_lr_answer_t *hold_a;\n} pcc_lr_table_entry_t;\n\ntypedef struct pcc_lr_table_tag {\n    pcc_lr_table_entry_t **buf;\n    size_t max;\n    size_t len;\n    size_t ofs;\n} pcc_lr_table_t;\n\ntypedef struct pcc_memory_entry_tag pcc_memory_entry_t;\ntypedef struct pcc_memory_pool_tag pcc_memory_pool_t;\n\nstruct pcc_memory_entry_tag {\n    pcc_memory_entry_t *next;\n};\n\nstruct pcc_memory_pool_tag {\n    pcc_memory_pool_t *next;\n    size_t allocated;\n    size_t unused;\n};\n\ntypedef struct pcc_memory_recycler_tag {\n    pcc_memory_pool_t *pool_list;\n    pcc_memory_entry_t *entry_list;\n    size_t element_size;\n} pcc_memory_recycler_t;\n\nstruct #{prefix}_context_tag {\n    size_t buffer_start_position; /* the position in the input of the first character currently buffered */\n    size_t position_offset; /* the current parsing position in the character buffer */\n".freeze

        if @location
          erbout << "    pcc_location_t buffer_start_position_loc;\n    pcc_location_t position_offset_loc;\n".freeze
        end
        erbout << "    size_t level;\n    pcc_char_array_t buffer;\n    pcc_lr_table_t lrtable;\n    pcc_thunk_array_t thunks;\n    pcc_auxil_t auxil;\n    pcc_memory_recycler_t thunk_chunk_recycler;\n    pcc_memory_recycler_t lr_answer_recycler;\n};\n\n#ifndef PCC_ERROR\n#define PCC_ERROR(auxil) pcc_error()\nMARK_FUNC_AS_USED\nstatic void pcc_error(void) {\n    fprintf(stderr, \"Syntax error\\n\");\n    exit(1);\n}\n#endif /* !PCC_ERROR */\n\n#ifndef PCC_GETCHAR\n#define PCC_GETCHAR(auxil) getchar()\n#endif /* !PCC_GETCHAR */\n\n#ifndef PCC_MALLOC\n#define PCC_MALLOC(auxil, size) pcc_malloc_e(size)\nstatic void *pcc_malloc_e(size_t size) {\n    void *const p = malloc(size);\n    if (p == NULL) {\n        fprintf(stderr, \"Out of memory\\n\");\n        exit(1);\n    }\n    return p;\n}\n#endif /* !PCC_MALLOC */\n\n#ifndef PCC_REALLOC\n#define PCC_REALLOC(auxil, ptr, size) pcc_realloc_e(ptr, size)\nstatic void *pcc_realloc_e(void *ptr, size_t size) {\n    void *const p = realloc(ptr, size);\n    if (p == NULL) {\n        fprintf(stderr, \"Out of memory\\n\");\n        exit(1);\n    }\n    return p;\n}\n#endif /* !PCC_REALLOC */\n\n#ifndef PCC_FREE\n#define PCC_FREE(auxil, ptr) free(ptr)\n#endif /* !PCC_FREE */\n\n#ifndef PCC_DEBUG\n#define PCC_DEBUG(auxil, event, rule, level, pos, buffer, length) ((void)0)\n#endif /* !PCC_DEBUG */\n\nstatic char *pcc_strndup_e(pcc_auxil_t auxil, const char *str, size_t len) {\n    const size_t m = strnlen(str, len);\n    char *const s = (char *)PCC_MALLOC(auxil, m + 1);\n    memcpy(s, str, m);\n    s[m] = '\\0';\n    return s;\n}\n\nstatic void pcc_char_array__init(pcc_auxil_t auxil, pcc_char_array_t *array) {\n    array->len = 0;\n    array->max = 0;\n    array->buf = NULL;\n}\n\nstatic void pcc_char_array__add(pcc_auxil_t auxil, pcc_char_array_t *array, char ch) {\n    if (array->max <= array->len) {\n        const size_t n = array->len + 1;\n        size_t m = array->max;\n        if (m == 0) m = PCC_BUFFER_MIN_SIZE;\n        while (m < n && m != 0) m <<= 1;\n        if (m == 0) m = n;\n        array->buf = (char *)PCC_REALLOC(auxil, array->buf, m);\n        array->max = m;\n    }\n    array->buf[array->len++] = ch;\n}\n\nstatic void pcc_char_array__term(pcc_auxil_t auxil, pcc_char_array_t *array) {\n    PCC_FREE(auxil, array->buf);\n}\n\nstatic void pcc_value_table__init(pcc_auxil_t auxil, pcc_value_table_t *table) {\n    table->len = 0;\n    table->max = 0;\n    table->buf = NULL;\n}\n\nMARK_FUNC_AS_USED\nstatic void pcc_value_table__resize(pcc_auxil_t auxil, pcc_value_table_t *table, size_t len) {\n    if (table->max < len) {\n        size_t m = table->max;\n        if (m == 0) m = PCC_ARRAY_MIN_SIZE;\n        while (m < len && m != 0) m <<= 1;\n        if (m == 0) m = len;\n        table->buf = (pcc_value_t *)PCC_REALLOC(auxil, table->buf, sizeof(pcc_value_t) * m);\n        table->max = m;\n    }\n    table->len = len;\n}\n\nMARK_FUNC_AS_USED\nstatic void pcc_value_table__clear(pcc_auxil_t auxil, pcc_value_table_t *table) {\n    memset(table->buf, 0, sizeof(pcc_value_t) * table->len);\n}\n\nstatic void pcc_value_table__term(pcc_auxil_t auxil, pcc_value_table_t *table) {\n    PCC_FREE(auxil, table->buf);\n}\n\nstatic void pcc_value_refer_table__init(pcc_auxil_t auxil, pcc_value_refer_table_t *table) {\n    table->len = 0;\n    table->max = 0;\n    table->buf = NULL;\n}\n\nstatic void pcc_value_refer_table__resize(pcc_auxil_t auxil, pcc_value_refer_table_t *table, size_t len) {\n    size_t i;\n    if (table->max < len) {\n        size_t m = table->max;\n        if (m == 0) m = PCC_ARRAY_MIN_SIZE;\n        while (m < len && m != 0) m <<= 1;\n        if (m == 0) m = len;\n        table->buf = (pcc_value_t **)PCC_REALLOC(auxil, table->buf, sizeof(pcc_value_t *) * m);\n        table->max = m;\n    }\n    for (i = table->len; i < len; i++) table->buf[i] = NULL;\n    table->len = len;\n}\n\nstatic void pcc_value_refer_table__term(pcc_auxil_t auxil, pcc_value_refer_table_t *table) {\n    PCC_FREE(auxil, table->buf);\n}\n\nstatic void pcc_capture_table__init(pcc_auxil_t auxil, pcc_capture_table_t *table) {\n    table->len = 0;\n    table->max = 0;\n    table->buf = NULL;\n}\n\nMARK_FUNC_AS_USED\nstatic void pcc_capture_table__resize(pcc_auxil_t auxil, pcc_capture_table_t *table, size_t len) {\n    size_t i;\n    for (i = len; i < table->len; i++) PCC_FREE(auxil, table->buf[i].string);\n    if (table->max < len) {\n        size_t m = table->max;\n        if (m == 0) m = PCC_ARRAY_MIN_SIZE;\n        while (m < len && m != 0) m <<= 1;\n        if (m == 0) m = len;\n        table->buf = (pcc_capture_t *)PCC_REALLOC(auxil, table->buf, sizeof(pcc_capture_t) * m);\n        table->max = m;\n    }\n    for (i = table->len; i < len; i++) {\n        table->buf[i].range.start = 0;\n        table->buf[i].range.end = 0;\n".freeze

        if @location
          erbout << "        pcc_location_init(&table->buf[i].range.start_loc);\n        pcc_location_init(&table->buf[i].range.end_loc);\n".freeze
        end
        erbout << "        table->buf[i].string = NULL;\n    }\n    table->len = len;\n}\n\nstatic void pcc_capture_table__term(pcc_auxil_t auxil, pcc_capture_table_t *table) {\n    while (table->len > 0) {\n        table->len--;\n        PCC_FREE(auxil, table->buf[table->len].string);\n    }\n    PCC_FREE(auxil, table->buf);\n}\n\nstatic void pcc_capture_const_table__init(pcc_auxil_t auxil, pcc_capture_const_table_t *table) {\n    table->len = 0;\n    table->max = 0;\n    table->buf = NULL;\n}\n\nstatic void pcc_capture_const_table__resize(pcc_auxil_t auxil, pcc_capture_const_table_t *table, size_t len) {\n    size_t i;\n    if (table->max < len) {\n        size_t m = table->max;\n        if (m == 0) m = PCC_ARRAY_MIN_SIZE;\n        while (m < len && m != 0) m <<= 1;\n        if (m == 0) m = len;\n        table->buf = (const pcc_capture_t **)PCC_REALLOC(auxil, (pcc_capture_t **)table->buf, sizeof(const pcc_capture_t *) * m);\n        table->max = m;\n    }\n    for (i = table->len; i < len; i++) table->buf[i] = NULL;\n    table->len = len;\n}\n\nstatic void pcc_capture_const_table__term(pcc_auxil_t auxil, pcc_capture_const_table_t *table) {\n    PCC_FREE(auxil, (void *)table->buf);\n}\n\nMARK_FUNC_AS_USED\nstatic pcc_thunk_t *pcc_thunk__create_leaf(pcc_auxil_t auxil, pcc_action_t action, size_t valuec, size_t captc) {\n    pcc_thunk_t *const thunk = (pcc_thunk_t *)PCC_MALLOC(auxil, sizeof(pcc_thunk_t));\n    thunk->type = PCC_THUNK_LEAF;\n    pcc_value_refer_table__init(auxil, &thunk->data.leaf.values);\n    pcc_value_refer_table__resize(auxil, &thunk->data.leaf.values, valuec);\n    pcc_capture_const_table__init(auxil, &thunk->data.leaf.capts);\n    pcc_capture_const_table__resize(auxil, &thunk->data.leaf.capts, captc);\n    thunk->data.leaf.capt0.range.start = 0;\n    thunk->data.leaf.capt0.range.end = 0;\n".freeze

        if @location
          erbout << "    pcc_location_init(&thunk->data.leaf.capt0.range.start_loc);\n    pcc_location_init(&thunk->data.leaf.capt0.range.end_loc);\n".freeze
        end
        erbout << "    thunk->data.leaf.capt0.string = NULL;\n    thunk->data.leaf.action = action;\n    return thunk;\n}\n\nstatic pcc_thunk_t *pcc_thunk__create_node(pcc_auxil_t auxil, const pcc_thunk_array_t *thunks, pcc_value_t *value) {\n    pcc_thunk_t *const thunk = (pcc_thunk_t *)PCC_MALLOC(auxil, sizeof(pcc_thunk_t));\n    thunk->type = PCC_THUNK_NODE;\n    thunk->data.node.thunks = thunks;\n    thunk->data.node.value = value;\n    return thunk;\n}\n\nstatic void pcc_thunk__destroy(pcc_auxil_t auxil, pcc_thunk_t *thunk) {\n    if (thunk == NULL) return;\n    switch (thunk->type) {\n    case PCC_THUNK_LEAF:\n        PCC_FREE(auxil, thunk->data.leaf.capt0.string);\n        pcc_capture_const_table__term(auxil, &thunk->data.leaf.capts);\n        pcc_value_refer_table__term(auxil, &thunk->data.leaf.values);\n        break;\n    case PCC_THUNK_NODE:\n        break;\n    default: /* unknown */\n        break;\n    }\n    PCC_FREE(auxil, thunk);\n}\n\nstatic void pcc_thunk_array__init(pcc_auxil_t auxil, pcc_thunk_array_t *array) {\n    array->len = 0;\n    array->max = 0;\n    array->buf = NULL;\n}\n\nstatic void pcc_thunk_array__add(pcc_auxil_t auxil, pcc_thunk_array_t *array, pcc_thunk_t *thunk) {\n    if (array->max <= array->len) {\n        const size_t n = array->len + 1;\n        size_t m = array->max;\n        if (m == 0) m = PCC_ARRAY_MIN_SIZE;\n        while (m < n && m != 0) m <<= 1;\n        if (m == 0) m = n;\n        array->buf = (pcc_thunk_t **)PCC_REALLOC(auxil, array->buf, sizeof(pcc_thunk_t *) * m);\n        array->max = m;\n    }\n    array->buf[array->len++] = thunk;\n}\n\nstatic void pcc_thunk_array__revert(pcc_auxil_t auxil, pcc_thunk_array_t *array, size_t len) {\n    while (array->len > len) {\n        array->len--;\n        pcc_thunk__destroy(auxil, array->buf[array->len]);\n    }\n}\n\nstatic void pcc_thunk_array__term(pcc_auxil_t auxil, pcc_thunk_array_t *array) {\n    while (array->len > 0) {\n        array->len--;\n        pcc_thunk__destroy(auxil, array->buf[array->len]);\n    }\n    PCC_FREE(auxil, array->buf);\n}\n\nstatic void pcc_memory_recycler__init(pcc_auxil_t auxil, pcc_memory_recycler_t *recycler, size_t element_size) {\n    recycler->pool_list = NULL;\n    recycler->entry_list = NULL;\n    recycler->element_size = element_size;\n}\n\nstatic void *pcc_memory_recycler__supply(pcc_auxil_t auxil, pcc_memory_recycler_t *recycler) {\n    if (recycler->entry_list) {\n        pcc_memory_entry_t *const tmp = recycler->entry_list;\n        recycler->entry_list = tmp->next;\n        return tmp;\n    }\n    if (!recycler->pool_list || recycler->pool_list->unused == 0) {\n        size_t size = PCC_POOL_MIN_SIZE;\n        if (recycler->pool_list) {\n            size = recycler->pool_list->allocated << 1;\n            if (size == 0) size = recycler->pool_list->allocated;\n        }\n        {\n            pcc_memory_pool_t *const pool = (pcc_memory_pool_t *)PCC_MALLOC(\n                auxil, sizeof(pcc_memory_pool_t) + recycler->element_size * size\n            );\n            pool->allocated = size;\n            pool->unused = size;\n            pool->next = recycler->pool_list;\n            recycler->pool_list = pool;\n        }\n    }\n    recycler->pool_list->unused--;\n    return (char *)recycler->pool_list + sizeof(pcc_memory_pool_t) + recycler->element_size * recycler->pool_list->unused;\n}\n\nstatic void pcc_memory_recycler__recycle(pcc_auxil_t auxil, pcc_memory_recycler_t *recycler, void *ptr) {\n    pcc_memory_entry_t *const tmp = (pcc_memory_entry_t *)ptr;\n    tmp->next = recycler->entry_list;\n    recycler->entry_list = tmp;\n}\n\nstatic void pcc_memory_recycler__term(pcc_auxil_t auxil, pcc_memory_recycler_t *recycler) {\n    while (recycler->pool_list) {\n        pcc_memory_pool_t *const tmp = recycler->pool_list;\n        recycler->pool_list = tmp->next;\n        PCC_FREE(auxil, tmp);\n    }\n}\n\nMARK_FUNC_AS_USED\nstatic pcc_thunk_chunk_t *pcc_thunk_chunk__create(pcc_context_t *ctx) {\n    pcc_thunk_chunk_t *const chunk = (pcc_thunk_chunk_t *)pcc_memory_recycler__supply(ctx->auxil, &ctx->thunk_chunk_recycler);\n    pcc_value_table__init(ctx->auxil, &chunk->values);\n    pcc_capture_table__init(ctx->auxil, &chunk->capts);\n    pcc_thunk_array__init(ctx->auxil, &chunk->thunks);\n    chunk->pos = 0;\n    return chunk;\n}\n\nstatic void pcc_thunk_chunk__destroy(pcc_context_t *ctx, pcc_thunk_chunk_t *chunk) {\n    if (chunk == NULL) return;\n    pcc_thunk_array__term(ctx->auxil, &chunk->thunks);\n    pcc_capture_table__term(ctx->auxil, &chunk->capts);\n    pcc_value_table__term(ctx->auxil, &chunk->values);\n    pcc_memory_recycler__recycle(ctx->auxil, &ctx->thunk_chunk_recycler, chunk);\n}\n\nstatic void pcc_rule_set__init(pcc_auxil_t auxil, pcc_rule_set_t *set) {\n    set->len = 0;\n    set->max = 0;\n    set->buf = NULL;\n}\n\nstatic size_t pcc_rule_set__index(pcc_auxil_t auxil, const pcc_rule_set_t *set, pcc_rule_t rule) {\n    size_t i;\n    for (i = 0; i < set->len; i++) {\n        if (set->buf[i] == rule) return i;\n    }\n    return PCC_VOID_VALUE;\n}\n\nstatic pcc_bool_t pcc_rule_set__add(pcc_auxil_t auxil, pcc_rule_set_t *set, pcc_rule_t rule) {\n    const size_t i = pcc_rule_set__index(auxil, set, rule);\n    if (i != PCC_VOID_VALUE) return PCC_FALSE;\n    if (set->max <= set->len) {\n        const size_t n = set->len + 1;\n        size_t m = set->max;\n        if (m == 0) m = PCC_ARRAY_MIN_SIZE;\n        while (m < n && m != 0) m <<= 1;\n        if (m == 0) m = n;\n        set->buf = (pcc_rule_t *)PCC_REALLOC(auxil, set->buf, sizeof(pcc_rule_t) * m);\n        set->max = m;\n    }\n    set->buf[set->len++] = rule;\n    return PCC_TRUE;\n}\n\nstatic void pcc_rule_set__term(pcc_auxil_t auxil, pcc_rule_set_t *set) {\n    PCC_FREE(auxil, set->buf);\n}\n\nstatic pcc_lr_answer_t *pcc_lr_answer__create(pcc_context_t *ctx, size_t offset".freeze
        if @location
          erbout << ", pcc_location_t offset_loc".freeze
        end
        erbout << ") {\n    pcc_lr_answer_t *answer = (pcc_lr_answer_t *)pcc_memory_recycler__supply(ctx->auxil, &ctx->lr_answer_recycler);\n    answer->offset = offset;\n".freeze

        if @location
          erbout << "    answer->offset_loc = offset_loc;\n".freeze
        end
        erbout << "    answer->chunk = NULL;\n    answer->fail = PCC_TRUE;\n    answer->grow = PCC_FALSE;\n    answer->hold = NULL;\n    return answer;\n}\n\nstatic void pcc_lr_answer__set_chunk(pcc_context_t *ctx, pcc_lr_answer_t *answer, pcc_thunk_chunk_t *chunk) {\n    if (answer->chunk) {\n        pcc_lr_answer_t *const a = pcc_lr_answer__create(ctx, answer->offset".freeze

        if @location
          erbout << ", answer->offset_loc".freeze
        end
        erbout << ");\n        a->chunk = answer->chunk;\n        a->hold = answer->hold;\n        answer->hold = a;\n    }\n    answer->chunk = chunk;\n    answer->fail = PCC_FALSE;\n}\n\nstatic void pcc_lr_answer__destroy(pcc_context_t *ctx, pcc_lr_answer_t *answer) {\n    while (answer != NULL) {\n        pcc_lr_answer_t *const a = answer->hold;\n        pcc_thunk_chunk__destroy(ctx, answer->chunk);\n        pcc_memory_recycler__recycle(ctx->auxil, &ctx->lr_answer_recycler, answer);\n        answer = a;\n    }\n}\n\nstatic void pcc_lr_memo_map__init(pcc_auxil_t auxil, pcc_lr_memo_map_t *map) {\n    map->len = 0;\n    map->max = 0;\n    map->buf = NULL;\n}\n\nstatic size_t pcc_lr_memo_map__index(pcc_context_t *ctx, pcc_lr_memo_map_t *map, pcc_rule_t rule) {\n    size_t i;\n    for (i = 0; i < map->len; i++) {\n        if (map->buf[i].rule == rule) return i;\n    }\n    return PCC_VOID_VALUE;\n}\n\nstatic void pcc_lr_memo_map__put(pcc_context_t *ctx, pcc_lr_memo_map_t *map, pcc_rule_t rule, pcc_lr_answer_t *answer) {\n    const size_t i = pcc_lr_memo_map__index(ctx, map, rule);\n    if (i != PCC_VOID_VALUE) {\n        pcc_lr_answer__destroy(ctx, map->buf[i].answer);\n        map->buf[i].answer = answer;\n    }\n    else {\n        if (map->max <= map->len) {\n            const size_t n = map->len + 1;\n            size_t m = map->max;\n            if (m == 0) m = PCC_ARRAY_MIN_SIZE;\n            while (m < n && m != 0) m <<= 1;\n            if (m == 0) m = n;\n            map->buf = (pcc_lr_memo_t *)PCC_REALLOC(ctx->auxil, map->buf, sizeof(pcc_lr_memo_t) * m);\n            map->max = m;\n        }\n        map->buf[map->len].rule = rule;\n        map->buf[map->len].answer = answer;\n        map->len++;\n    }\n}\n\nstatic pcc_lr_answer_t *pcc_lr_memo_map__get(pcc_context_t *ctx, pcc_lr_memo_map_t *map, pcc_rule_t rule) {\n    const size_t i = pcc_lr_memo_map__index(ctx, map, rule);\n    return (i != PCC_VOID_VALUE) ? map->buf[i].answer : NULL;\n}\n\nstatic void pcc_lr_memo_map__term(pcc_context_t *ctx, pcc_lr_memo_map_t *map) {\n    while (map->len > 0) {\n        map->len--;\n        pcc_lr_answer__destroy(ctx, map->buf[map->len].answer);\n    }\n    PCC_FREE(ctx->auxil, map->buf);\n}\n\nstatic pcc_lr_table_entry_t *pcc_lr_table_entry__create(pcc_context_t *ctx) {\n    pcc_lr_table_entry_t *const entry = (pcc_lr_table_entry_t *)PCC_MALLOC(ctx->auxil, sizeof(pcc_lr_table_entry_t));\n    pcc_lr_memo_map__init(ctx->auxil, &entry->memos);\n    entry->hold_a = NULL;\n    return entry;\n}\n\nstatic void pcc_lr_table_entry__destroy(pcc_context_t *ctx, pcc_lr_table_entry_t *entry) {\n    if (entry == NULL) return;\n    pcc_lr_answer__destroy(ctx, entry->hold_a);\n    pcc_lr_memo_map__term(ctx, &entry->memos);\n    PCC_FREE(ctx->auxil, entry);\n}\n\nstatic void pcc_lr_table__init(pcc_auxil_t auxil, pcc_lr_table_t *table) {\n    table->ofs = 0;\n    table->len = 0;\n    table->max = 0;\n    table->buf = NULL;\n}\n\nstatic void pcc_lr_table__resize(pcc_context_t *ctx, pcc_lr_table_t *table, size_t len) {\n    size_t i;\n    for (i = len; i < table->len; i++) pcc_lr_table_entry__destroy(ctx, table->buf[i]);\n    if (table->max < len) {\n        size_t m = table->max;\n        if (m == 0) m = PCC_ARRAY_MIN_SIZE;\n        while (m < len && m != 0) m <<= 1;\n        if (m == 0) m = len;\n        table->buf = (pcc_lr_table_entry_t **)PCC_REALLOC(ctx->auxil, table->buf, sizeof(pcc_lr_table_entry_t *) * m);\n        table->max = m;\n    }\n    for (i = table->len; i < len; i++) table->buf[i] = NULL;\n    table->len = len;\n}\n\nstatic void pcc_lr_table__set_answer(pcc_context_t *ctx, pcc_lr_table_t *table, size_t index, pcc_rule_t rule, pcc_lr_answer_t *answer) {\n    index += table->ofs;\n    if (index >= table->len) pcc_lr_table__resize(ctx, table, index + 1);\n    if (table->buf[index] == NULL) table->buf[index] = pcc_lr_table_entry__create(ctx);\n    pcc_lr_memo_map__put(ctx, &table->buf[index]->memos, rule, answer);\n}\n\nstatic pcc_lr_answer_t *pcc_lr_table__get_answer(pcc_context_t *ctx, pcc_lr_table_t *table, size_t index, pcc_rule_t rule) {\n    index += table->ofs;\n    if (index >= table->len || table->buf[index] == NULL) return NULL;\n    return pcc_lr_memo_map__get(ctx, &table->buf[index]->memos, rule);\n}\n\nstatic void pcc_lr_table__shift(pcc_context_t *ctx, pcc_lr_table_t *table, size_t count) {\n    size_t i;\n    if (count > table->len - table->ofs) count = table->len - table->ofs;\n    for (i = 0; i < count; i++) pcc_lr_table_entry__destroy(ctx, table->buf[table->ofs++]);\n    if (table->ofs > (table->max >> 1)) {\n        memmove(table->buf, table->buf + table->ofs, sizeof(pcc_lr_table_entry_t *) * (table->len - table->ofs));\n        table->len -= table->ofs;\n        table->ofs = 0;\n    }\n}\n\nstatic void pcc_lr_table__term(pcc_context_t *ctx, pcc_lr_table_t *table) {\n    while (table->len > table->ofs) {\n        table->len--;\n        pcc_lr_table_entry__destroy(ctx, table->buf[table->len]);\n    }\n    PCC_FREE(ctx->auxil, table->buf);\n}\n\nstatic pcc_context_t *pcc_context__create(pcc_auxil_t auxil) {\n    pcc_context_t *const ctx = (pcc_context_t *)PCC_MALLOC(auxil, sizeof(pcc_context_t));\n    ctx->buffer_start_position = 0;\n    ctx->position_offset = 0;\n".freeze

        if @location
          erbout << "    pcc_location_init(&ctx->buffer_start_position_loc);\n    pcc_location_init(&ctx->position_offset_loc);\n".freeze
        end
        erbout << "    ctx->level = 0;\n    pcc_char_array__init(auxil, &ctx->buffer);\n    pcc_lr_table__init(auxil, &ctx->lrtable);\n    pcc_thunk_array__init(auxil, &ctx->thunks);\n    pcc_memory_recycler__init(auxil, &ctx->thunk_chunk_recycler, sizeof(pcc_thunk_chunk_t));\n    pcc_memory_recycler__init(auxil, &ctx->lr_answer_recycler, sizeof(pcc_lr_answer_t));\n    ctx->auxil = auxil;\n    return ctx;\n}\n\nstatic void pcc_context__destroy(pcc_context_t *ctx) {\n    if (ctx == NULL) return;\n    pcc_thunk_array__term(ctx->auxil, &ctx->thunks);\n    pcc_lr_table__term(ctx, &ctx->lrtable);\n    pcc_char_array__term(ctx->auxil, &ctx->buffer);\n    pcc_memory_recycler__term(ctx->auxil, &ctx->thunk_chunk_recycler);\n    pcc_memory_recycler__term(ctx->auxil, &ctx->lr_answer_recycler);\n    PCC_FREE(ctx->auxil, ctx);\n}\n\nstatic size_t pcc_refill_buffer(pcc_context_t *ctx, size_t num) {\n    if (ctx->buffer.len >= ctx->position_offset + num) return ctx->buffer.len - ctx->position_offset;\n    while (ctx->buffer.len < ctx->position_offset + num) {\n        const int c = PCC_GETCHAR(ctx->auxil);\n        if (c < 0) break;\n        pcc_char_array__add(ctx->auxil, &ctx->buffer, (char)c);\n    }\n    return ctx->buffer.len - ctx->position_offset;\n}\n\nMARK_FUNC_AS_USED\nstatic void pcc_commit_buffer(pcc_context_t *ctx) {\n    memmove(ctx->buffer.buf, ctx->buffer.buf + ctx->position_offset, ctx->buffer.len - ctx->position_offset);\n    ctx->buffer.len -= ctx->position_offset;\n    ctx->buffer_start_position += ctx->position_offset;\n    pcc_lr_table__shift(ctx, &ctx->lrtable, ctx->position_offset);\n    ctx->position_offset = 0;\n".freeze

        if @location
          erbout << "    ctx->buffer_start_position_loc = pcc_location_add(ctx->buffer_start_position_loc, ctx->position_offset_loc);\n    pcc_location_init(&ctx->position_offset_loc);\n".freeze
        end
        erbout << "}\n\nMARK_FUNC_AS_USED\nstatic const char *pcc_get_capture_string(pcc_context_t *ctx, const pcc_capture_t *capt) {\n    if (capt->string == NULL)\n        ((pcc_capture_t *)capt)->string =\n            pcc_strndup_e(ctx->auxil, ctx->buffer.buf + capt->range.start, capt->range.end - capt->range.start);\n    return capt->string;\n}\n\n".freeze

        if @utf8
          erbout << "static size_t pcc_get_char_as_utf32(pcc_context_t *ctx, int *out) { /* with checking UTF-8 validity */\n    int c, u;\n    size_t n;\n    if (pcc_refill_buffer(ctx, 1) < 1) return 0;\n    c = (int)(unsigned char)ctx->buffer.buf[ctx->position_offset];\n    n = (c < 0x80) ? 1 :\n        ((c & 0xe0) == 0xc0) ? 2 :\n        ((c & 0xf0) == 0xe0) ? 3 :\n        ((c & 0xf8) == 0xf0) ? 4 : 0;\n    if (n < 1) return 0;\n    if (pcc_refill_buffer(ctx, n) < n) return 0;\n    switch (n) {\n    case 1:\n        u = c;\n        break;\n    case 2:\n        u = c & 0x1f;\n        c = (int)(unsigned char)ctx->buffer.buf[ctx->position_offset + 1];\n        if ((c & 0xc0) != 0x80) return 0;\n        u <<= 6; u |= c & 0x3f;\n        if (u < 0x80) return 0;\n        break;\n    case 3:\n        u = c & 0x0f;\n        c = (int)(unsigned char)ctx->buffer.buf[ctx->position_offset + 1];\n        if ((c & 0xc0) != 0x80) return 0;\n        u <<= 6; u |= c & 0x3f;\n        c = (int)(unsigned char)ctx->buffer.buf[ctx->position_offset + 2];\n        if ((c & 0xc0) != 0x80) return 0;\n        u <<= 6; u |= c & 0x3f;\n        if (u < 0x800) return 0;\n        break;\n    case 4:\n        u = c & 0x07;\n        c = (int)(unsigned char)ctx->buffer.buf[ctx->position_offset + 1];\n        if ((c & 0xc0) != 0x80) return 0;\n        u <<= 6; u |= c & 0x3f;\n        c = (int)(unsigned char)ctx->buffer.buf[ctx->position_offset + 2];\n        if ((c & 0xc0) != 0x80) return 0;\n        u <<= 6; u |= c & 0x3f;\n        c = (int)(unsigned char)ctx->buffer.buf[ctx->position_offset + 3];\n        if ((c & 0xc0) != 0x80) return 0;\n        u <<= 6; u |= c & 0x3f;\n        if (u < 0x10000 || u > 0x10ffff) return 0;\n        break;\n    default:\n        return 0;\n    }\n    if (out) *out = u;\n    return n;\n}\n\n".freeze
        end
        erbout << "static void pcc_grow_lr(pcc_context_t *ctx, pcc_rule_t rule, size_t offset".freeze
        if @location
          erbout << ", pcc_location_t offset_loc".freeze
        end
        erbout << ") {\n    while(1) {\n        const size_t old_offset = ctx->position_offset;\n        pcc_thunk_chunk_t *chunk;\n        pcc_lr_answer_t *answer;\n        pcc_rule_set_t limits;\n        ctx->position_offset = offset;\n".freeze

        if @location
          erbout << "        ctx->position_offset_loc = offset_loc;\n".freeze
        end
        erbout << "        pcc_rule_set__init(ctx->auxil, &limits);\n        pcc_rule_set__add(ctx->auxil, &limits, rule);\n        chunk = rule(ctx, offset".freeze

        if @location
          erbout << ", offset_loc".freeze
        end
        erbout << ", &limits);\n        pcc_rule_set__term(ctx->auxil, &limits);\n        if (!chunk)\n            break;\n        if (ctx->position_offset <= old_offset) {\n            pcc_thunk_chunk__destroy(ctx, chunk);\n            break;\n        }\n        answer = pcc_lr_table__get_answer(ctx, &ctx->lrtable, offset, rule);\n        pcc_lr_answer__set_chunk(ctx, answer, chunk);\n        answer->offset = ctx->position_offset;\n".freeze

        if @location
          erbout << "        answer->offset_loc = ctx->position_offset_loc;\n".freeze
        end
        erbout << "    }\n}\n\nMARK_FUNC_AS_USED\nstatic pcc_thunk_chunk_t *pcc_get_rule_answer(pcc_context_t *ctx, pcc_rule_t rule) {\n    pcc_thunk_chunk_t *c = NULL;\n    size_t offset = ctx->position_offset;\n".freeze

        if @location
          erbout << "    pcc_location_t offset_loc = ctx->position_offset_loc;\n".freeze
        end
        erbout << "    pcc_lr_answer_t *a = pcc_lr_table__get_answer(ctx, &ctx->lrtable, offset, rule);\n\n    if (a == NULL) {\n        a = pcc_lr_answer__create(ctx, offset".freeze

        if @location
          erbout << ", offset_loc".freeze
        end
        erbout << ");\n        pcc_lr_table__set_answer(ctx, &ctx->lrtable, offset, rule, a);\n        c = rule(ctx, offset".freeze

        if @location
          erbout << ", offset_loc".freeze
        end
        erbout << ", NULL);\n        pcc_lr_answer__set_chunk(ctx, a, c);\n        a->offset = ctx->position_offset;\n".freeze

        if @location
          erbout << "        a->offset_loc = ctx->position_offset_loc;\n".freeze
        end
        erbout << "        if (a->grow) {\n            pcc_grow_lr(ctx, rule, offset".freeze

        if @location
          erbout << ", offset_loc".freeze
        end
        erbout << ");\n            a->grow = PCC_FALSE;\n            ctx->position_offset = a->offset;\n            return a->chunk;\n        }\n        return c;\n    } else if (a->fail) {\n        pcc_lr_answer__set_chunk(ctx, a, NULL);\n        a->grow = PCC_TRUE;\n        return NULL;\n    }\n    ctx->position_offset = a->offset;\n    return a->chunk;\n}\n\nMARK_FUNC_AS_USED\nstatic pcc_bool_t pcc_apply_rule(pcc_context_t *ctx, pcc_rule_t rule, pcc_thunk_array_t *thunks, pcc_value_t *value, size_t offset".freeze

        if @location
          erbout << ", pcc_location_t offset_loc".freeze
        end
        erbout << ", pcc_rule_set_t *limits) {\n    static pcc_value_t null;\n    pcc_thunk_chunk_t *c;\n    if (limits != NULL) {\n        pcc_lr_answer_t *a;\n        pcc_rule_set__add(ctx->auxil, limits, rule);\n        c = rule(ctx, offset".freeze

        if @location
          erbout << ", offset_loc".freeze
        end
        erbout << ", limits);\n        a = pcc_lr_table__get_answer(ctx, &ctx->lrtable, offset, rule);\n        if (a == NULL || ctx->position_offset <= a->offset) {\n            c = a->chunk;\n            ctx->position_offset = a->offset;\n        } else {\n            pcc_lr_answer__set_chunk(ctx, a, c);\n            a->offset = ctx->position_offset;\n        }\n    } else {\n        c = pcc_get_rule_answer(ctx, rule);\n    }\n    if (c == NULL) return PCC_FALSE;\n    if (value == NULL) value = &null;\n    memset(value, 0, sizeof(pcc_value_t)); /* in case */\n    pcc_thunk_array__add(ctx->auxil, thunks, pcc_thunk__create_node(ctx->auxil, &c->thunks, value));\n    return PCC_TRUE;\n}\n\nMARK_FUNC_AS_USED\nstatic void pcc_do_action(pcc_context_t *ctx, const pcc_thunk_array_t *thunks, pcc_value_t *value) {\n    size_t i;\n    for (i = 0; i < thunks->len; i++) {\n        pcc_thunk_t *const thunk = thunks->buf[i];\n        switch (thunk->type) {\n        case PCC_THUNK_LEAF:\n            thunk->data.leaf.action(ctx, thunk, value);\n            break;\n        case PCC_THUNK_NODE:\n            pcc_do_action(ctx, thunk->data.node.thunks, thunk->data.node.value);\n            break;\n        default: /* unknown */\n            break;\n        }\n    }\n}\n\n".freeze

        @root.rules.each do |rule|
          rule.codes.each do |code|
            erbout << "static void pcc_action_#{rule.name}_#{code.index}(#{prefix}_context_t *__pcc_ctx, pcc_thunk_t *__pcc_in, pcc_value_t *__pcc_out) {\n#define auxil (__pcc_ctx->auxil)\n#define __ (*__pcc_out)\n".freeze

            code.vars.each do |ref|
              erbout << "#define #{ref.var} (*__pcc_in->data.leaf.values.buf[#{ref.index}])\n".freeze
            end
            erbout << "#define _0 pcc_get_capture_string(__pcc_ctx, &__pcc_in->data.leaf.capt0)\n#define _0s ((const size_t)(__pcc_ctx->buffer_start_position + __pcc_in->data.leaf.capt0.range.start))\n#define _0e ((const size_t)(__pcc_ctx->buffer_start_position + __pcc_in->data.leaf.capt0.range.end))\n".freeze

            if @location
              erbout << "#define _0sl ((const pcc_location_t)(pcc_location_add(__pcc_ctx->buffer_start_position_loc, __pcc_in->data.leaf.capt0.range.start_loc)))\n#define _0el ((const pcc_location_t)(pcc_location_add(__pcc_ctx->buffer_start_position_loc, __pcc_in->data.leaf.capt0.range.end_loc)))\n".freeze
            end
            if @capture_in_code
              erbout << "#define _0c __pcc_in->data.leaf.capt0\n".freeze
            end
            code.capts.each do |capture|
              erbout << "#define _#{capture.index + 1} pcc_get_capture_string(__pcc_ctx, __pcc_in->data.leaf.capts.buf[#{capture.index}])\n#define _#{capture.index + 1}s ((const size_t)(__pcc_ctx->buffer_start_position + __pcc_in->data.leaf.capts.buf[#{capture.index}]->range.start))\n#define _#{capture.index + 1}e ((const size_t)(__pcc_ctx->buffer_start_position + __pcc_in->data.leaf.capts.buf[#{capture.index}]->range.end))\n".freeze

              if @location
                erbout << "#define _#{capture.index + 1}sl ((const pcc_location_t)(pcc_location_add(__pcc_ctx->buffer_start_position_loc, __pcc_in->data.leaf.capts.buf[#{capture.index}]->range.start_loc)))\n#define _#{capture.index + 1}el ((const pcc_location_t)(pcc_location_add(__pcc_ctx->buffer_start_position_loc, __pcc_in->data.leaf.capts.buf[#{capture.index}]->range.end_loc)))\n".freeze
              end
              next unless @capture_in_code

              erbout << "#define _#{capture.index + 1}c (*__pcc_in->data.leaf.capts.buf[#{capture.index}])\n".freeze
            end
            erbout << "#{stream.get_code_block(code.code, 4, @iname)}".freeze
            code.capts.reverse_each do |capture|
              if @location
                erbout << "#undef _#{capture.index + 1}el\n#undef _#{capture.index + 1}sl\n".freeze
              end
              erbout << "#undef _#{capture.index + 1}e\n#undef _#{capture.index + 1}s\n#undef _#{capture.index + 1}\n".freeze
            end
            erbout << "#undef _0e\n#undef _0s\n#undef _0\n".freeze

            code.vars.reverse_each do |ref|
              erbout << "#undef #{ref.var}\n".freeze
            end
            erbout << "#undef __\n#undef auxil\n}\n\n".freeze
          end
        end
        @root.rules.each do |rule|
          erbout << "static pcc_thunk_chunk_t *pcc_evaluate_rule_#{rule.name}(pcc_context_t *ctx, size_t offset".freeze
          if @location
            erbout << ", pcc_location_t offset_loc".freeze
          end
          erbout << ", pcc_rule_set_t *limits);\n".freeze
        end
        erbout << "\n".freeze

        @root.rules.each do |rule|
          gen = ::Packcr::Generator.new(rule, @ascii, @location)
          erbout << "#{gen.generate_code(rule, 0, 0, false)}\n".freeze
        end
        erbout << "#{prefix}_context_t *#{prefix}_create(#{auxil_def}auxil) {\n    return pcc_context__create(auxil);\n}\n\nint #{prefix}_parse(#{prefix}_context_t *ctx, #{value_def}*ret) {\n    size_t pos = ctx->buffer_start_position;\n".freeze

        if !@root.rules.empty?
          erbout << "    if (pcc_apply_rule(ctx, pcc_evaluate_rule_#{@root.rules[0].name}, &ctx->thunks, ret, ctx->position_offset".freeze
          if @location
            erbout << ", ctx->position_offset_loc".freeze
          end
          erbout << ", NULL))\n        pcc_do_action(ctx, &ctx->thunks, ret);\n    else\n        PCC_ERROR(ctx->auxil);\n    pcc_commit_buffer(ctx);\n".freeze
        end
        erbout << "    pcc_thunk_array__revert(ctx->auxil, &ctx->thunks, 0);\n    return pos != ctx->buffer_start_position && pcc_refill_buffer(ctx, 1) >= 1;\n}\n\nvoid #{prefix}_destroy(#{prefix}_context_t *ctx) {\n    pcc_context__destroy(ctx);\n}\n".freeze

        if !code(:lsource).empty?
          erbout << "\n".freeze

          code(:lsource).each do |code|
            erbout << "#{stream.get_code_block(code, 0, @iname)}".freeze
          end
        end
        erbout
      when :rb
        erbout = +""
        erbout << "# A packrat parser generated by PackCR #{Packcr::VERSION}\n".freeze

        if !code(:source).empty?
          erbout << "\n".freeze

          code(:source).each do |code|
            erbout << "#{stream.get_code_block(code, 0, @iname)}".freeze
          end
        end
        erbout << "\nclass #{class_name}\n  def initialize(".freeze
        if @auxil_type
          erbout << "#{auxil_type}, ".freeze
        end
        erbout << "debug: false)\n".freeze

        if @utf8
          erbout << "    @buffer = +\"\"\n".freeze

        else
          erbout << "    @buffer = +\"\".b\n".freeze
        end
        erbout << "\n    @buffer_start_position = 0\n    @position_offset = 0\n    @level = 0\n    @thunk = ThunkNode.new([], nil, 0)\n    @memos = LrMemoTable.new\n    @debug = debug\n    @global_values = {}\n".freeze

        if @location
          erbout << "    @buffer_start_position_loc = Location.new\n    @position_offset_loc = Location.new\n".freeze
        end
        code(:init).each do |code|
          erbout << "#{stream.get_code_block(code, 4, @iname)}".freeze
        end
        erbout << "  end\n\n  def debug\n    yield if @debug\n  end\n\n  def getc\n".freeze

        if @utf8
          erbout << "    $stdin.getc\n".freeze

        else
          erbout << "    $stdin.getc&.b\n".freeze
        end
        erbout << "  end\n\n  def refill_buffer(num, mode = nil)\n    len = @buffer.length\n    if len >= @position_offset + num\n      return len - @position_offset\n    end\n    while len < @position_offset + num\n      c = getc\n      break if !c\n      @buffer << c\n      len = @buffer.length\n    end\n    return len - @position_offset\n  end\n\n  def commit_buffer\n    @buffer = @buffer[@position_offset, @buffer.length - @position_offset]\n    @buffer_start_position += @position_offset\n    @memos.clear\n    @position_offset = 0\n".freeze

        if @location
          erbout << "    @buffer_start_position_loc = @buffer_start_position_loc + @position_offset_loc\n    @position_offset_loc = Location.new\n".freeze
        end
        erbout << "  end\n\n  def parse\n    pos = @buffer_start_position\n".freeze

        if !@root.rules.empty?
          erbout << "    if apply_rule(:evaluate_rule_#{@root.rules[0].name}, @thunk.thunks, nil, 0, @buffer_start_position".freeze
          if @location
            erbout << ", @buffer_start_position_loc".freeze
          end
          erbout << ")\n      @thunk.do_action(self, nil, 0)\n    else\n      raise SyntaxError, \"can't parse\"\n    end\n    commit_buffer\n".freeze
        end
        erbout << "    @thunk.clear\n    refill_buffer(1) >= 1 && pos != @buffer_start_position\n  end\n\n  def run\n    nil while parse\n  end\n\n".freeze

        @root.rules.each do |rule|
          rule.codes.each do |code|
            erbout << "  def action_#{rule.name}_#{code.index}(__pcc_in, __pcc_vars, __pcc_index)\n    ____ = (__pcc_vars[__pcc_index] ||= Value.new).value if __pcc_vars\n".freeze

            code.vars.each do |ref|
              erbout << "    #{ref.var} = (__pcc_in.value_refs[#{ref.index}]  ||= Value.new).value\n".freeze
            end
            erbout << "    __0 = __pcc_in.capt0.capture_string(@buffer)\n    __0s = @buffer_start_position + __pcc_in.capt0.range_start\n    __0e = @buffer_start_position + __pcc_in.capt0.range_end\n".freeze

            if @location
              erbout << "    __0sl = @buffer_start_position_loc + __pcc_in.capt0.start_loc\n    __0el = @buffer_start_position_loc + __pcc_in.capt0.end_loc\n".freeze
            end
            if @capture_in_code
              erbout << "    __0c = __pcc_in.capt0\n".freeze
            end
            code.capts.each do |capture|
              erbout << "    __#{capture.index + 1} = __pcc_in.capts[#{capture.index}].capture_string(@buffer)\n    __#{capture.index + 1}s = @buffer_start_position + __pcc_in.capts[#{capture.index}].range_start\n    __#{capture.index + 1}e = @buffer_start_position + __pcc_in.capts[#{capture.index}].range_end\n".freeze

              if @location
                erbout << "    __#{capture.index + 1}sl = @buffer_start_position_loc + __pcc_in.capts[#{capture.index}].start_loc\n    __#{capture.index + 1}el = @buffer_start_position_loc + __pcc_in.capts[#{capture.index}].end_loc\n".freeze
              end
              next unless @capture_in_code

              erbout << "    __#{capture.index + 1}c = __pcc_in.capts[#{capture.index}]\n".freeze
            end

            erbout << "#{stream.get_code_block(code.code, 4, @iname)}\n    __pcc_vars[__pcc_index].value = ____ if __pcc_vars\n  end\n\n".freeze
          end
        end
        @root.rules.each do |rule|
          gen = ::Packcr::Generator.new(rule, @ascii, @location, :rb)

          erbout << "#{gen.generate_code(rule, 0, 2, false)}\n".freeze
        end
        erbout << "  def grow_lr(rule, offset".freeze
        if @location
          erbout << ", offset_loc".freeze
        end
        erbout << ")\n    while true\n      old_offset = @position_offset\n      @position_offset = offset\n".freeze

        if @location
          erbout << "      @position_offset_loc = offset_loc\n".freeze
        end
        erbout << "      answer = public_send(rule, offset".freeze
        if @location
          erbout << ", offset_loc".freeze
        end
        erbout << ", limits: {rule => true})\n      if !answer || @position_offset <= old_offset\n        break\n      end\n      memo = @memos[offset, rule]\n      memo.answer = answer\n      memo.offset = @position_offset\n".freeze

        if @location
          erbout << "      memo.offset_loc = @position_offset_loc\n".freeze
        end
        erbout << "    end\n  end\n\n  def rule_answer(rule)\n    offset = @position_offset\n".freeze

        if @location
          erbout << "    offset_loc = @position_offset_loc\n".freeze
        end
        erbout << "    memo = @memos[offset, rule]\n\n    if !memo\n      memo = LrMemo.new(offset".freeze

        if @location
          erbout << ", offset_loc".freeze
        end
        erbout << ")\n      @memos[offset, rule] = memo\n      answer = public_send(rule, offset".freeze

        if @location
          erbout << ", offset_loc".freeze
        end
        erbout << ")\n      memo.answer = answer\n      memo.offset = @position_offset\n".freeze

        if @location
          erbout << "      memo.offset_loc = @position_offset_loc\n".freeze
        end
        erbout << "      if memo.grow\n        grow_lr(rule, offset".freeze

        if @location
          erbout << ", offset_loc".freeze
        end
        erbout << ")\n        memo.grow = false\n        answer = memo.answer\n        @position_offset = memo.offset\n      end\n      return answer\n    elsif memo.fail\n      memo.answer = nil\n      memo.grow = true\n      return nil\n    else\n      @position_offset = memo.offset\n      return memo.answer\n    end\n  end\n\n  def apply_rule(rule, thunks, values, index, offset".freeze
        if @location
          erbout << ", offset_loc".freeze
        end
        erbout << ", limits: nil)\n    if limits\n      limits = limits.merge(rule => true)\n      answer = public_send(rule, offset".freeze

        if @location
          erbout << ", offset_loc".freeze
        end
        erbout << ", limits: limits)\n      memo = @memos[offset, rule]\n      if !answer || @position_offset <= memo.offset\n        answer = memo.answer\n        @position_offset = memo.offset\n      else\n        memo.answer = answer\n        memo.offset = @position_offset\n      end\n    else\n      answer = rule_answer(rule)\n    end\n\n    if !answer\n      return false\n    end\n    values ||= @global_values\n    thunks << ThunkNode.new(answer.thunks, values, index)\n    return true\n  end\n\n  def do_action(thunks, values, index)\n    thunks.each do |thunk|\n      thunk.do_action(self, values, index)\n    end\n  end\n\n".freeze

        code(:location).each do |code|
          erbout << "#{stream.get_code_block(code, 2, @iname)}\n".freeze
        end
        erbout << "  class LrMemoTable\n    def initialize\n      @memos = {}\n    end\n\n    def clear\n      @memos.clear\n    end\n\n    def []=(index, rule_name, memo)\n      entry = @memos[index] ||= {}\n      entry[rule_name] = memo\n    end\n\n    def [](index, rule_name)\n      @memos.dig(index, rule_name)\n    end\n  end\n\n  class LrMemo\n    attr_accessor :grow, :answer, :offset, :fail\n".freeze

        if @location
          erbout << "    attr_accessor :offset_loc\n".freeze
        end
        erbout << "\n    def initialize(offset".freeze
        if @location
          erbout << ", offset_loc".freeze
        end
        erbout << ")\n      @offset = offset\n".freeze

        if @location
          erbout << "      @offset_loc = offset_loc\n".freeze
        end
        erbout << "      @fail = true\n      @grow = false\n    end\n\n    def answer=(answer)\n      @fail = nil\n      @answer = answer\n    end\n  end\n\n  class ThunkChunk\n    attr_accessor :thunks, :capts, :pos, :values\n".freeze

        if @location
          erbout << "    attr_accessor :pos_loc\n".freeze
        end
        erbout << "\n    def initialize\n      super\n      @thunks = []\n      @capts = {}\n      @pos = 0\n      @values = {}\n    end\n\n    def resize_captures(len)\n      len.times do |i|\n        @capts[i] = Capture.new\n      end\n    end\n  end\n\n  class ThunkLeaf\n    attr_accessor :capt0, :capts, :value_refs, :action\n\n    def initialize(action, capt0 = Capture.new, value_refs = {}, capts = {})\n      @value_refs = value_refs\n      @capts = capts\n      @capt0 = capt0\n      @action = action\n    end\n\n    def do_action(ctx, values, index)\n      ctx.public_send(action, self, values, index)\n    end\n  end\n\n  class ThunkNode\n    attr_accessor :thunks, :values, :index\n\n    def initialize(thunks, values, index)\n      @thunks = thunks\n      @values = values\n      @index = index\n      values[index] ||= Value.new if values\n    end\n\n    def do_action(ctx, _values, _index)\n      @thunks.each do |thunk|\n        thunk.do_action(ctx, @values, @index)\n      end\n    end\n\n    def clear\n      @thunks.clear\n    end\n  end\n\n  class Capture\n    attr_accessor :range_start, :range_end\n".freeze

        if @location
          erbout << "    attr_accessor :start_loc, :end_loc\n".freeze
        end
        erbout << "\n    def initialize(range_start = 0, range_end = 0".freeze
        if @location
          erbout << ", start_loc = nil, end_loc = nil".freeze
        end
        erbout << ")\n      @range_start = range_start\n      @range_end = range_end\n".freeze

        if @location
          erbout << "      @start_loc = start_loc || Location.new\n      @end_loc = end_loc || Location.new\n".freeze
        end
        erbout << "    end\n\n    def capture_string(buffer)\n      @capture_string ||= buffer[@range_start, @range_end - @range_start]\n    end\n  end\n\n  class Value\n    attr_accessor :value\n  end\nend\n".freeze

        if !code(:lsource).empty?
          erbout << "\n".freeze

          code(:lsource).each do |code|
            erbout << "#{stream.get_code_block(code, 0, @iname)}".freeze
          end
        end
        erbout
      end
    end
  end
end
