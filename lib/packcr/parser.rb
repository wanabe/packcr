# A packrat parser generated by PackCR 0.0.5

class Packcr::Parser
  def initialize(ctx = nil, ifile = nil, debug: false)
    @buffer = +""

    @pos = 0
    @cur = 0
    @level = 0
    @lrstack = []
    @thunk = ThunkNode.new([], nil, 0)
    @lrtable = LrTable.new
    @debug = debug
    @global_values = {}
    @pos_loc = Location.new
    @cur_loc = Location.new
    @ctx = ctx || self
    @ifile = ifile || stdin
    @utf8 = true
    @ascii = false
    @lang = :rb
  end

  def debug
    yield if @debug
  end

  def getc
    $stdin.getc
  end

  def refill_buffer(num, mode = nil)
    len = @buffer.length
    if len >= @cur + num
      return len - @cur
    end
    while len < @cur + num
      c = getc
      break if !c
      @buffer << c
      len = @buffer.length
    end
    return len - @cur
  end

  def commit_buffer
    @buffer = @buffer[@cur, @buffer.length - @cur]
    @pos += @cur
    @lrtable.clear
    @cur = 0
    @pos_loc = @pos_loc + @cur_loc
    @cur_loc = Location.new
  end

  def parse
    pos = @pos
    if apply_rule(:evaluate_rule_statement, @thunk.thunks, nil, 0)
      @thunk.do_action(self, nil, 0)
    else
      raise SyntaxError, "can't parse"
    end
    commit_buffer
    @thunk.clear
    refill_buffer(1) >= 1 && pos != @pos
  end

  def run
    nil while parse
  end

  def action_statement_0(__pcc_in, __pcc_vars, __pcc_index)
    ____ = (__pcc_vars[__pcc_index] ||= Value.new).value if __pcc_vars
    __0 = __pcc_in.capt0.capture_string(@buffer)
    __0s = @pos + __pcc_in.capt0.range_start
    __0e = @pos + __pcc_in.capt0.range_end
    __0sl = @pos_loc + __pcc_in.capt0.start_loc
    __0el = @pos_loc + __pcc_in.capt0.end_loc
    @ctx.error __0sl.linenum + 1, __0sl.charnum + 1, "Illegal syntax"

    __pcc_vars[__pcc_index].value = ____ if __pcc_vars
  end

  def action_supported_language_0(__pcc_in, __pcc_vars, __pcc_index)
    ____ = (__pcc_vars[__pcc_index] ||= Value.new).value if __pcc_vars
    __0 = __pcc_in.capt0.capture_string(@buffer)
    __0s = @pos + __pcc_in.capt0.range_start
    __0e = @pos + __pcc_in.capt0.range_end
    __0sl = @pos_loc + __pcc_in.capt0.start_loc
    __0el = @pos_loc + __pcc_in.capt0.end_loc
    @ctx.error __0sl.linenum + 1, __0sl.charnum + 1, "Not supported language: #{__0}"

    __pcc_vars[__pcc_index].value = ____ if __pcc_vars
  end

  def action_directive_include_0(__pcc_in, __pcc_vars, __pcc_index)
    ____ = (__pcc_vars[__pcc_index] ||= Value.new).value if __pcc_vars
    blocks = (__pcc_in.value_refs[0]  ||= Value.new).value
    __0 = __pcc_in.capt0.capture_string(@buffer)
    __0s = @pos + __pcc_in.capt0.range_start
    __0e = @pos + __pcc_in.capt0.range_end
    __0sl = @pos_loc + __pcc_in.capt0.start_loc
    __0el = @pos_loc + __pcc_in.capt0.end_loc
    blocks.each { |b| @ctx.code(:esource)  << Packcr::CodeBlock.new(b, __0sl.linenum, __0sl.charnum) }

    __pcc_vars[__pcc_index].value = ____ if __pcc_vars
  end

  def action_directive_include_1(__pcc_in, __pcc_vars, __pcc_index)
    ____ = (__pcc_vars[__pcc_index] ||= Value.new).value if __pcc_vars
    blocks = (__pcc_in.value_refs[0]  ||= Value.new).value
    __0 = __pcc_in.capt0.capture_string(@buffer)
    __0s = @pos + __pcc_in.capt0.range_start
    __0e = @pos + __pcc_in.capt0.range_end
    __0sl = @pos_loc + __pcc_in.capt0.start_loc
    __0el = @pos_loc + __pcc_in.capt0.end_loc
    blocks.each { |b| @ctx.code(:source)   << Packcr::CodeBlock.new(b, __0sl.linenum, __0sl.charnum) }

    __pcc_vars[__pcc_index].value = ____ if __pcc_vars
  end

  def action_directive_include_2(__pcc_in, __pcc_vars, __pcc_index)
    ____ = (__pcc_vars[__pcc_index] ||= Value.new).value if __pcc_vars
    blocks = (__pcc_in.value_refs[0]  ||= Value.new).value
    __0 = __pcc_in.capt0.capture_string(@buffer)
    __0s = @pos + __pcc_in.capt0.range_start
    __0e = @pos + __pcc_in.capt0.range_end
    __0sl = @pos_loc + __pcc_in.capt0.start_loc
    __0el = @pos_loc + __pcc_in.capt0.end_loc
    blocks.each { |b| @ctx.code(:lheader)  << Packcr::CodeBlock.new(b, __0sl.linenum, __0sl.charnum) }

    __pcc_vars[__pcc_index].value = ____ if __pcc_vars
  end

  def action_directive_include_3(__pcc_in, __pcc_vars, __pcc_index)
    ____ = (__pcc_vars[__pcc_index] ||= Value.new).value if __pcc_vars
    blocks = (__pcc_in.value_refs[0]  ||= Value.new).value
    __0 = __pcc_in.capt0.capture_string(@buffer)
    __0s = @pos + __pcc_in.capt0.range_start
    __0e = @pos + __pcc_in.capt0.range_end
    __0sl = @pos_loc + __pcc_in.capt0.start_loc
    __0el = @pos_loc + __pcc_in.capt0.end_loc
    blocks.each { |b| @ctx.code(:lsource)  << Packcr::CodeBlock.new(b, __0sl.linenum, __0sl.charnum) }

    __pcc_vars[__pcc_index].value = ____ if __pcc_vars
  end

  def action_directive_include_4(__pcc_in, __pcc_vars, __pcc_index)
    ____ = (__pcc_vars[__pcc_index] ||= Value.new).value if __pcc_vars
    blocks = (__pcc_in.value_refs[0]  ||= Value.new).value
    __0 = __pcc_in.capt0.capture_string(@buffer)
    __0s = @pos + __pcc_in.capt0.range_start
    __0e = @pos + __pcc_in.capt0.range_end
    __0sl = @pos_loc + __pcc_in.capt0.start_loc
    __0el = @pos_loc + __pcc_in.capt0.end_loc
    blocks.each { |b| @ctx.code(:header)   << Packcr::CodeBlock.new(b, __0sl.linenum, __0sl.charnum) }

    __pcc_vars[__pcc_index].value = ____ if __pcc_vars
  end

  def action_directive_include_5(__pcc_in, __pcc_vars, __pcc_index)
    ____ = (__pcc_vars[__pcc_index] ||= Value.new).value if __pcc_vars
    blocks = (__pcc_in.value_refs[0]  ||= Value.new).value
    __0 = __pcc_in.capt0.capture_string(@buffer)
    __0s = @pos + __pcc_in.capt0.range_start
    __0e = @pos + __pcc_in.capt0.range_end
    __0sl = @pos_loc + __pcc_in.capt0.start_loc
    __0el = @pos_loc + __pcc_in.capt0.end_loc
    blocks.each { |b| @ctx.code(:location) << Packcr::CodeBlock.new(b, __0sl.linenum, __0sl.charnum) }

    __pcc_vars[__pcc_index].value = ____ if __pcc_vars
  end

  def action_directive_include_6(__pcc_in, __pcc_vars, __pcc_index)
    ____ = (__pcc_vars[__pcc_index] ||= Value.new).value if __pcc_vars
    blocks = (__pcc_in.value_refs[0]  ||= Value.new).value
    __0 = __pcc_in.capt0.capture_string(@buffer)
    __0s = @pos + __pcc_in.capt0.range_start
    __0e = @pos + __pcc_in.capt0.range_end
    __0sl = @pos_loc + __pcc_in.capt0.start_loc
    __0el = @pos_loc + __pcc_in.capt0.end_loc
    blocks.each { |b| @ctx.code(:init)     << Packcr::CodeBlock.new(b, __0sl.linenum, __0sl.charnum) }

    __pcc_vars[__pcc_index].value = ____ if __pcc_vars
  end

  def action_directive_include_7(__pcc_in, __pcc_vars, __pcc_index)
    ____ = (__pcc_vars[__pcc_index] ||= Value.new).value if __pcc_vars
    blocks = (__pcc_in.value_refs[0]  ||= Value.new).value
    __0 = __pcc_in.capt0.capture_string(@buffer)
    __0s = @pos + __pcc_in.capt0.range_start
    __0e = @pos + __pcc_in.capt0.range_end
    __0sl = @pos_loc + __pcc_in.capt0.start_loc
    __0el = @pos_loc + __pcc_in.capt0.end_loc
    blocks.each { |b| Packcr::BroadCast.new(@ctx.code(:eheader), @ctx.code(:esource)) << Packcr::CodeBlock.new(b, __0sl.linenum, __0sl.charnum) }

    __pcc_vars[__pcc_index].value = ____ if __pcc_vars
  end

  def action_directive_include_8(__pcc_in, __pcc_vars, __pcc_index)
    ____ = (__pcc_vars[__pcc_index] ||= Value.new).value if __pcc_vars
    blocks = (__pcc_in.value_refs[0]  ||= Value.new).value
    __0 = __pcc_in.capt0.capture_string(@buffer)
    __0s = @pos + __pcc_in.capt0.range_start
    __0e = @pos + __pcc_in.capt0.range_end
    __0sl = @pos_loc + __pcc_in.capt0.start_loc
    __0el = @pos_loc + __pcc_in.capt0.end_loc
    blocks.each { |b| Packcr::BroadCast.new(@ctx.code(:header),  @ctx.code(:source))  << Packcr::CodeBlock.new(b, __0sl.linenum, __0sl.charnum) }

    __pcc_vars[__pcc_index].value = ____ if __pcc_vars
  end

  def action_directive_include_9(__pcc_in, __pcc_vars, __pcc_index)
    ____ = (__pcc_vars[__pcc_index] ||= Value.new).value if __pcc_vars
    blocks = (__pcc_in.value_refs[0]  ||= Value.new).value
    __0 = __pcc_in.capt0.capture_string(@buffer)
    __0s = @pos + __pcc_in.capt0.range_start
    __0e = @pos + __pcc_in.capt0.range_end
    __0sl = @pos_loc + __pcc_in.capt0.start_loc
    __0el = @pos_loc + __pcc_in.capt0.end_loc
    __1 = __pcc_in.capts[0].capture_string(@buffer)
    __1s = @pos + __pcc_in.capts[0].range_start
    __1e = @pos + __pcc_in.capts[0].range_end
    __1sl = @pos_loc + __pcc_in.capts[0].start_loc
    __1el = @pos_loc + __pcc_in.capts[0].end_loc
    blocks.each { @ctx.error __0sl.linenum + 1, __0sl.charnum + 1, "Invalid directive: #{__1}" }

    __pcc_vars[__pcc_index].value = ____ if __pcc_vars
  end

  def action_code_blocks_0(__pcc_in, __pcc_vars, __pcc_index)
    ____ = (__pcc_vars[__pcc_index] ||= Value.new).value if __pcc_vars
    blocks = (__pcc_in.value_refs[0]  ||= Value.new).value
    block = (__pcc_in.value_refs[1]  ||= Value.new).value
    __0 = __pcc_in.capt0.capture_string(@buffer)
    __0s = @pos + __pcc_in.capt0.range_start
    __0e = @pos + __pcc_in.capt0.range_end
    __0sl = @pos_loc + __pcc_in.capt0.start_loc
    __0el = @pos_loc + __pcc_in.capt0.end_loc
    blocks.push(block) if block; ____ = blocks

    __pcc_vars[__pcc_index].value = ____ if __pcc_vars
  end

  def action_code_blocks_1(__pcc_in, __pcc_vars, __pcc_index)
    ____ = (__pcc_vars[__pcc_index] ||= Value.new).value if __pcc_vars
    block = (__pcc_in.value_refs[1]  ||= Value.new).value
    __0 = __pcc_in.capt0.capture_string(@buffer)
    __0s = @pos + __pcc_in.capt0.range_start
    __0e = @pos + __pcc_in.capt0.range_end
    __0sl = @pos_loc + __pcc_in.capt0.start_loc
    __0el = @pos_loc + __pcc_in.capt0.end_loc
    ____ = block ? [block] : []

    __pcc_vars[__pcc_index].value = ____ if __pcc_vars
  end

  def action_directive_string_0(__pcc_in, __pcc_vars, __pcc_index)
    ____ = (__pcc_vars[__pcc_index] ||= Value.new).value if __pcc_vars
    strings = (__pcc_in.value_refs[0]  ||= Value.new).value
    __0 = __pcc_in.capt0.capture_string(@buffer)
    __0s = @pos + __pcc_in.capt0.range_start
    __0e = @pos + __pcc_in.capt0.range_end
    __0sl = @pos_loc + __pcc_in.capt0.start_loc
    __0el = @pos_loc + __pcc_in.capt0.end_loc
    strings.each { |str| @ctx.value_type = str }

    __pcc_vars[__pcc_index].value = ____ if __pcc_vars
  end

  def action_directive_string_1(__pcc_in, __pcc_vars, __pcc_index)
    ____ = (__pcc_vars[__pcc_index] ||= Value.new).value if __pcc_vars
    strings = (__pcc_in.value_refs[0]  ||= Value.new).value
    __0 = __pcc_in.capt0.capture_string(@buffer)
    __0s = @pos + __pcc_in.capt0.range_start
    __0e = @pos + __pcc_in.capt0.range_end
    __0sl = @pos_loc + __pcc_in.capt0.start_loc
    __0el = @pos_loc + __pcc_in.capt0.end_loc
    strings.each { |str| @ctx.auxil_type = str }

    __pcc_vars[__pcc_index].value = ____ if __pcc_vars
  end

  def action_directive_string_2(__pcc_in, __pcc_vars, __pcc_index)
    ____ = (__pcc_vars[__pcc_index] ||= Value.new).value if __pcc_vars
    strings = (__pcc_in.value_refs[0]  ||= Value.new).value
    __0 = __pcc_in.capt0.capture_string(@buffer)
    __0s = @pos + __pcc_in.capt0.range_start
    __0e = @pos + __pcc_in.capt0.range_end
    __0sl = @pos_loc + __pcc_in.capt0.start_loc
    __0el = @pos_loc + __pcc_in.capt0.end_loc
    strings.each { |str| @ctx.prefix = str }

    __pcc_vars[__pcc_index].value = ____ if __pcc_vars
  end

  def action_directive_string_3(__pcc_in, __pcc_vars, __pcc_index)
    ____ = (__pcc_vars[__pcc_index] ||= Value.new).value if __pcc_vars
    str = (__pcc_in.value_refs[1]  ||= Value.new).value
    __0 = __pcc_in.capt0.capture_string(@buffer)
    __0s = @pos + __pcc_in.capt0.range_start
    __0e = @pos + __pcc_in.capt0.range_end
    __0sl = @pos_loc + __pcc_in.capt0.start_loc
    __0el = @pos_loc + __pcc_in.capt0.end_loc
    __1 = __pcc_in.capts[0].capture_string(@buffer)
    __1s = @pos + __pcc_in.capts[0].range_start
    __1e = @pos + __pcc_in.capts[0].range_end
    __1sl = @pos_loc + __pcc_in.capts[0].start_loc
    __1el = @pos_loc + __pcc_in.capts[0].end_loc
    @ctx.error __0sl.linenum + 1, __0sl.charnum + 1, "Invalid directive: #{__1}"

    __pcc_vars[__pcc_index].value = ____ if __pcc_vars
  end

  def action_directive_value_0(__pcc_in, __pcc_vars, __pcc_index)
    ____ = (__pcc_vars[__pcc_index] ||= Value.new).value if __pcc_vars
    __0 = __pcc_in.capt0.capture_string(@buffer)
    __0s = @pos + __pcc_in.capt0.range_start
    __0e = @pos + __pcc_in.capt0.range_end
    __0sl = @pos_loc + __pcc_in.capt0.start_loc
    __0el = @pos_loc + __pcc_in.capt0.end_loc
    @ctx.capture_in_code = true

    __pcc_vars[__pcc_index].value = ____ if __pcc_vars
  end

  def action_lang_strings_0(__pcc_in, __pcc_vars, __pcc_index)
    ____ = (__pcc_vars[__pcc_index] ||= Value.new).value if __pcc_vars
    strings = (__pcc_in.value_refs[0]  ||= Value.new).value
    string = (__pcc_in.value_refs[1]  ||= Value.new).value
    __0 = __pcc_in.capt0.capture_string(@buffer)
    __0s = @pos + __pcc_in.capt0.range_start
    __0e = @pos + __pcc_in.capt0.range_end
    __0sl = @pos_loc + __pcc_in.capt0.start_loc
    __0el = @pos_loc + __pcc_in.capt0.end_loc
    strings.push(string) if string; ____ = strings

    __pcc_vars[__pcc_index].value = ____ if __pcc_vars
  end

  def action_lang_strings_1(__pcc_in, __pcc_vars, __pcc_index)
    ____ = (__pcc_vars[__pcc_index] ||= Value.new).value if __pcc_vars
    string = (__pcc_in.value_refs[1]  ||= Value.new).value
    __0 = __pcc_in.capt0.capture_string(@buffer)
    __0s = @pos + __pcc_in.capt0.range_start
    __0e = @pos + __pcc_in.capt0.range_end
    __0sl = @pos_loc + __pcc_in.capt0.start_loc
    __0el = @pos_loc + __pcc_in.capt0.end_loc
    ____ = string ? [string] : []

    __pcc_vars[__pcc_index].value = ____ if __pcc_vars
  end

  def action_lang_string_0(__pcc_in, __pcc_vars, __pcc_index)
    ____ = (__pcc_vars[__pcc_index] ||= Value.new).value if __pcc_vars
    string = (__pcc_in.value_refs[0]  ||= Value.new).value
    __0 = __pcc_in.capt0.capture_string(@buffer)
    __0s = @pos + __pcc_in.capt0.range_start
    __0e = @pos + __pcc_in.capt0.range_end
    __0sl = @pos_loc + __pcc_in.capt0.start_loc
    __0el = @pos_loc + __pcc_in.capt0.end_loc
    ____ = string

    __pcc_vars[__pcc_index].value = ____ if __pcc_vars
  end

  def action_lang_string_1(__pcc_in, __pcc_vars, __pcc_index)
    ____ = (__pcc_vars[__pcc_index] ||= Value.new).value if __pcc_vars
    string = (__pcc_in.value_refs[0]  ||= Value.new).value
    __0 = __pcc_in.capt0.capture_string(@buffer)
    __0s = @pos + __pcc_in.capt0.range_start
    __0e = @pos + __pcc_in.capt0.range_end
    __0sl = @pos_loc + __pcc_in.capt0.start_loc
    __0el = @pos_loc + __pcc_in.capt0.end_loc
    __1 = __pcc_in.capts[0].capture_string(@buffer)
    __1s = @pos + __pcc_in.capts[0].range_start
    __1e = @pos + __pcc_in.capts[0].range_end
    __1sl = @pos_loc + __pcc_in.capts[0].start_loc
    __1el = @pos_loc + __pcc_in.capts[0].end_loc
    ____ = @ctx.lang == __1.to_sym ? string : nil

    __pcc_vars[__pcc_index].value = ____ if __pcc_vars
  end

  def action_rule_0(__pcc_in, __pcc_vars, __pcc_index)
    ____ = (__pcc_vars[__pcc_index] ||= Value.new).value if __pcc_vars
    name = (__pcc_in.value_refs[0]  ||= Value.new).value
    expr = (__pcc_in.value_refs[1]  ||= Value.new).value
    __0 = __pcc_in.capt0.capture_string(@buffer)
    __0s = @pos + __pcc_in.capt0.range_start
    __0e = @pos + __pcc_in.capt0.range_end
    __0sl = @pos_loc + __pcc_in.capt0.start_loc
    __0el = @pos_loc + __pcc_in.capt0.end_loc
    return unless expr
    rule =  Packcr::Node::RuleNode.new(expr, name, __0sl.linenum, __0sl.charnum)
    @ctx.root.rules << rule

    __pcc_vars[__pcc_index].value = ____ if __pcc_vars
  end

  def action_expression_0(__pcc_in, __pcc_vars, __pcc_index)
    ____ = (__pcc_vars[__pcc_index] ||= Value.new).value if __pcc_vars
    expr = (__pcc_in.value_refs[0]  ||= Value.new).value
    seq = (__pcc_in.value_refs[1]  ||= Value.new).value
    __0 = __pcc_in.capt0.capture_string(@buffer)
    __0s = @pos + __pcc_in.capt0.range_start
    __0e = @pos + __pcc_in.capt0.range_end
    __0sl = @pos_loc + __pcc_in.capt0.start_loc
    __0el = @pos_loc + __pcc_in.capt0.end_loc
    ____ = expr.alt(seq)

    __pcc_vars[__pcc_index].value = ____ if __pcc_vars
  end

  def action_expression_1(__pcc_in, __pcc_vars, __pcc_index)
    ____ = (__pcc_vars[__pcc_index] ||= Value.new).value if __pcc_vars
    seq = (__pcc_in.value_refs[1]  ||= Value.new).value
    __0 = __pcc_in.capt0.capture_string(@buffer)
    __0s = @pos + __pcc_in.capt0.range_start
    __0e = @pos + __pcc_in.capt0.range_end
    __0sl = @pos_loc + __pcc_in.capt0.start_loc
    __0el = @pos_loc + __pcc_in.capt0.end_loc
    ____ = seq

    __pcc_vars[__pcc_index].value = ____ if __pcc_vars
  end

  def action_sequence_0(__pcc_in, __pcc_vars, __pcc_index)
    ____ = (__pcc_vars[__pcc_index] ||= Value.new).value if __pcc_vars
    seq = (__pcc_in.value_refs[0]  ||= Value.new).value
    expr = (__pcc_in.value_refs[1]  ||= Value.new).value
    __0 = __pcc_in.capt0.capture_string(@buffer)
    __0s = @pos + __pcc_in.capt0.range_start
    __0e = @pos + __pcc_in.capt0.range_end
    __0sl = @pos_loc + __pcc_in.capt0.start_loc
    __0el = @pos_loc + __pcc_in.capt0.end_loc
    ____ = seq.seq(expr, cut: true)

    __pcc_vars[__pcc_index].value = ____ if __pcc_vars
  end

  def action_sequence_1(__pcc_in, __pcc_vars, __pcc_index)
    ____ = (__pcc_vars[__pcc_index] ||= Value.new).value if __pcc_vars
    seq = (__pcc_in.value_refs[0]  ||= Value.new).value
    code = (__pcc_in.value_refs[2]  ||= Value.new).value
    __0 = __pcc_in.capt0.capture_string(@buffer)
    __0s = @pos + __pcc_in.capt0.range_start
    __0e = @pos + __pcc_in.capt0.range_end
    __0sl = @pos_loc + __pcc_in.capt0.start_loc
    __0el = @pos_loc + __pcc_in.capt0.end_loc
    ____ = code ? Packcr::Node::ErrorNode.new(seq, Packcr::CodeBlock.new(code, __0sl.linenum, __0sl.charnum)) : seq

    __pcc_vars[__pcc_index].value = ____ if __pcc_vars
  end

  def action_sequence_2(__pcc_in, __pcc_vars, __pcc_index)
    ____ = (__pcc_vars[__pcc_index] ||= Value.new).value if __pcc_vars
    seq = (__pcc_in.value_refs[0]  ||= Value.new).value
    expr = (__pcc_in.value_refs[1]  ||= Value.new).value
    __0 = __pcc_in.capt0.capture_string(@buffer)
    __0s = @pos + __pcc_in.capt0.range_start
    __0e = @pos + __pcc_in.capt0.range_end
    __0sl = @pos_loc + __pcc_in.capt0.start_loc
    __0el = @pos_loc + __pcc_in.capt0.end_loc
    ____ = seq.seq(expr)

    __pcc_vars[__pcc_index].value = ____ if __pcc_vars
  end

  def action_sequence_3(__pcc_in, __pcc_vars, __pcc_index)
    ____ = (__pcc_vars[__pcc_index] ||= Value.new).value if __pcc_vars
    expr = (__pcc_in.value_refs[1]  ||= Value.new).value
    __0 = __pcc_in.capt0.capture_string(@buffer)
    __0s = @pos + __pcc_in.capt0.range_start
    __0e = @pos + __pcc_in.capt0.range_end
    __0sl = @pos_loc + __pcc_in.capt0.start_loc
    __0el = @pos_loc + __pcc_in.capt0.end_loc
    ____ = expr

    __pcc_vars[__pcc_index].value = ____ if __pcc_vars
  end

  def action_term_0(__pcc_in, __pcc_vars, __pcc_index)
    ____ = (__pcc_vars[__pcc_index] ||= Value.new).value if __pcc_vars
    node = (__pcc_in.value_refs[0]  ||= Value.new).value
    __0 = __pcc_in.capt0.capture_string(@buffer)
    __0s = @pos + __pcc_in.capt0.range_start
    __0e = @pos + __pcc_in.capt0.range_end
    __0sl = @pos_loc + __pcc_in.capt0.start_loc
    __0el = @pos_loc + __pcc_in.capt0.end_loc
    ____ = Packcr::Node::PredicateNode.new(node)

    __pcc_vars[__pcc_index].value = ____ if __pcc_vars
  end

  def action_term_1(__pcc_in, __pcc_vars, __pcc_index)
    ____ = (__pcc_vars[__pcc_index] ||= Value.new).value if __pcc_vars
    node = (__pcc_in.value_refs[0]  ||= Value.new).value
    __0 = __pcc_in.capt0.capture_string(@buffer)
    __0s = @pos + __pcc_in.capt0.range_start
    __0e = @pos + __pcc_in.capt0.range_end
    __0sl = @pos_loc + __pcc_in.capt0.start_loc
    __0el = @pos_loc + __pcc_in.capt0.end_loc
    ____ = Packcr::Node::PredicateNode.new(node, true)

    __pcc_vars[__pcc_index].value = ____ if __pcc_vars
  end

  def action_term_2(__pcc_in, __pcc_vars, __pcc_index)
    ____ = (__pcc_vars[__pcc_index] ||= Value.new).value if __pcc_vars
    node = (__pcc_in.value_refs[0]  ||= Value.new).value
    __0 = __pcc_in.capt0.capture_string(@buffer)
    __0s = @pos + __pcc_in.capt0.range_start
    __0e = @pos + __pcc_in.capt0.range_end
    __0sl = @pos_loc + __pcc_in.capt0.start_loc
    __0el = @pos_loc + __pcc_in.capt0.end_loc
    ____ = node

    __pcc_vars[__pcc_index].value = ____ if __pcc_vars
  end

  def action_quantity_0(__pcc_in, __pcc_vars, __pcc_index)
    ____ = (__pcc_vars[__pcc_index] ||= Value.new).value if __pcc_vars
    node = (__pcc_in.value_refs[0]  ||= Value.new).value
    __0 = __pcc_in.capt0.capture_string(@buffer)
    __0s = @pos + __pcc_in.capt0.range_start
    __0e = @pos + __pcc_in.capt0.range_end
    __0sl = @pos_loc + __pcc_in.capt0.start_loc
    __0el = @pos_loc + __pcc_in.capt0.end_loc
    ____ = Packcr::Node::QuantityNode.new(node, 0, -1)

    __pcc_vars[__pcc_index].value = ____ if __pcc_vars
  end

  def action_quantity_1(__pcc_in, __pcc_vars, __pcc_index)
    ____ = (__pcc_vars[__pcc_index] ||= Value.new).value if __pcc_vars
    node = (__pcc_in.value_refs[0]  ||= Value.new).value
    __0 = __pcc_in.capt0.capture_string(@buffer)
    __0s = @pos + __pcc_in.capt0.range_start
    __0e = @pos + __pcc_in.capt0.range_end
    __0sl = @pos_loc + __pcc_in.capt0.start_loc
    __0el = @pos_loc + __pcc_in.capt0.end_loc
    ____ = Packcr::Node::QuantityNode.new(node, 1, -1)

    __pcc_vars[__pcc_index].value = ____ if __pcc_vars
  end

  def action_quantity_2(__pcc_in, __pcc_vars, __pcc_index)
    ____ = (__pcc_vars[__pcc_index] ||= Value.new).value if __pcc_vars
    node = (__pcc_in.value_refs[0]  ||= Value.new).value
    __0 = __pcc_in.capt0.capture_string(@buffer)
    __0s = @pos + __pcc_in.capt0.range_start
    __0e = @pos + __pcc_in.capt0.range_end
    __0sl = @pos_loc + __pcc_in.capt0.start_loc
    __0el = @pos_loc + __pcc_in.capt0.end_loc
    ____ = Packcr::Node::QuantityNode.new(node, 0, 1)

    __pcc_vars[__pcc_index].value = ____ if __pcc_vars
  end

  def action_quantity_3(__pcc_in, __pcc_vars, __pcc_index)
    ____ = (__pcc_vars[__pcc_index] ||= Value.new).value if __pcc_vars
    node = (__pcc_in.value_refs[0]  ||= Value.new).value
    __0 = __pcc_in.capt0.capture_string(@buffer)
    __0s = @pos + __pcc_in.capt0.range_start
    __0e = @pos + __pcc_in.capt0.range_end
    __0sl = @pos_loc + __pcc_in.capt0.start_loc
    __0el = @pos_loc + __pcc_in.capt0.end_loc
    ____ = node

    __pcc_vars[__pcc_index].value = ____ if __pcc_vars
  end

  def action_primary_0(__pcc_in, __pcc_vars, __pcc_index)
    ____ = (__pcc_vars[__pcc_index] ||= Value.new).value if __pcc_vars
    code = (__pcc_in.value_refs[0]  ||= Value.new).value
    __0 = __pcc_in.capt0.capture_string(@buffer)
    __0s = @pos + __pcc_in.capt0.range_start
    __0e = @pos + __pcc_in.capt0.range_end
    __0sl = @pos_loc + __pcc_in.capt0.start_loc
    __0el = @pos_loc + __pcc_in.capt0.end_loc
    ____ = code && Packcr::Node::ActionNode.new(Packcr::CodeBlock.new(code, __0sl.linenum, __0sl.charnum))

    __pcc_vars[__pcc_index].value = ____ if __pcc_vars
  end

  def action_primary_1(__pcc_in, __pcc_vars, __pcc_index)
    ____ = (__pcc_vars[__pcc_index] ||= Value.new).value if __pcc_vars
    var_name = (__pcc_in.value_refs[1]  ||= Value.new).value
    name = (__pcc_in.value_refs[2]  ||= Value.new).value
    __0 = __pcc_in.capt0.capture_string(@buffer)
    __0s = @pos + __pcc_in.capt0.range_start
    __0e = @pos + __pcc_in.capt0.range_end
    __0sl = @pos_loc + __pcc_in.capt0.start_loc
    __0el = @pos_loc + __pcc_in.capt0.end_loc
    ____ = Packcr::Node::ReferenceNode.new(name, var_name, __0sl.linenum, __0sl.charnum)

    __pcc_vars[__pcc_index].value = ____ if __pcc_vars
  end

  def action_primary_2(__pcc_in, __pcc_vars, __pcc_index)
    ____ = (__pcc_vars[__pcc_index] ||= Value.new).value if __pcc_vars
    name = (__pcc_in.value_refs[2]  ||= Value.new).value
    __0 = __pcc_in.capt0.capture_string(@buffer)
    __0s = @pos + __pcc_in.capt0.range_start
    __0e = @pos + __pcc_in.capt0.range_end
    __0sl = @pos_loc + __pcc_in.capt0.start_loc
    __0el = @pos_loc + __pcc_in.capt0.end_loc
    ref = Packcr::Node::ReferenceNode.new(name, "_out", __0sl.linenum, __0sl.charnum)
    code = @ctx.pass_value_code("_out")
    act = Packcr::Node::ActionNode.new(Packcr::CodeBlock.new(code, __0sl.linenum, __0sl.charnum))
    ____ = ref.seq(act)

    __pcc_vars[__pcc_index].value = ____ if __pcc_vars
  end

  def action_primary_3(__pcc_in, __pcc_vars, __pcc_index)
    ____ = (__pcc_vars[__pcc_index] ||= Value.new).value if __pcc_vars
    name = (__pcc_in.value_refs[2]  ||= Value.new).value
    __0 = __pcc_in.capt0.capture_string(@buffer)
    __0s = @pos + __pcc_in.capt0.range_start
    __0e = @pos + __pcc_in.capt0.range_end
    __0sl = @pos_loc + __pcc_in.capt0.start_loc
    __0el = @pos_loc + __pcc_in.capt0.end_loc
    ____ = Packcr::Node::ReferenceNode.new(name, nil, __0sl.linenum, __0sl.charnum)

    __pcc_vars[__pcc_index].value = ____ if __pcc_vars
  end

  def action_primary_4(__pcc_in, __pcc_vars, __pcc_index)
    ____ = (__pcc_vars[__pcc_index] ||= Value.new).value if __pcc_vars
    expr = (__pcc_in.value_refs[3]  ||= Value.new).value
    __0 = __pcc_in.capt0.capture_string(@buffer)
    __0s = @pos + __pcc_in.capt0.range_start
    __0e = @pos + __pcc_in.capt0.range_end
    __0sl = @pos_loc + __pcc_in.capt0.start_loc
    __0el = @pos_loc + __pcc_in.capt0.end_loc
    ____ = expr

    __pcc_vars[__pcc_index].value = ____ if __pcc_vars
  end

  def action_primary_5(__pcc_in, __pcc_vars, __pcc_index)
    ____ = (__pcc_vars[__pcc_index] ||= Value.new).value if __pcc_vars
    expr = (__pcc_in.value_refs[3]  ||= Value.new).value
    __0 = __pcc_in.capt0.capture_string(@buffer)
    __0s = @pos + __pcc_in.capt0.range_start
    __0e = @pos + __pcc_in.capt0.range_end
    __0sl = @pos_loc + __pcc_in.capt0.start_loc
    __0el = @pos_loc + __pcc_in.capt0.end_loc
    ____ = Packcr::Node::CaptureNode.new(expr)

    __pcc_vars[__pcc_index].value = ____ if __pcc_vars
  end

  def action_primary_6(__pcc_in, __pcc_vars, __pcc_index)
    ____ = (__pcc_vars[__pcc_index] ||= Value.new).value if __pcc_vars
    __0 = __pcc_in.capt0.capture_string(@buffer)
    __0s = @pos + __pcc_in.capt0.range_start
    __0e = @pos + __pcc_in.capt0.range_end
    __0sl = @pos_loc + __pcc_in.capt0.start_loc
    __0el = @pos_loc + __pcc_in.capt0.end_loc
    __1 = __pcc_in.capts[0].capture_string(@buffer)
    __1s = @pos + __pcc_in.capts[0].range_start
    __1e = @pos + __pcc_in.capts[0].range_end
    __1sl = @pos_loc + __pcc_in.capts[0].start_loc
    __1el = @pos_loc + __pcc_in.capts[0].end_loc
    ____ = Packcr::Node::ExpandNode.new(__1.to_i - 1, __0sl.linenum, __0sl.charnum)

    __pcc_vars[__pcc_index].value = ____ if __pcc_vars
  end

  def action_primary_7(__pcc_in, __pcc_vars, __pcc_index)
    ____ = (__pcc_vars[__pcc_index] ||= Value.new).value if __pcc_vars
    __0 = __pcc_in.capt0.capture_string(@buffer)
    __0s = @pos + __pcc_in.capt0.range_start
    __0e = @pos + __pcc_in.capt0.range_end
    __0sl = @pos_loc + __pcc_in.capt0.start_loc
    __0el = @pos_loc + __pcc_in.capt0.end_loc
    ____ = Packcr::Node::CharclassNode.new

    __pcc_vars[__pcc_index].value = ____ if __pcc_vars
  end

  def action_primary_8(__pcc_in, __pcc_vars, __pcc_index)
    ____ = (__pcc_vars[__pcc_index] ||= Value.new).value if __pcc_vars
    str = (__pcc_in.value_refs[4]  ||= Value.new).value
    __0 = __pcc_in.capt0.capture_string(@buffer)
    __0s = @pos + __pcc_in.capt0.range_start
    __0e = @pos + __pcc_in.capt0.range_end
    __0sl = @pos_loc + __pcc_in.capt0.start_loc
    __0el = @pos_loc + __pcc_in.capt0.end_loc
    ____ = Packcr::Node::CharclassNode.new(Packcr.unescape_string(str, true))

    __pcc_vars[__pcc_index].value = ____ if __pcc_vars
  end

  def action_primary_9(__pcc_in, __pcc_vars, __pcc_index)
    ____ = (__pcc_vars[__pcc_index] ||= Value.new).value if __pcc_vars
    str = (__pcc_in.value_refs[4]  ||= Value.new).value
    __0 = __pcc_in.capt0.capture_string(@buffer)
    __0s = @pos + __pcc_in.capt0.range_start
    __0e = @pos + __pcc_in.capt0.range_end
    __0sl = @pos_loc + __pcc_in.capt0.start_loc
    __0el = @pos_loc + __pcc_in.capt0.end_loc
    ____ = Packcr::Node::StringNode.new(Packcr.unescape_string(str, false))

    __pcc_vars[__pcc_index].value = ____ if __pcc_vars
  end

  def action_primary_10(__pcc_in, __pcc_vars, __pcc_index)
    ____ = (__pcc_vars[__pcc_index] ||= Value.new).value if __pcc_vars
    str = (__pcc_in.value_refs[4]  ||= Value.new).value
    __0 = __pcc_in.capt0.capture_string(@buffer)
    __0s = @pos + __pcc_in.capt0.range_start
    __0e = @pos + __pcc_in.capt0.range_end
    __0sl = @pos_loc + __pcc_in.capt0.start_loc
    __0el = @pos_loc + __pcc_in.capt0.end_loc
    ____ = Packcr::Node::StringNode.new(Packcr.unescape_string(str, false))

    __pcc_vars[__pcc_index].value = ____ if __pcc_vars
  end

  def action_character_class_0(__pcc_in, __pcc_vars, __pcc_index)
    ____ = (__pcc_vars[__pcc_index] ||= Value.new).value if __pcc_vars
    __0 = __pcc_in.capt0.capture_string(@buffer)
    __0s = @pos + __pcc_in.capt0.range_start
    __0e = @pos + __pcc_in.capt0.range_end
    __0sl = @pos_loc + __pcc_in.capt0.start_loc
    __0el = @pos_loc + __pcc_in.capt0.end_loc
    __1 = __pcc_in.capts[0].capture_string(@buffer)
    __1s = @pos + __pcc_in.capts[0].range_start
    __1e = @pos + __pcc_in.capts[0].range_end
    __1sl = @pos_loc + __pcc_in.capts[0].start_loc
    __1el = @pos_loc + __pcc_in.capts[0].end_loc
    ____ = __1

    __pcc_vars[__pcc_index].value = ____ if __pcc_vars
  end

  def action_lang_code_block_0(__pcc_in, __pcc_vars, __pcc_index)
    ____ = (__pcc_vars[__pcc_index] ||= Value.new).value if __pcc_vars
    code = (__pcc_in.value_refs[0]  ||= Value.new).value
    __0 = __pcc_in.capt0.capture_string(@buffer)
    __0s = @pos + __pcc_in.capt0.range_start
    __0e = @pos + __pcc_in.capt0.range_end
    __0sl = @pos_loc + __pcc_in.capt0.start_loc
    __0el = @pos_loc + __pcc_in.capt0.end_loc
    ____ = code

    __pcc_vars[__pcc_index].value = ____ if __pcc_vars
  end

  def action_lang_code_block_1(__pcc_in, __pcc_vars, __pcc_index)
    ____ = (__pcc_vars[__pcc_index] ||= Value.new).value if __pcc_vars
    code = (__pcc_in.value_refs[0]  ||= Value.new).value
    __0 = __pcc_in.capt0.capture_string(@buffer)
    __0s = @pos + __pcc_in.capt0.range_start
    __0e = @pos + __pcc_in.capt0.range_end
    __0sl = @pos_loc + __pcc_in.capt0.start_loc
    __0el = @pos_loc + __pcc_in.capt0.end_loc
    __1 = __pcc_in.capts[0].capture_string(@buffer)
    __1s = @pos + __pcc_in.capts[0].range_start
    __1e = @pos + __pcc_in.capts[0].range_end
    __1sl = @pos_loc + __pcc_in.capts[0].start_loc
    __1el = @pos_loc + __pcc_in.capts[0].end_loc
    ____ = @ctx.lang == __1.to_sym ? code : nil

    __pcc_vars[__pcc_index].value = ____ if __pcc_vars
  end

  def action_code_block_0(__pcc_in, __pcc_vars, __pcc_index)
    ____ = (__pcc_vars[__pcc_index] ||= Value.new).value if __pcc_vars
    code = (__pcc_in.value_refs[0]  ||= Value.new).value
    __0 = __pcc_in.capt0.capture_string(@buffer)
    __0s = @pos + __pcc_in.capt0.range_start
    __0e = @pos + __pcc_in.capt0.range_end
    __0sl = @pos_loc + __pcc_in.capt0.start_loc
    __0el = @pos_loc + __pcc_in.capt0.end_loc
    ____ = code

    __pcc_vars[__pcc_index].value = ____ if __pcc_vars
  end

  def action_code_block_1(__pcc_in, __pcc_vars, __pcc_index)
    ____ = (__pcc_vars[__pcc_index] ||= Value.new).value if __pcc_vars
    code = (__pcc_in.value_refs[0]  ||= Value.new).value
    __0 = __pcc_in.capt0.capture_string(@buffer)
    __0s = @pos + __pcc_in.capt0.range_start
    __0e = @pos + __pcc_in.capt0.range_end
    __0sl = @pos_loc + __pcc_in.capt0.start_loc
    __0el = @pos_loc + __pcc_in.capt0.end_loc
    ____ = code.gsub("$", @ctx.lang == :rb ? "__" : "_")

    __pcc_vars[__pcc_index].value = ____ if __pcc_vars
  end

  def action_plain_code_block_0(__pcc_in, __pcc_vars, __pcc_index)
    ____ = (__pcc_vars[__pcc_index] ||= Value.new).value if __pcc_vars
    __0 = __pcc_in.capt0.capture_string(@buffer)
    __0s = @pos + __pcc_in.capt0.range_start
    __0e = @pos + __pcc_in.capt0.range_end
    __0sl = @pos_loc + __pcc_in.capt0.start_loc
    __0el = @pos_loc + __pcc_in.capt0.end_loc
    __1 = __pcc_in.capts[0].capture_string(@buffer)
    __1s = @pos + __pcc_in.capts[0].range_start
    __1e = @pos + __pcc_in.capts[0].range_end
    __1sl = @pos_loc + __pcc_in.capts[0].start_loc
    __1el = @pos_loc + __pcc_in.capts[0].end_loc
    ____ = __1

    __pcc_vars[__pcc_index].value = ____ if __pcc_vars
  end

  def action_quotation_single_0(__pcc_in, __pcc_vars, __pcc_index)
    ____ = (__pcc_vars[__pcc_index] ||= Value.new).value if __pcc_vars
    __0 = __pcc_in.capt0.capture_string(@buffer)
    __0s = @pos + __pcc_in.capt0.range_start
    __0e = @pos + __pcc_in.capt0.range_end
    __0sl = @pos_loc + __pcc_in.capt0.start_loc
    __0el = @pos_loc + __pcc_in.capt0.end_loc
    __1 = __pcc_in.capts[0].capture_string(@buffer)
    __1s = @pos + __pcc_in.capts[0].range_start
    __1e = @pos + __pcc_in.capts[0].range_end
    __1sl = @pos_loc + __pcc_in.capts[0].start_loc
    __1el = @pos_loc + __pcc_in.capts[0].end_loc
    ____ = __1

    __pcc_vars[__pcc_index].value = ____ if __pcc_vars
  end

  def action_quotation_double_0(__pcc_in, __pcc_vars, __pcc_index)
    ____ = (__pcc_vars[__pcc_index] ||= Value.new).value if __pcc_vars
    __0 = __pcc_in.capt0.capture_string(@buffer)
    __0s = @pos + __pcc_in.capt0.range_start
    __0e = @pos + __pcc_in.capt0.range_end
    __0sl = @pos_loc + __pcc_in.capt0.start_loc
    __0el = @pos_loc + __pcc_in.capt0.end_loc
    __1 = __pcc_in.capts[0].capture_string(@buffer)
    __1s = @pos + __pcc_in.capts[0].range_start
    __1e = @pos + __pcc_in.capts[0].range_end
    __1sl = @pos_loc + __pcc_in.capts[0].start_loc
    __1el = @pos_loc + __pcc_in.capts[0].end_loc
    ____ = __1

    __pcc_vars[__pcc_index].value = ____ if __pcc_vars
  end

  def action_identifier_0(__pcc_in, __pcc_vars, __pcc_index)
    ____ = (__pcc_vars[__pcc_index] ||= Value.new).value if __pcc_vars
    __0 = __pcc_in.capt0.capture_string(@buffer)
    __0s = @pos + __pcc_in.capt0.range_start
    __0e = @pos + __pcc_in.capt0.range_end
    __0sl = @pos_loc + __pcc_in.capt0.start_loc
    __0el = @pos_loc + __pcc_in.capt0.end_loc
    ____ = __0

    __pcc_vars[__pcc_index].value = ____ if __pcc_vars
  end

  def action_footer_0(__pcc_in, __pcc_vars, __pcc_index)
    ____ = (__pcc_vars[__pcc_index] ||= Value.new).value if __pcc_vars
    __0 = __pcc_in.capt0.capture_string(@buffer)
    __0s = @pos + __pcc_in.capt0.range_start
    __0e = @pos + __pcc_in.capt0.range_end
    __0sl = @pos_loc + __pcc_in.capt0.start_loc
    __0el = @pos_loc + __pcc_in.capt0.end_loc
    __1 = __pcc_in.capts[0].capture_string(@buffer)
    __1s = @pos + __pcc_in.capts[0].range_start
    __1e = @pos + __pcc_in.capts[0].range_end
    __1sl = @pos_loc + __pcc_in.capts[0].start_loc
    __1el = @pos_loc + __pcc_in.capts[0].end_loc
    @ctx.code(:lsource) << Packcr::CodeBlock.new(__1, __1sl.linenum, __1sl.charnum)

    __pcc_vars[__pcc_index].value = ____ if __pcc_vars
  end

  def evaluate_rule_statement
    answer = ThunkChunk.new
    answer.pos = @cur
    answer.pos_loc = @cur_loc
    debug { warn "#{ "  " * @level}EVAL    statement #{answer.pos} #{@buffer[answer.pos..-1].inspect}" }
    @level += 1
    answer.resize_captures(0)
    catch(0) do
      catch(1) do |; pos, p_loc, n|
        pos = @cur
        p_loc = @cur_loc
        n = answer.thunks.length
        if apply_rule(:evaluate_rule_comment, answer.thunks, nil, 0)
          throw(1)
        end
        @cur = pos
        @cur_loc = p_loc
        answer.thunks[n..-1] = []
        if apply_rule(:evaluate_rule_spaces, answer.thunks, nil, 0)
          throw(1)
        end
        @cur = pos
        @cur_loc = p_loc
        answer.thunks[n..-1] = []
        if apply_rule(:evaluate_rule_directive_include, answer.thunks, nil, 0)
          throw(1)
        end
        @cur = pos
        @cur_loc = p_loc
        answer.thunks[n..-1] = []
        if apply_rule(:evaluate_rule_directive_string, answer.thunks, nil, 0)
          throw(1)
        end
        @cur = pos
        @cur_loc = p_loc
        answer.thunks[n..-1] = []
        if apply_rule(:evaluate_rule_directive_value, answer.thunks, nil, 0)
          throw(1)
        end
        @cur = pos
        @cur_loc = p_loc
        answer.thunks[n..-1] = []
        if apply_rule(:evaluate_rule_rule, answer.thunks, nil, 0)
          throw(1)
        end
        @cur = pos
        @cur_loc = p_loc
        answer.thunks[n..-1] = []
        if apply_rule(:evaluate_rule_footer, answer.thunks, nil, 0)
          throw(1)
        end
        @cur = pos
        @cur_loc = p_loc
        answer.thunks[n..-1] = []
        catch(2) do
          catch(4) do
            catch(3) do
              if !apply_rule(:evaluate_rule_EOF, answer.thunks, nil, 0)
                throw(3)
              end
              throw(4)
            end

            action_statement_0(
              ThunkLeaf.new(
                :action_statement_0,
                Capture.new(
                  answer.pos, @cur,
                  answer.pos_loc,@cur_loc,
                ),
                {},
                {},
              ),
              nil,
              0
            )

            throw(2)
          end
          throw(1)
        end
        @cur = pos
        @cur_loc = p_loc
        answer.thunks[n..-1] = []
        throw(0)
      end
      @level -= 1
      debug { warn "#{ "  " * @level}MATCH   statement #{answer.pos} #{@buffer[answer.pos...@cur].inspect}" }
      return answer
    end
    @level -= 1
    debug { warn "#{ "  " * @level}NOMATCH statement #{answer.pos} #{@buffer[answer.pos...@cur].inspect}" }
    return nil
  end

  def evaluate_rule_supported_language
    answer = ThunkChunk.new
    answer.pos = @cur
    answer.pos_loc = @cur_loc
    debug { warn "#{ "  " * @level}EVAL    supported_language #{answer.pos} #{@buffer[answer.pos..-1].inspect}" }
    @level += 1
    answer.resize_captures(0)
    catch(0) do
      catch(1) do |; pos, p_loc, n|
        pos = @cur
        p_loc = @cur_loc
        n = answer.thunks.length
        catch(2) do
          if (
            refill_buffer(1) < 1 ||
            @buffer[@cur] != "c"
          )
            throw(2)
          end
          @cur_loc = @cur_loc.forward(@buffer, @cur, 1)
          @cur += 1
          throw(1)
        end
        @cur = pos
        @cur_loc = p_loc
        answer.thunks[n..-1] = []
        catch(3) do
          if (
            refill_buffer(2) < 2 ||
            @buffer[@cur, 2] != "rb"
          )
            throw(3)
          end
          @cur_loc = @cur_loc.forward(@buffer, @cur, 2)
          @cur += 2
          throw(1)
        end
        @cur = pos
        @cur_loc = p_loc
        answer.thunks[n..-1] = []
        catch(4) do
          if !apply_rule(:evaluate_rule_identifier, answer.thunks, nil, 0)
            throw(4)
          end
          answer.thunks.push(
            ThunkLeaf.new(
              :action_supported_language_0,
              Capture.new(
                answer.pos, @cur,
                answer.pos_loc, @cur_loc,
              ),
              {},
              {},
            )
          )
          throw(1)
        end
        @cur = pos
        @cur_loc = p_loc
        answer.thunks[n..-1] = []
        throw(0)
      end
      @level -= 1
      debug { warn "#{ "  " * @level}MATCH   supported_language #{answer.pos} #{@buffer[answer.pos...@cur].inspect}" }
      return answer
    end
    @level -= 1
    debug { warn "#{ "  " * @level}NOMATCH supported_language #{answer.pos} #{@buffer[answer.pos...@cur].inspect}" }
    return nil
  end

  def evaluate_rule_comment
    answer = ThunkChunk.new
    answer.pos = @cur
    answer.pos_loc = @cur_loc
    debug { warn "#{ "  " * @level}EVAL    comment #{answer.pos} #{@buffer[answer.pos..-1].inspect}" }
    @level += 1
    answer.resize_captures(0)
    catch(0) do
      if (
        refill_buffer(1) < 1 ||
        @buffer[@cur] != "#"
      )
        throw(0)
      end
      @cur_loc = @cur_loc.forward(@buffer, @cur, 1)
      @cur += 1
      1.times do |;p0, p0_loc, n0, i, pos, p_loc, n, stat|
        i = 0
        catch(1) do
          pos = @cur
          p_loc = @cur_loc
          n = answer.thunks.length
          1.times do |;u, n|
            if refill_buffer(1) < 1
              throw(1)
            end
            u = @buffer[@cur]
            if (
              u == "\n"
            )
              throw(1)
            end
            @cur_loc = @cur_loc.forward(@buffer, @cur, 1)
            @cur += 1
          end
          i += 1
          if @cur != pos
            redo
          end
          pos = nil
        end
        if pos
          @cur = pos
          @cur_loc = p_loc
          answer.thunks[n..-1] = []
        end
      end
      catch(2) do |; pos, p_loc, n|
        pos = @cur
        p_loc = @cur_loc
        n = answer.thunks.length
        if apply_rule(:evaluate_rule_lf, answer.thunks, nil, 0)
          throw(2)
        end
        @cur = pos
        @cur_loc = p_loc
        answer.thunks[n..-1] = []
        if apply_rule(:evaluate_rule_EOF, answer.thunks, nil, 0)
          throw(2)
        end
        @cur = pos
        @cur_loc = p_loc
        answer.thunks[n..-1] = []
        throw(0)
      end
      @level -= 1
      debug { warn "#{ "  " * @level}MATCH   comment #{answer.pos} #{@buffer[answer.pos...@cur].inspect}" }
      return answer
    end
    @level -= 1
    debug { warn "#{ "  " * @level}NOMATCH comment #{answer.pos} #{@buffer[answer.pos...@cur].inspect}" }
    return nil
  end

  def evaluate_rule_directive_include
    answer = ThunkChunk.new
    answer.pos = @cur
    answer.pos_loc = @cur_loc
    debug { warn "#{ "  " * @level}EVAL    directive_include #{answer.pos} #{@buffer[answer.pos..-1].inspect}" }
    @level += 1
    answer.resize_captures(1)
    answer.values = {}
    catch(0) do
      catch(1) do |; pos, p_loc, n|
        pos = @cur
        p_loc = @cur_loc
        n = answer.thunks.length
        catch(2) do
          if (
            refill_buffer(12) < 12 ||
            @buffer[@cur, 12] != "%earlysource"
          )
            throw(2)
          end
          @cur_loc = @cur_loc.forward(@buffer, @cur, 12)
          @cur += 12
          if !apply_rule(:evaluate_rule_opt_spaces_or_comments, answer.thunks, nil, 0)
            throw(2)
          end
          if !apply_rule(:evaluate_rule_code_blocks, answer.thunks, answer.values, 0)
            throw(2)
          end
          answer.thunks.push(
            ThunkLeaf.new(
              :action_directive_include_0,
              Capture.new(
                answer.pos, @cur,
                answer.pos_loc, @cur_loc,
              ),
              answer.values.slice(0),
              {},
            )
          )
          throw(1)
        end
        @cur = pos
        @cur_loc = p_loc
        answer.thunks[n..-1] = []
        catch(3) do
          if (
            refill_buffer(7) < 7 ||
            @buffer[@cur, 7] != "%source"
          )
            throw(3)
          end
          @cur_loc = @cur_loc.forward(@buffer, @cur, 7)
          @cur += 7
          if !apply_rule(:evaluate_rule_opt_spaces_or_comments, answer.thunks, nil, 0)
            throw(3)
          end
          if !apply_rule(:evaluate_rule_code_blocks, answer.thunks, answer.values, 0)
            throw(3)
          end
          answer.thunks.push(
            ThunkLeaf.new(
              :action_directive_include_1,
              Capture.new(
                answer.pos, @cur,
                answer.pos_loc, @cur_loc,
              ),
              answer.values.slice(0),
              {},
            )
          )
          throw(1)
        end
        @cur = pos
        @cur_loc = p_loc
        answer.thunks[n..-1] = []
        catch(4) do
          if (
            refill_buffer(11) < 11 ||
            @buffer[@cur, 11] != "%lateheader"
          )
            throw(4)
          end
          @cur_loc = @cur_loc.forward(@buffer, @cur, 11)
          @cur += 11
          if !apply_rule(:evaluate_rule_opt_spaces_or_comments, answer.thunks, nil, 0)
            throw(4)
          end
          if !apply_rule(:evaluate_rule_code_blocks, answer.thunks, answer.values, 0)
            throw(4)
          end
          answer.thunks.push(
            ThunkLeaf.new(
              :action_directive_include_2,
              Capture.new(
                answer.pos, @cur,
                answer.pos_loc, @cur_loc,
              ),
              answer.values.slice(0),
              {},
            )
          )
          throw(1)
        end
        @cur = pos
        @cur_loc = p_loc
        answer.thunks[n..-1] = []
        catch(5) do
          if (
            refill_buffer(11) < 11 ||
            @buffer[@cur, 11] != "%latesource"
          )
            throw(5)
          end
          @cur_loc = @cur_loc.forward(@buffer, @cur, 11)
          @cur += 11
          if !apply_rule(:evaluate_rule_opt_spaces_or_comments, answer.thunks, nil, 0)
            throw(5)
          end
          if !apply_rule(:evaluate_rule_code_blocks, answer.thunks, answer.values, 0)
            throw(5)
          end
          answer.thunks.push(
            ThunkLeaf.new(
              :action_directive_include_3,
              Capture.new(
                answer.pos, @cur,
                answer.pos_loc, @cur_loc,
              ),
              answer.values.slice(0),
              {},
            )
          )
          throw(1)
        end
        @cur = pos
        @cur_loc = p_loc
        answer.thunks[n..-1] = []
        catch(6) do
          if (
            refill_buffer(7) < 7 ||
            @buffer[@cur, 7] != "%header"
          )
            throw(6)
          end
          @cur_loc = @cur_loc.forward(@buffer, @cur, 7)
          @cur += 7
          if !apply_rule(:evaluate_rule_opt_spaces_or_comments, answer.thunks, nil, 0)
            throw(6)
          end
          if !apply_rule(:evaluate_rule_code_blocks, answer.thunks, answer.values, 0)
            throw(6)
          end
          answer.thunks.push(
            ThunkLeaf.new(
              :action_directive_include_4,
              Capture.new(
                answer.pos, @cur,
                answer.pos_loc, @cur_loc,
              ),
              answer.values.slice(0),
              {},
            )
          )
          throw(1)
        end
        @cur = pos
        @cur_loc = p_loc
        answer.thunks[n..-1] = []
        catch(7) do
          if (
            refill_buffer(9) < 9 ||
            @buffer[@cur, 9] != "%location"
          )
            throw(7)
          end
          @cur_loc = @cur_loc.forward(@buffer, @cur, 9)
          @cur += 9
          if !apply_rule(:evaluate_rule_opt_spaces_or_comments, answer.thunks, nil, 0)
            throw(7)
          end
          if !apply_rule(:evaluate_rule_code_blocks, answer.thunks, answer.values, 0)
            throw(7)
          end
          answer.thunks.push(
            ThunkLeaf.new(
              :action_directive_include_5,
              Capture.new(
                answer.pos, @cur,
                answer.pos_loc, @cur_loc,
              ),
              answer.values.slice(0),
              {},
            )
          )
          throw(1)
        end
        @cur = pos
        @cur_loc = p_loc
        answer.thunks[n..-1] = []
        catch(8) do
          if (
            refill_buffer(11) < 11 ||
            @buffer[@cur, 11] != "%initialize"
          )
            throw(8)
          end
          @cur_loc = @cur_loc.forward(@buffer, @cur, 11)
          @cur += 11
          if !apply_rule(:evaluate_rule_opt_spaces_or_comments, answer.thunks, nil, 0)
            throw(8)
          end
          if !apply_rule(:evaluate_rule_code_blocks, answer.thunks, answer.values, 0)
            throw(8)
          end
          answer.thunks.push(
            ThunkLeaf.new(
              :action_directive_include_6,
              Capture.new(
                answer.pos, @cur,
                answer.pos_loc, @cur_loc,
              ),
              answer.values.slice(0),
              {},
            )
          )
          throw(1)
        end
        @cur = pos
        @cur_loc = p_loc
        answer.thunks[n..-1] = []
        catch(9) do
          if (
            refill_buffer(12) < 12 ||
            @buffer[@cur, 12] != "%earlycommon"
          )
            throw(9)
          end
          @cur_loc = @cur_loc.forward(@buffer, @cur, 12)
          @cur += 12
          if !apply_rule(:evaluate_rule_opt_spaces_or_comments, answer.thunks, nil, 0)
            throw(9)
          end
          if !apply_rule(:evaluate_rule_code_blocks, answer.thunks, answer.values, 0)
            throw(9)
          end
          answer.thunks.push(
            ThunkLeaf.new(
              :action_directive_include_7,
              Capture.new(
                answer.pos, @cur,
                answer.pos_loc, @cur_loc,
              ),
              answer.values.slice(0),
              {},
            )
          )
          throw(1)
        end
        @cur = pos
        @cur_loc = p_loc
        answer.thunks[n..-1] = []
        catch(10) do
          if (
            refill_buffer(7) < 7 ||
            @buffer[@cur, 7] != "%common"
          )
            throw(10)
          end
          @cur_loc = @cur_loc.forward(@buffer, @cur, 7)
          @cur += 7
          if !apply_rule(:evaluate_rule_opt_spaces_or_comments, answer.thunks, nil, 0)
            throw(10)
          end
          if !apply_rule(:evaluate_rule_code_blocks, answer.thunks, answer.values, 0)
            throw(10)
          end
          answer.thunks.push(
            ThunkLeaf.new(
              :action_directive_include_8,
              Capture.new(
                answer.pos, @cur,
                answer.pos_loc, @cur_loc,
              ),
              answer.values.slice(0),
              {},
            )
          )
          throw(1)
        end
        @cur = pos
        @cur_loc = p_loc
        answer.thunks[n..-1] = []
        catch(11) do
          if (
            refill_buffer(1) < 1 ||
            @buffer[@cur] != "%"
          )
            throw(11)
          end
          @cur_loc = @cur_loc.forward(@buffer, @cur, 1)
          @cur += 1
          1.times do |;pos, q, capt, p_loc, q_loc|
            pos = @cur
            p_loc = @cur_loc
            if !apply_rule(:evaluate_rule_identifier, answer.thunks, nil, 0)
              throw(11)
            end
            q = @cur
            capt = answer.capts[0]
            capt.range_start = pos
            capt.range_end = q
            q_loc = @cur_loc
            capt.start_loc = p_loc
            capt.end_loc = q_loc
          end
          if !apply_rule(:evaluate_rule_opt_spaces_or_comments, answer.thunks, nil, 0)
            throw(11)
          end
          if !apply_rule(:evaluate_rule_code_blocks, answer.thunks, answer.values, 0)
            throw(11)
          end
          answer.thunks.push(
            ThunkLeaf.new(
              :action_directive_include_9,
              Capture.new(
                answer.pos, @cur,
                answer.pos_loc, @cur_loc,
              ),
              answer.values.slice(0),
              answer.capts.slice(0),
            )
          )
          throw(1)
        end
        @cur = pos
        @cur_loc = p_loc
        answer.thunks[n..-1] = []
        throw(0)
      end
      @level -= 1
      debug { warn "#{ "  " * @level}MATCH   directive_include #{answer.pos} #{@buffer[answer.pos...@cur].inspect}" }
      return answer
    end
    @level -= 1
    debug { warn "#{ "  " * @level}NOMATCH directive_include #{answer.pos} #{@buffer[answer.pos...@cur].inspect}" }
    return nil
  end

  def evaluate_rule_code_blocks
    answer = ThunkChunk.new
    answer.pos = @cur
    answer.pos_loc = @cur_loc
    debug { warn "#{ "  " * @level}EVAL    code_blocks #{answer.pos} #{@buffer[answer.pos..-1].inspect}" }
    @level += 1
    answer.resize_captures(0)
    answer.values = {}
    catch(0) do
      catch(1) do |; pos, p_loc, n|
        pos = @cur
        p_loc = @cur_loc
        n = answer.thunks.length
        catch(2) do
          if !apply_rule(:evaluate_rule_code_blocks, answer.thunks, answer.values, 0)
            throw(2)
          end
          if !apply_rule(:evaluate_rule_opt_spaces_or_comments, answer.thunks, nil, 0)
            throw(2)
          end
          if !apply_rule(:evaluate_rule_lang_code_block, answer.thunks, answer.values, 1)
            throw(2)
          end
          answer.thunks.push(
            ThunkLeaf.new(
              :action_code_blocks_0,
              Capture.new(
                answer.pos, @cur,
                answer.pos_loc, @cur_loc,
              ),
              answer.values.slice(0, 1),
              {},
            )
          )
          throw(1)
        end
        @cur = pos
        @cur_loc = p_loc
        answer.thunks[n..-1] = []
        catch(3) do
          if !apply_rule(:evaluate_rule_lang_code_block, answer.thunks, answer.values, 1)
            throw(3)
          end
          answer.thunks.push(
            ThunkLeaf.new(
              :action_code_blocks_1,
              Capture.new(
                answer.pos, @cur,
                answer.pos_loc, @cur_loc,
              ),
              answer.values.slice(1),
              {},
            )
          )
          throw(1)
        end
        @cur = pos
        @cur_loc = p_loc
        answer.thunks[n..-1] = []
        throw(0)
      end
      @level -= 1
      debug { warn "#{ "  " * @level}MATCH   code_blocks #{answer.pos} #{@buffer[answer.pos...@cur].inspect}" }
      return answer
    end
    @level -= 1
    debug { warn "#{ "  " * @level}NOMATCH code_blocks #{answer.pos} #{@buffer[answer.pos...@cur].inspect}" }
    return nil
  end

  def evaluate_rule_directive_string
    answer = ThunkChunk.new
    answer.pos = @cur
    answer.pos_loc = @cur_loc
    debug { warn "#{ "  " * @level}EVAL    directive_string #{answer.pos} #{@buffer[answer.pos..-1].inspect}" }
    @level += 1
    answer.resize_captures(1)
    answer.values = {}
    catch(0) do
      catch(1) do |; pos, p_loc, n|
        pos = @cur
        p_loc = @cur_loc
        n = answer.thunks.length
        catch(2) do
          if (
            refill_buffer(6) < 6 ||
            @buffer[@cur, 6] != "%value"
          )
            throw(2)
          end
          @cur_loc = @cur_loc.forward(@buffer, @cur, 6)
          @cur += 6
          if !apply_rule(:evaluate_rule_opt_spaces_or_comments, answer.thunks, nil, 0)
            throw(2)
          end
          if !apply_rule(:evaluate_rule_lang_strings, answer.thunks, answer.values, 0)
            throw(2)
          end
          answer.thunks.push(
            ThunkLeaf.new(
              :action_directive_string_0,
              Capture.new(
                answer.pos, @cur,
                answer.pos_loc, @cur_loc,
              ),
              answer.values.slice(0),
              {},
            )
          )
          throw(1)
        end
        @cur = pos
        @cur_loc = p_loc
        answer.thunks[n..-1] = []
        catch(3) do
          if (
            refill_buffer(6) < 6 ||
            @buffer[@cur, 6] != "%auxil"
          )
            throw(3)
          end
          @cur_loc = @cur_loc.forward(@buffer, @cur, 6)
          @cur += 6
          if !apply_rule(:evaluate_rule_opt_spaces_or_comments, answer.thunks, nil, 0)
            throw(3)
          end
          if !apply_rule(:evaluate_rule_lang_strings, answer.thunks, answer.values, 0)
            throw(3)
          end
          answer.thunks.push(
            ThunkLeaf.new(
              :action_directive_string_1,
              Capture.new(
                answer.pos, @cur,
                answer.pos_loc, @cur_loc,
              ),
              answer.values.slice(0),
              {},
            )
          )
          throw(1)
        end
        @cur = pos
        @cur_loc = p_loc
        answer.thunks[n..-1] = []
        catch(4) do
          if (
            refill_buffer(7) < 7 ||
            @buffer[@cur, 7] != "%prefix"
          )
            throw(4)
          end
          @cur_loc = @cur_loc.forward(@buffer, @cur, 7)
          @cur += 7
          if !apply_rule(:evaluate_rule_opt_spaces_or_comments, answer.thunks, nil, 0)
            throw(4)
          end
          if !apply_rule(:evaluate_rule_lang_strings, answer.thunks, answer.values, 0)
            throw(4)
          end
          answer.thunks.push(
            ThunkLeaf.new(
              :action_directive_string_2,
              Capture.new(
                answer.pos, @cur,
                answer.pos_loc, @cur_loc,
              ),
              answer.values.slice(0),
              {},
            )
          )
          throw(1)
        end
        @cur = pos
        @cur_loc = p_loc
        answer.thunks[n..-1] = []
        catch(5) do
          if (
            refill_buffer(1) < 1 ||
            @buffer[@cur] != "%"
          )
            throw(5)
          end
          @cur_loc = @cur_loc.forward(@buffer, @cur, 1)
          @cur += 1
          1.times do |;pos, q, capt, p_loc, q_loc|
            pos = @cur
            p_loc = @cur_loc
            if !apply_rule(:evaluate_rule_identifier, answer.thunks, nil, 0)
              throw(5)
            end
            q = @cur
            capt = answer.capts[0]
            capt.range_start = pos
            capt.range_end = q
            q_loc = @cur_loc
            capt.start_loc = p_loc
            capt.end_loc = q_loc
          end
          if !apply_rule(:evaluate_rule_opt_spaces_or_comments, answer.thunks, nil, 0)
            throw(5)
          end
          if !apply_rule(:evaluate_rule_quotation_double, answer.thunks, answer.values, 1)
            throw(5)
          end
          answer.thunks.push(
            ThunkLeaf.new(
              :action_directive_string_3,
              Capture.new(
                answer.pos, @cur,
                answer.pos_loc, @cur_loc,
              ),
              answer.values.slice(1),
              answer.capts.slice(0),
            )
          )
          throw(1)
        end
        @cur = pos
        @cur_loc = p_loc
        answer.thunks[n..-1] = []
        throw(0)
      end
      @level -= 1
      debug { warn "#{ "  " * @level}MATCH   directive_string #{answer.pos} #{@buffer[answer.pos...@cur].inspect}" }
      return answer
    end
    @level -= 1
    debug { warn "#{ "  " * @level}NOMATCH directive_string #{answer.pos} #{@buffer[answer.pos...@cur].inspect}" }
    return nil
  end

  def evaluate_rule_directive_value
    answer = ThunkChunk.new
    answer.pos = @cur
    answer.pos_loc = @cur_loc
    debug { warn "#{ "  " * @level}EVAL    directive_value #{answer.pos} #{@buffer[answer.pos..-1].inspect}" }
    @level += 1
    answer.resize_captures(0)
    catch(0) do
      if (
        refill_buffer(8) < 8 ||
        @buffer[@cur, 8] != "%capture"
      )
        throw(0)
      end
      @cur_loc = @cur_loc.forward(@buffer, @cur, 8)
      @cur += 8
      if !apply_rule(:evaluate_rule_spaces, answer.thunks, nil, 0)
        throw(0)
      end
      catch(1) do |; pos, p_loc, n|
        pos = @cur
        p_loc = @cur_loc
        n = answer.thunks.length
        catch(2) do
          if (
            refill_buffer(2) < 2 ||
            @buffer[@cur, 2] != "on"
          )
            throw(2)
          end
          @cur_loc = @cur_loc.forward(@buffer, @cur, 2)
          @cur += 2
          throw(1)
        end
        @cur = pos
        @cur_loc = p_loc
        answer.thunks[n..-1] = []
        catch(3) do
          if (
            refill_buffer(4) < 4 ||
            @buffer[@cur, 4] != "true"
          )
            throw(3)
          end
          @cur_loc = @cur_loc.forward(@buffer, @cur, 4)
          @cur += 4
          throw(1)
        end
        @cur = pos
        @cur_loc = p_loc
        answer.thunks[n..-1] = []
        throw(0)
      end
      answer.thunks.push(
        ThunkLeaf.new(
          :action_directive_value_0,
          Capture.new(
            answer.pos, @cur,
            answer.pos_loc, @cur_loc,
          ),
          {},
          {},
        )
      )
      @level -= 1
      debug { warn "#{ "  " * @level}MATCH   directive_value #{answer.pos} #{@buffer[answer.pos...@cur].inspect}" }
      return answer
    end
    @level -= 1
    debug { warn "#{ "  " * @level}NOMATCH directive_value #{answer.pos} #{@buffer[answer.pos...@cur].inspect}" }
    return nil
  end

  def evaluate_rule_lang_strings
    answer = ThunkChunk.new
    answer.pos = @cur
    answer.pos_loc = @cur_loc
    debug { warn "#{ "  " * @level}EVAL    lang_strings #{answer.pos} #{@buffer[answer.pos..-1].inspect}" }
    @level += 1
    answer.resize_captures(0)
    answer.values = {}
    catch(0) do
      catch(1) do |; pos, p_loc, n|
        pos = @cur
        p_loc = @cur_loc
        n = answer.thunks.length
        catch(2) do
          if !apply_rule(:evaluate_rule_lang_strings, answer.thunks, answer.values, 0)
            throw(2)
          end
          if !apply_rule(:evaluate_rule_opt_spaces_or_comments, answer.thunks, nil, 0)
            throw(2)
          end
          if !apply_rule(:evaluate_rule_lang_string, answer.thunks, answer.values, 1)
            throw(2)
          end
          answer.thunks.push(
            ThunkLeaf.new(
              :action_lang_strings_0,
              Capture.new(
                answer.pos, @cur,
                answer.pos_loc, @cur_loc,
              ),
              answer.values.slice(0, 1),
              {},
            )
          )
          throw(1)
        end
        @cur = pos
        @cur_loc = p_loc
        answer.thunks[n..-1] = []
        catch(3) do
          if !apply_rule(:evaluate_rule_lang_string, answer.thunks, answer.values, 1)
            throw(3)
          end
          answer.thunks.push(
            ThunkLeaf.new(
              :action_lang_strings_1,
              Capture.new(
                answer.pos, @cur,
                answer.pos_loc, @cur_loc,
              ),
              answer.values.slice(1),
              {},
            )
          )
          throw(1)
        end
        @cur = pos
        @cur_loc = p_loc
        answer.thunks[n..-1] = []
        throw(0)
      end
      @level -= 1
      debug { warn "#{ "  " * @level}MATCH   lang_strings #{answer.pos} #{@buffer[answer.pos...@cur].inspect}" }
      return answer
    end
    @level -= 1
    debug { warn "#{ "  " * @level}NOMATCH lang_strings #{answer.pos} #{@buffer[answer.pos...@cur].inspect}" }
    return nil
  end

  def evaluate_rule_lang_string
    answer = ThunkChunk.new
    answer.pos = @cur
    answer.pos_loc = @cur_loc
    debug { warn "#{ "  " * @level}EVAL    lang_string #{answer.pos} #{@buffer[answer.pos..-1].inspect}" }
    @level += 1
    answer.resize_captures(1)
    answer.values = {}
    catch(0) do
      catch(1) do |; pos, p_loc, n|
        pos = @cur
        p_loc = @cur_loc
        n = answer.thunks.length
        catch(2) do
          if !apply_rule(:evaluate_rule_quotation_double, answer.thunks, answer.values, 0)
            throw(2)
          end
          answer.thunks.push(
            ThunkLeaf.new(
              :action_lang_string_0,
              Capture.new(
                answer.pos, @cur,
                answer.pos_loc, @cur_loc,
              ),
              answer.values.slice(0),
              {},
            )
          )
          throw(1)
        end
        @cur = pos
        @cur_loc = p_loc
        answer.thunks[n..-1] = []
        catch(3) do
          1.times do |;pos, q, capt, p_loc, q_loc|
            pos = @cur
            p_loc = @cur_loc
            if !apply_rule(:evaluate_rule_supported_language, answer.thunks, nil, 0)
              throw(3)
            end
            q = @cur
            capt = answer.capts[0]
            capt.range_start = pos
            capt.range_end = q
            q_loc = @cur_loc
            capt.start_loc = p_loc
            capt.end_loc = q_loc
          end
          if !apply_rule(:evaluate_rule_opt_spaces_or_comments, answer.thunks, nil, 0)
            throw(3)
          end
          if (
            refill_buffer(2) < 2 ||
            @buffer[@cur, 2] != "->"
          )
            throw(3)
          end
          @cur_loc = @cur_loc.forward(@buffer, @cur, 2)
          @cur += 2
          if !apply_rule(:evaluate_rule_opt_spaces_or_comments, answer.thunks, nil, 0)
            throw(3)
          end
          if !apply_rule(:evaluate_rule_quotation_double, answer.thunks, answer.values, 0)
            throw(3)
          end
          answer.thunks.push(
            ThunkLeaf.new(
              :action_lang_string_1,
              Capture.new(
                answer.pos, @cur,
                answer.pos_loc, @cur_loc,
              ),
              answer.values.slice(0),
              answer.capts.slice(0),
            )
          )
          throw(1)
        end
        @cur = pos
        @cur_loc = p_loc
        answer.thunks[n..-1] = []
        throw(0)
      end
      @level -= 1
      debug { warn "#{ "  " * @level}MATCH   lang_string #{answer.pos} #{@buffer[answer.pos...@cur].inspect}" }
      return answer
    end
    @level -= 1
    debug { warn "#{ "  " * @level}NOMATCH lang_string #{answer.pos} #{@buffer[answer.pos...@cur].inspect}" }
    return nil
  end

  def evaluate_rule_rule
    answer = ThunkChunk.new
    answer.pos = @cur
    answer.pos_loc = @cur_loc
    debug { warn "#{ "  " * @level}EVAL    rule #{answer.pos} #{@buffer[answer.pos..-1].inspect}" }
    @level += 1
    answer.resize_captures(0)
    answer.values = {}
    catch(0) do
      if !apply_rule(:evaluate_rule_identifier, answer.thunks, answer.values, 0)
        throw(0)
      end
      if !apply_rule(:evaluate_rule_opt_spaces_or_comments, answer.thunks, nil, 0)
        throw(0)
      end
      if (
        refill_buffer(2) < 2 ||
        @buffer[@cur, 2] != "<-"
      )
        throw(0)
      end
      @cur_loc = @cur_loc.forward(@buffer, @cur, 2)
      @cur += 2
      if !apply_rule(:evaluate_rule_opt_spaces_or_comments, answer.thunks, nil, 0)
        throw(0)
      end
      if !apply_rule(:evaluate_rule_expression, answer.thunks, answer.values, 1)
        throw(0)
      end
      answer.thunks.push(
        ThunkLeaf.new(
          :action_rule_0,
          Capture.new(
            answer.pos, @cur,
            answer.pos_loc, @cur_loc,
          ),
          answer.values.slice(0, 1),
          {},
        )
      )
      @level -= 1
      debug { warn "#{ "  " * @level}MATCH   rule #{answer.pos} #{@buffer[answer.pos...@cur].inspect}" }
      return answer
    end
    @level -= 1
    debug { warn "#{ "  " * @level}NOMATCH rule #{answer.pos} #{@buffer[answer.pos...@cur].inspect}" }
    return nil
  end

  def evaluate_rule_expression
    answer = ThunkChunk.new
    answer.pos = @cur
    answer.pos_loc = @cur_loc
    debug { warn "#{ "  " * @level}EVAL    expression #{answer.pos} #{@buffer[answer.pos..-1].inspect}" }
    @level += 1
    answer.resize_captures(0)
    answer.values = {}
    catch(0) do
      catch(1) do |; pos, p_loc, n|
        pos = @cur
        p_loc = @cur_loc
        n = answer.thunks.length
        catch(2) do
          if !apply_rule(:evaluate_rule_expression, answer.thunks, answer.values, 0)
            throw(2)
          end
          if !apply_rule(:evaluate_rule_opt_spaces_or_comments, answer.thunks, nil, 0)
            throw(2)
          end
          if (
            refill_buffer(1) < 1 ||
            @buffer[@cur] != "/"
          )
            throw(2)
          end
          @cur_loc = @cur_loc.forward(@buffer, @cur, 1)
          @cur += 1
          if !apply_rule(:evaluate_rule_opt_spaces_or_comments, answer.thunks, nil, 0)
            throw(0)
          end
          if !apply_rule(:evaluate_rule_sequence, answer.thunks, answer.values, 1)
            throw(0)
          end
          answer.thunks.push(
            ThunkLeaf.new(
              :action_expression_0,
              Capture.new(
                answer.pos, @cur,
                answer.pos_loc, @cur_loc,
              ),
              answer.values.slice(0, 1),
              {},
            )
          )
          throw(1)
        end
        @cur = pos
        @cur_loc = p_loc
        answer.thunks[n..-1] = []
        catch(3) do
          if !apply_rule(:evaluate_rule_sequence, answer.thunks, answer.values, 1)
            throw(3)
          end
          answer.thunks.push(
            ThunkLeaf.new(
              :action_expression_1,
              Capture.new(
                answer.pos, @cur,
                answer.pos_loc, @cur_loc,
              ),
              answer.values.slice(1),
              {},
            )
          )
          throw(1)
        end
        @cur = pos
        @cur_loc = p_loc
        answer.thunks[n..-1] = []
        throw(0)
      end
      @level -= 1
      debug { warn "#{ "  " * @level}MATCH   expression #{answer.pos} #{@buffer[answer.pos...@cur].inspect}" }
      return answer
    end
    @level -= 1
    debug { warn "#{ "  " * @level}NOMATCH expression #{answer.pos} #{@buffer[answer.pos...@cur].inspect}" }
    return nil
  end

  def evaluate_rule_sequence
    answer = ThunkChunk.new
    answer.pos = @cur
    answer.pos_loc = @cur_loc
    debug { warn "#{ "  " * @level}EVAL    sequence #{answer.pos} #{@buffer[answer.pos..-1].inspect}" }
    @level += 1
    answer.resize_captures(0)
    answer.values = {}
    catch(0) do
      catch(1) do |; pos, p_loc, n|
        pos = @cur
        p_loc = @cur_loc
        n = answer.thunks.length
        catch(2) do
          if !apply_rule(:evaluate_rule_sequence, answer.thunks, answer.values, 0)
            throw(2)
          end
          if !apply_rule(:evaluate_rule_opt_spaces_or_comments, answer.thunks, nil, 0)
            throw(2)
          end
          if (
            refill_buffer(2) < 2 ||
            @buffer[@cur, 2] != "8<"
          )
            throw(2)
          end
          @cur_loc = @cur_loc.forward(@buffer, @cur, 2)
          @cur += 2
          if !apply_rule(:evaluate_rule_opt_spaces_or_comments, answer.thunks, nil, 0)
            throw(0)
          end
          if !apply_rule(:evaluate_rule_term, answer.thunks, answer.values, 1)
            throw(0)
          end
          answer.thunks.push(
            ThunkLeaf.new(
              :action_sequence_0,
              Capture.new(
                answer.pos, @cur,
                answer.pos_loc, @cur_loc,
              ),
              answer.values.slice(0, 1),
              {},
            )
          )
          throw(1)
        end
        @cur = pos
        @cur_loc = p_loc
        answer.thunks[n..-1] = []
        catch(3) do
          if !apply_rule(:evaluate_rule_sequence, answer.thunks, answer.values, 0)
            throw(3)
          end
          if !apply_rule(:evaluate_rule_opt_spaces_or_comments, answer.thunks, nil, 0)
            throw(3)
          end
          if (
            refill_buffer(1) < 1 ||
            @buffer[@cur] != "~"
          )
            throw(3)
          end
          @cur_loc = @cur_loc.forward(@buffer, @cur, 1)
          @cur += 1
          if !apply_rule(:evaluate_rule_opt_spaces_or_comments, answer.thunks, nil, 0)
            throw(0)
          end
          if !apply_rule(:evaluate_rule_lang_code_block, answer.thunks, answer.values, 2)
            throw(0)
          end
          answer.thunks.push(
            ThunkLeaf.new(
              :action_sequence_1,
              Capture.new(
                answer.pos, @cur,
                answer.pos_loc, @cur_loc,
              ),
              answer.values.slice(0, 2),
              {},
            )
          )
          throw(1)
        end
        @cur = pos
        @cur_loc = p_loc
        answer.thunks[n..-1] = []
        catch(4) do
          if !apply_rule(:evaluate_rule_sequence, answer.thunks, answer.values, 0)
            throw(4)
          end
          if !apply_rule(:evaluate_rule_opt_spaces_or_comments, answer.thunks, nil, 0)
            throw(4)
          end
          if !apply_rule(:evaluate_rule_term, answer.thunks, answer.values, 1)
            throw(4)
          end
          answer.thunks.push(
            ThunkLeaf.new(
              :action_sequence_2,
              Capture.new(
                answer.pos, @cur,
                answer.pos_loc, @cur_loc,
              ),
              answer.values.slice(0, 1),
              {},
            )
          )
          throw(1)
        end
        @cur = pos
        @cur_loc = p_loc
        answer.thunks[n..-1] = []
        catch(5) do
          if !apply_rule(:evaluate_rule_term, answer.thunks, answer.values, 1)
            throw(5)
          end
          answer.thunks.push(
            ThunkLeaf.new(
              :action_sequence_3,
              Capture.new(
                answer.pos, @cur,
                answer.pos_loc, @cur_loc,
              ),
              answer.values.slice(1),
              {},
            )
          )
          throw(1)
        end
        @cur = pos
        @cur_loc = p_loc
        answer.thunks[n..-1] = []
        throw(0)
      end
      @level -= 1
      debug { warn "#{ "  " * @level}MATCH   sequence #{answer.pos} #{@buffer[answer.pos...@cur].inspect}" }
      return answer
    end
    @level -= 1
    debug { warn "#{ "  " * @level}NOMATCH sequence #{answer.pos} #{@buffer[answer.pos...@cur].inspect}" }
    return nil
  end

  def evaluate_rule_term
    answer = ThunkChunk.new
    answer.pos = @cur
    answer.pos_loc = @cur_loc
    debug { warn "#{ "  " * @level}EVAL    term #{answer.pos} #{@buffer[answer.pos..-1].inspect}" }
    @level += 1
    answer.resize_captures(0)
    answer.values = {}
    catch(0) do
      catch(1) do |; pos, p_loc, n|
        pos = @cur
        p_loc = @cur_loc
        n = answer.thunks.length
        catch(2) do
          if (
            refill_buffer(1) < 1 ||
            @buffer[@cur] != "&"
          )
            throw(2)
          end
          @cur_loc = @cur_loc.forward(@buffer, @cur, 1)
          @cur += 1
          if !apply_rule(:evaluate_rule_opt_spaces_or_comments, answer.thunks, nil, 0)
            throw(0)
          end
          if !apply_rule(:evaluate_rule_quantity, answer.thunks, answer.values, 0)
            throw(0)
          end
          answer.thunks.push(
            ThunkLeaf.new(
              :action_term_0,
              Capture.new(
                answer.pos, @cur,
                answer.pos_loc, @cur_loc,
              ),
              answer.values.slice(0),
              {},
            )
          )
          throw(1)
        end
        @cur = pos
        @cur_loc = p_loc
        answer.thunks[n..-1] = []
        catch(3) do
          if (
            refill_buffer(1) < 1 ||
            @buffer[@cur] != "!"
          )
            throw(3)
          end
          @cur_loc = @cur_loc.forward(@buffer, @cur, 1)
          @cur += 1
          if !apply_rule(:evaluate_rule_opt_spaces_or_comments, answer.thunks, nil, 0)
            throw(0)
          end
          if !apply_rule(:evaluate_rule_quantity, answer.thunks, answer.values, 0)
            throw(0)
          end
          answer.thunks.push(
            ThunkLeaf.new(
              :action_term_1,
              Capture.new(
                answer.pos, @cur,
                answer.pos_loc, @cur_loc,
              ),
              answer.values.slice(0),
              {},
            )
          )
          throw(1)
        end
        @cur = pos
        @cur_loc = p_loc
        answer.thunks[n..-1] = []
        catch(4) do
          if !apply_rule(:evaluate_rule_quantity, answer.thunks, answer.values, 0)
            throw(4)
          end
          answer.thunks.push(
            ThunkLeaf.new(
              :action_term_2,
              Capture.new(
                answer.pos, @cur,
                answer.pos_loc, @cur_loc,
              ),
              answer.values.slice(0),
              {},
            )
          )
          throw(1)
        end
        @cur = pos
        @cur_loc = p_loc
        answer.thunks[n..-1] = []
        throw(0)
      end
      @level -= 1
      debug { warn "#{ "  " * @level}MATCH   term #{answer.pos} #{@buffer[answer.pos...@cur].inspect}" }
      return answer
    end
    @level -= 1
    debug { warn "#{ "  " * @level}NOMATCH term #{answer.pos} #{@buffer[answer.pos...@cur].inspect}" }
    return nil
  end

  def evaluate_rule_quantity
    answer = ThunkChunk.new
    answer.pos = @cur
    answer.pos_loc = @cur_loc
    debug { warn "#{ "  " * @level}EVAL    quantity #{answer.pos} #{@buffer[answer.pos..-1].inspect}" }
    @level += 1
    answer.resize_captures(0)
    answer.values = {}
    catch(0) do
      catch(1) do |; pos, p_loc, n|
        pos = @cur
        p_loc = @cur_loc
        n = answer.thunks.length
        catch(2) do
          if !apply_rule(:evaluate_rule_primary, answer.thunks, answer.values, 0)
            throw(2)
          end
          if !apply_rule(:evaluate_rule_opt_spaces_or_comments, answer.thunks, nil, 0)
            throw(2)
          end
          if (
            refill_buffer(1) < 1 ||
            @buffer[@cur] != "*"
          )
            throw(2)
          end
          @cur_loc = @cur_loc.forward(@buffer, @cur, 1)
          @cur += 1
          answer.thunks.push(
            ThunkLeaf.new(
              :action_quantity_0,
              Capture.new(
                answer.pos, @cur,
                answer.pos_loc, @cur_loc,
              ),
              answer.values.slice(0),
              {},
            )
          )
          throw(1)
        end
        @cur = pos
        @cur_loc = p_loc
        answer.thunks[n..-1] = []
        catch(3) do
          if !apply_rule(:evaluate_rule_primary, answer.thunks, answer.values, 0)
            throw(3)
          end
          if !apply_rule(:evaluate_rule_opt_spaces_or_comments, answer.thunks, nil, 0)
            throw(3)
          end
          if (
            refill_buffer(1) < 1 ||
            @buffer[@cur] != "+"
          )
            throw(3)
          end
          @cur_loc = @cur_loc.forward(@buffer, @cur, 1)
          @cur += 1
          answer.thunks.push(
            ThunkLeaf.new(
              :action_quantity_1,
              Capture.new(
                answer.pos, @cur,
                answer.pos_loc, @cur_loc,
              ),
              answer.values.slice(0),
              {},
            )
          )
          throw(1)
        end
        @cur = pos
        @cur_loc = p_loc
        answer.thunks[n..-1] = []
        catch(4) do
          if !apply_rule(:evaluate_rule_primary, answer.thunks, answer.values, 0)
            throw(4)
          end
          if !apply_rule(:evaluate_rule_opt_spaces_or_comments, answer.thunks, nil, 0)
            throw(4)
          end
          if (
            refill_buffer(1) < 1 ||
            @buffer[@cur] != "?"
          )
            throw(4)
          end
          @cur_loc = @cur_loc.forward(@buffer, @cur, 1)
          @cur += 1
          answer.thunks.push(
            ThunkLeaf.new(
              :action_quantity_2,
              Capture.new(
                answer.pos, @cur,
                answer.pos_loc, @cur_loc,
              ),
              answer.values.slice(0),
              {},
            )
          )
          throw(1)
        end
        @cur = pos
        @cur_loc = p_loc
        answer.thunks[n..-1] = []
        catch(5) do
          if !apply_rule(:evaluate_rule_primary, answer.thunks, answer.values, 0)
            throw(5)
          end
          answer.thunks.push(
            ThunkLeaf.new(
              :action_quantity_3,
              Capture.new(
                answer.pos, @cur,
                answer.pos_loc, @cur_loc,
              ),
              answer.values.slice(0),
              {},
            )
          )
          throw(1)
        end
        @cur = pos
        @cur_loc = p_loc
        answer.thunks[n..-1] = []
        throw(0)
      end
      @level -= 1
      debug { warn "#{ "  " * @level}MATCH   quantity #{answer.pos} #{@buffer[answer.pos...@cur].inspect}" }
      return answer
    end
    @level -= 1
    debug { warn "#{ "  " * @level}NOMATCH quantity #{answer.pos} #{@buffer[answer.pos...@cur].inspect}" }
    return nil
  end

  def evaluate_rule_primary
    answer = ThunkChunk.new
    answer.pos = @cur
    answer.pos_loc = @cur_loc
    debug { warn "#{ "  " * @level}EVAL    primary #{answer.pos} #{@buffer[answer.pos..-1].inspect}" }
    @level += 1
    answer.resize_captures(1)
    answer.values = {}
    catch(0) do
      catch(1) do |; pos, p_loc, n|
        pos = @cur
        p_loc = @cur_loc
        n = answer.thunks.length
        catch(2) do
          if !apply_rule(:evaluate_rule_lang_code_block, answer.thunks, answer.values, 0)
            throw(2)
          end
          answer.thunks.push(
            ThunkLeaf.new(
              :action_primary_0,
              Capture.new(
                answer.pos, @cur,
                answer.pos_loc, @cur_loc,
              ),
              answer.values.slice(0),
              {},
            )
          )
          throw(1)
        end
        @cur = pos
        @cur_loc = p_loc
        answer.thunks[n..-1] = []
        catch(3) do
          if !apply_rule(:evaluate_rule_identifier, answer.thunks, answer.values, 1)
            throw(3)
          end
          if !apply_rule(:evaluate_rule_opt_spaces_or_comments, answer.thunks, nil, 0)
            throw(3)
          end
          if (
            refill_buffer(1) < 1 ||
            @buffer[@cur] != ":"
          )
            throw(3)
          end
          @cur_loc = @cur_loc.forward(@buffer, @cur, 1)
          @cur += 1
          if !apply_rule(:evaluate_rule_opt_spaces_or_comments, answer.thunks, nil, 0)
            throw(0)
          end
          if !apply_rule(:evaluate_rule_identifier, answer.thunks, answer.values, 2)
            throw(0)
          end
          1.times do |;pos, p_loc|
            pos = @cur
            p_loc = @cur_loc
            catch(4) do
              1.times do |;p0, p0_loc, n0, i, pos, p_loc, n, stat|
                i = 0
                catch(5) do
                  pos = @cur
                  p_loc = @cur_loc
                  n = answer.thunks.length
                  1.times do |;u, n|
                    if refill_buffer(1) < 1
                      throw(5)
                    end
                    u = @buffer[@cur]
                    if (!(
                      u == " " ||
                      u == "\t" ||
                      u == "\v" ||
                      u == "\f" ||
                      u == "\r" ||
                      u == "\n"
                    ))
                      throw(5)
                    end
                    @cur_loc = @cur_loc.forward(@buffer, @cur, 1)
                    @cur += 1
                  end
                  i += 1
                  if @cur != pos
                    redo
                  end
                  pos = nil
                end
                if pos
                  @cur = pos
                  @cur_loc = p_loc
                  answer.thunks[n..-1] = []
                end
              end
              if (
                refill_buffer(2) < 2 ||
                @buffer[@cur, 2] != "<-"
              )
                throw(4)
              end
              @cur_loc = @cur_loc.forward(@buffer, @cur, 2)
              @cur += 2
              @cur = pos
              @cur_loc = p_loc
              throw(0)
            end
            @cur = pos
            @cur_loc = p_loc
          end
          answer.thunks.push(
            ThunkLeaf.new(
              :action_primary_1,
              Capture.new(
                answer.pos, @cur,
                answer.pos_loc, @cur_loc,
              ),
              answer.values.slice(1, 2),
              {},
            )
          )
          throw(1)
        end
        @cur = pos
        @cur_loc = p_loc
        answer.thunks[n..-1] = []
        catch(6) do
          if (
            refill_buffer(2) < 2 ||
            @buffer[@cur, 2] != "$$"
          )
            throw(6)
          end
          @cur_loc = @cur_loc.forward(@buffer, @cur, 2)
          @cur += 2
          if !apply_rule(:evaluate_rule_opt_spaces_or_comments, answer.thunks, nil, 0)
            throw(6)
          end
          if (
            refill_buffer(1) < 1 ||
            @buffer[@cur] != ":"
          )
            throw(6)
          end
          @cur_loc = @cur_loc.forward(@buffer, @cur, 1)
          @cur += 1
          if !apply_rule(:evaluate_rule_opt_spaces_or_comments, answer.thunks, nil, 0)
            throw(0)
          end
          if !apply_rule(:evaluate_rule_identifier, answer.thunks, answer.values, 2)
            throw(0)
          end
          1.times do |;pos, p_loc|
            pos = @cur
            p_loc = @cur_loc
            catch(7) do
              1.times do |;p0, p0_loc, n0, i, pos, p_loc, n, stat|
                i = 0
                catch(8) do
                  pos = @cur
                  p_loc = @cur_loc
                  n = answer.thunks.length
                  1.times do |;u, n|
                    if refill_buffer(1) < 1
                      throw(8)
                    end
                    u = @buffer[@cur]
                    if (!(
                      u == " " ||
                      u == "\t" ||
                      u == "\v" ||
                      u == "\f" ||
                      u == "\r" ||
                      u == "\n"
                    ))
                      throw(8)
                    end
                    @cur_loc = @cur_loc.forward(@buffer, @cur, 1)
                    @cur += 1
                  end
                  i += 1
                  if @cur != pos
                    redo
                  end
                  pos = nil
                end
                if pos
                  @cur = pos
                  @cur_loc = p_loc
                  answer.thunks[n..-1] = []
                end
              end
              if (
                refill_buffer(2) < 2 ||
                @buffer[@cur, 2] != "<-"
              )
                throw(7)
              end
              @cur_loc = @cur_loc.forward(@buffer, @cur, 2)
              @cur += 2
              @cur = pos
              @cur_loc = p_loc
              throw(0)
            end
            @cur = pos
            @cur_loc = p_loc
          end
          answer.thunks.push(
            ThunkLeaf.new(
              :action_primary_2,
              Capture.new(
                answer.pos, @cur,
                answer.pos_loc, @cur_loc,
              ),
              answer.values.slice(2),
              {},
            )
          )
          throw(1)
        end
        @cur = pos
        @cur_loc = p_loc
        answer.thunks[n..-1] = []
        catch(9) do
          if !apply_rule(:evaluate_rule_identifier, answer.thunks, answer.values, 2)
            throw(9)
          end
          1.times do |;pos, p_loc|
            pos = @cur
            p_loc = @cur_loc
            catch(10) do
              1.times do |;p0, p0_loc, n0, i, pos, p_loc, n, stat|
                i = 0
                catch(11) do
                  pos = @cur
                  p_loc = @cur_loc
                  n = answer.thunks.length
                  1.times do |;u, n|
                    if refill_buffer(1) < 1
                      throw(11)
                    end
                    u = @buffer[@cur]
                    if (!(
                      u == " " ||
                      u == "\t" ||
                      u == "\v" ||
                      u == "\f" ||
                      u == "\r" ||
                      u == "\n"
                    ))
                      throw(11)
                    end
                    @cur_loc = @cur_loc.forward(@buffer, @cur, 1)
                    @cur += 1
                  end
                  i += 1
                  if @cur != pos
                    redo
                  end
                  pos = nil
                end
                if pos
                  @cur = pos
                  @cur_loc = p_loc
                  answer.thunks[n..-1] = []
                end
              end
              if (
                refill_buffer(2) < 2 ||
                @buffer[@cur, 2] != "<-"
              )
                throw(10)
              end
              @cur_loc = @cur_loc.forward(@buffer, @cur, 2)
              @cur += 2
              @cur = pos
              @cur_loc = p_loc
              throw(0)
            end
            @cur = pos
            @cur_loc = p_loc
          end
          answer.thunks.push(
            ThunkLeaf.new(
              :action_primary_3,
              Capture.new(
                answer.pos, @cur,
                answer.pos_loc, @cur_loc,
              ),
              answer.values.slice(2),
              {},
            )
          )
          throw(1)
        end
        @cur = pos
        @cur_loc = p_loc
        answer.thunks[n..-1] = []
        catch(12) do
          if (
            refill_buffer(1) < 1 ||
            @buffer[@cur] != "("
          )
            throw(12)
          end
          @cur_loc = @cur_loc.forward(@buffer, @cur, 1)
          @cur += 1
          if !apply_rule(:evaluate_rule_opt_spaces_or_comments, answer.thunks, nil, 0)
            throw(0)
          end
          if !apply_rule(:evaluate_rule_expression, answer.thunks, answer.values, 3)
            throw(0)
          end
          if !apply_rule(:evaluate_rule_opt_spaces_or_comments, answer.thunks, nil, 0)
            throw(0)
          end
          if (
            refill_buffer(1) < 1 ||
            @buffer[@cur] != ")"
          )
            throw(0)
          end
          @cur_loc = @cur_loc.forward(@buffer, @cur, 1)
          @cur += 1
          answer.thunks.push(
            ThunkLeaf.new(
              :action_primary_4,
              Capture.new(
                answer.pos, @cur,
                answer.pos_loc, @cur_loc,
              ),
              answer.values.slice(3),
              {},
            )
          )
          throw(1)
        end
        @cur = pos
        @cur_loc = p_loc
        answer.thunks[n..-1] = []
        catch(13) do
          if (
            refill_buffer(1) < 1 ||
            @buffer[@cur] != "<"
          )
            throw(13)
          end
          @cur_loc = @cur_loc.forward(@buffer, @cur, 1)
          @cur += 1
          if !apply_rule(:evaluate_rule_opt_spaces_or_comments, answer.thunks, nil, 0)
            throw(0)
          end
          if !apply_rule(:evaluate_rule_expression, answer.thunks, answer.values, 3)
            throw(0)
          end
          if !apply_rule(:evaluate_rule_opt_spaces_or_comments, answer.thunks, nil, 0)
            throw(0)
          end
          if (
            refill_buffer(1) < 1 ||
            @buffer[@cur] != ">"
          )
            throw(0)
          end
          @cur_loc = @cur_loc.forward(@buffer, @cur, 1)
          @cur += 1
          answer.thunks.push(
            ThunkLeaf.new(
              :action_primary_5,
              Capture.new(
                answer.pos, @cur,
                answer.pos_loc, @cur_loc,
              ),
              answer.values.slice(3),
              {},
            )
          )
          throw(1)
        end
        @cur = pos
        @cur_loc = p_loc
        answer.thunks[n..-1] = []
        catch(14) do
          if (
            refill_buffer(1) < 1 ||
            @buffer[@cur] != "$"
          )
            throw(14)
          end
          @cur_loc = @cur_loc.forward(@buffer, @cur, 1)
          @cur += 1
          1.times do |;pos, q, capt, p_loc, q_loc|
            pos = @cur
            p_loc = @cur_loc
            1.times do |;u, n|
              if refill_buffer(1) < 1
                throw(14)
              end
              u = @buffer[@cur]
              if (!(
                (u >= "1" && u <= "9")
              ))
                throw(14)
              end
              @cur_loc = @cur_loc.forward(@buffer, @cur, 1)
              @cur += 1
            end
            1.times do |;p0, p0_loc, n0, i, pos, p_loc, n, stat|
              i = 0
              catch(15) do
                pos = @cur
                p_loc = @cur_loc
                n = answer.thunks.length
                1.times do |;u, n|
                  if refill_buffer(1) < 1
                    throw(15)
                  end
                  u = @buffer[@cur]
                  if (!(
                    (u >= "0" && u <= "9")
                  ))
                    throw(15)
                  end
                  @cur_loc = @cur_loc.forward(@buffer, @cur, 1)
                  @cur += 1
                end
                i += 1
                if @cur != pos
                  redo
                end
                pos = nil
              end
              if pos
                @cur = pos
                @cur_loc = p_loc
                answer.thunks[n..-1] = []
              end
            end
            q = @cur
            capt = answer.capts[0]
            capt.range_start = pos
            capt.range_end = q
            q_loc = @cur_loc
            capt.start_loc = p_loc
            capt.end_loc = q_loc
          end
          answer.thunks.push(
            ThunkLeaf.new(
              :action_primary_6,
              Capture.new(
                answer.pos, @cur,
                answer.pos_loc, @cur_loc,
              ),
              {},
              answer.capts.slice(0),
            )
          )
          throw(1)
        end
        @cur = pos
        @cur_loc = p_loc
        answer.thunks[n..-1] = []
        catch(16) do
          if (
            refill_buffer(1) < 1 ||
            @buffer[@cur] != "."
          )
            throw(16)
          end
          @cur_loc = @cur_loc.forward(@buffer, @cur, 1)
          @cur += 1
          answer.thunks.push(
            ThunkLeaf.new(
              :action_primary_7,
              Capture.new(
                answer.pos, @cur,
                answer.pos_loc, @cur_loc,
              ),
              {},
              {},
            )
          )
          throw(1)
        end
        @cur = pos
        @cur_loc = p_loc
        answer.thunks[n..-1] = []
        catch(17) do
          if !apply_rule(:evaluate_rule_character_class, answer.thunks, answer.values, 4)
            throw(17)
          end
          answer.thunks.push(
            ThunkLeaf.new(
              :action_primary_8,
              Capture.new(
                answer.pos, @cur,
                answer.pos_loc, @cur_loc,
              ),
              answer.values.slice(4),
              {},
            )
          )
          throw(1)
        end
        @cur = pos
        @cur_loc = p_loc
        answer.thunks[n..-1] = []
        catch(18) do
          if !apply_rule(:evaluate_rule_quotation_single, answer.thunks, answer.values, 4)
            throw(18)
          end
          answer.thunks.push(
            ThunkLeaf.new(
              :action_primary_9,
              Capture.new(
                answer.pos, @cur,
                answer.pos_loc, @cur_loc,
              ),
              answer.values.slice(4),
              {},
            )
          )
          throw(1)
        end
        @cur = pos
        @cur_loc = p_loc
        answer.thunks[n..-1] = []
        catch(19) do
          if !apply_rule(:evaluate_rule_quotation_double, answer.thunks, answer.values, 4)
            throw(19)
          end
          answer.thunks.push(
            ThunkLeaf.new(
              :action_primary_10,
              Capture.new(
                answer.pos, @cur,
                answer.pos_loc, @cur_loc,
              ),
              answer.values.slice(4),
              {},
            )
          )
          throw(1)
        end
        @cur = pos
        @cur_loc = p_loc
        answer.thunks[n..-1] = []
        throw(0)
      end
      @level -= 1
      debug { warn "#{ "  " * @level}MATCH   primary #{answer.pos} #{@buffer[answer.pos...@cur].inspect}" }
      return answer
    end
    @level -= 1
    debug { warn "#{ "  " * @level}NOMATCH primary #{answer.pos} #{@buffer[answer.pos...@cur].inspect}" }
    return nil
  end

  def evaluate_rule_character_class
    answer = ThunkChunk.new
    answer.pos = @cur
    answer.pos_loc = @cur_loc
    debug { warn "#{ "  " * @level}EVAL    character_class #{answer.pos} #{@buffer[answer.pos..-1].inspect}" }
    @level += 1
    answer.resize_captures(1)
    catch(0) do
      if (
        refill_buffer(1) < 1 ||
        @buffer[@cur] != "["
      )
        throw(0)
      end
      @cur_loc = @cur_loc.forward(@buffer, @cur, 1)
      @cur += 1
      1.times do |;pos, q, capt, p_loc, q_loc|
        pos = @cur
        p_loc = @cur_loc
        1.times do |;p0, p0_loc, n0, i, pos, p_loc, n, stat|
          i = 0
          catch(1) do
            pos = @cur
            p_loc = @cur_loc
            n = answer.thunks.length
            catch(2) do |; pos, p_loc, n|
              pos = @cur
              p_loc = @cur_loc
              n = answer.thunks.length
              1.times do |;u, n|
                if refill_buffer(1) >= 1
                  u = @buffer[@cur]
                  unless (
                    u == "\\" ||
                    u == "[" ||
                    u == "]"
                  )
                    @cur_loc = @cur_loc.forward(@buffer, @cur, 1)
                    @cur += 1
                    throw(2)
                  end
                end
              end
              @cur = pos
              @cur_loc = p_loc
              answer.thunks[n..-1] = []
              catch(3) do
                if (
                  refill_buffer(2) < 2 ||
                  @buffer[@cur, 2] != "\\["
                )
                  throw(3)
                end
                @cur_loc = @cur_loc.forward(@buffer, @cur, 2)
                @cur += 2
                throw(2)
              end
              @cur = pos
              @cur_loc = p_loc
              answer.thunks[n..-1] = []
              catch(4) do
                if (
                  refill_buffer(2) < 2 ||
                  @buffer[@cur, 2] != "\\]"
                )
                  throw(4)
                end
                @cur_loc = @cur_loc.forward(@buffer, @cur, 2)
                @cur += 2
                throw(2)
              end
              @cur = pos
              @cur_loc = p_loc
              answer.thunks[n..-1] = []
              catch(5) do
                if (
                  refill_buffer(1) < 1 ||
                  @buffer[@cur] != "\\"
                )
                  throw(5)
                end
                @cur_loc = @cur_loc.forward(@buffer, @cur, 1)
                @cur += 1
                throw(2)
              end
              @cur = pos
              @cur_loc = p_loc
              answer.thunks[n..-1] = []
              throw(1)
            end
            i += 1
            if @cur != pos
              redo
            end
            pos = nil
          end
          if pos
            @cur = pos
            @cur_loc = p_loc
            answer.thunks[n..-1] = []
          end
        end
        q = @cur
        capt = answer.capts[0]
        capt.range_start = pos
        capt.range_end = q
        q_loc = @cur_loc
        capt.start_loc = p_loc
        capt.end_loc = q_loc
      end
      if (
        refill_buffer(1) < 1 ||
        @buffer[@cur] != "]"
      )
        throw(0)
      end
      @cur_loc = @cur_loc.forward(@buffer, @cur, 1)
      @cur += 1
      answer.thunks.push(
        ThunkLeaf.new(
          :action_character_class_0,
          Capture.new(
            answer.pos, @cur,
            answer.pos_loc, @cur_loc,
          ),
          {},
          answer.capts.slice(0),
        )
      )
      @level -= 1
      debug { warn "#{ "  " * @level}MATCH   character_class #{answer.pos} #{@buffer[answer.pos...@cur].inspect}" }
      return answer
    end
    @level -= 1
    debug { warn "#{ "  " * @level}NOMATCH character_class #{answer.pos} #{@buffer[answer.pos...@cur].inspect}" }
    return nil
  end

  def evaluate_rule_lang_code_block
    answer = ThunkChunk.new
    answer.pos = @cur
    answer.pos_loc = @cur_loc
    debug { warn "#{ "  " * @level}EVAL    lang_code_block #{answer.pos} #{@buffer[answer.pos..-1].inspect}" }
    @level += 1
    answer.resize_captures(1)
    answer.values = {}
    catch(0) do
      catch(1) do |; pos, p_loc, n|
        pos = @cur
        p_loc = @cur_loc
        n = answer.thunks.length
        catch(2) do
          if !apply_rule(:evaluate_rule_code_block, answer.thunks, answer.values, 0)
            throw(2)
          end
          answer.thunks.push(
            ThunkLeaf.new(
              :action_lang_code_block_0,
              Capture.new(
                answer.pos, @cur,
                answer.pos_loc, @cur_loc,
              ),
              answer.values.slice(0),
              {},
            )
          )
          throw(1)
        end
        @cur = pos
        @cur_loc = p_loc
        answer.thunks[n..-1] = []
        catch(3) do
          1.times do |;pos, q, capt, p_loc, q_loc|
            pos = @cur
            p_loc = @cur_loc
            if !apply_rule(:evaluate_rule_supported_language, answer.thunks, nil, 0)
              throw(3)
            end
            q = @cur
            capt = answer.capts[0]
            capt.range_start = pos
            capt.range_end = q
            q_loc = @cur_loc
            capt.start_loc = p_loc
            capt.end_loc = q_loc
          end
          if !apply_rule(:evaluate_rule_opt_spaces_or_comments, answer.thunks, nil, 0)
            throw(3)
          end
          if (
            refill_buffer(2) < 2 ||
            @buffer[@cur, 2] != "->"
          )
            throw(3)
          end
          @cur_loc = @cur_loc.forward(@buffer, @cur, 2)
          @cur += 2
          if !apply_rule(:evaluate_rule_opt_spaces_or_comments, answer.thunks, nil, 0)
            throw(3)
          end
          if !apply_rule(:evaluate_rule_code_block, answer.thunks, answer.values, 0)
            throw(3)
          end
          answer.thunks.push(
            ThunkLeaf.new(
              :action_lang_code_block_1,
              Capture.new(
                answer.pos, @cur,
                answer.pos_loc, @cur_loc,
              ),
              answer.values.slice(0),
              answer.capts.slice(0),
            )
          )
          throw(1)
        end
        @cur = pos
        @cur_loc = p_loc
        answer.thunks[n..-1] = []
        throw(0)
      end
      @level -= 1
      debug { warn "#{ "  " * @level}MATCH   lang_code_block #{answer.pos} #{@buffer[answer.pos...@cur].inspect}" }
      return answer
    end
    @level -= 1
    debug { warn "#{ "  " * @level}NOMATCH lang_code_block #{answer.pos} #{@buffer[answer.pos...@cur].inspect}" }
    return nil
  end

  def evaluate_rule_code_block
    answer = ThunkChunk.new
    answer.pos = @cur
    answer.pos_loc = @cur_loc
    debug { warn "#{ "  " * @level}EVAL    code_block #{answer.pos} #{@buffer[answer.pos..-1].inspect}" }
    @level += 1
    answer.resize_captures(0)
    answer.values = {}
    catch(0) do
      catch(1) do |; pos, p_loc, n|
        pos = @cur
        p_loc = @cur_loc
        n = answer.thunks.length
        catch(2) do
          if (
            refill_buffer(1) < 1 ||
            @buffer[@cur] != "$"
          )
            throw(2)
          end
          @cur_loc = @cur_loc.forward(@buffer, @cur, 1)
          @cur += 1
          if !apply_rule(:evaluate_rule_plain_code_block, answer.thunks, answer.values, 0)
            throw(2)
          end
          answer.thunks.push(
            ThunkLeaf.new(
              :action_code_block_0,
              Capture.new(
                answer.pos, @cur,
                answer.pos_loc, @cur_loc,
              ),
              answer.values.slice(0),
              {},
            )
          )
          throw(1)
        end
        @cur = pos
        @cur_loc = p_loc
        answer.thunks[n..-1] = []
        catch(3) do
          if !apply_rule(:evaluate_rule_plain_code_block, answer.thunks, answer.values, 0)
            throw(3)
          end
          answer.thunks.push(
            ThunkLeaf.new(
              :action_code_block_1,
              Capture.new(
                answer.pos, @cur,
                answer.pos_loc, @cur_loc,
              ),
              answer.values.slice(0),
              {},
            )
          )
          throw(1)
        end
        @cur = pos
        @cur_loc = p_loc
        answer.thunks[n..-1] = []
        throw(0)
      end
      @level -= 1
      debug { warn "#{ "  " * @level}MATCH   code_block #{answer.pos} #{@buffer[answer.pos...@cur].inspect}" }
      return answer
    end
    @level -= 1
    debug { warn "#{ "  " * @level}NOMATCH code_block #{answer.pos} #{@buffer[answer.pos...@cur].inspect}" }
    return nil
  end

  def evaluate_rule_plain_code_block
    answer = ThunkChunk.new
    answer.pos = @cur
    answer.pos_loc = @cur_loc
    debug { warn "#{ "  " * @level}EVAL    plain_code_block #{answer.pos} #{@buffer[answer.pos..-1].inspect}" }
    @level += 1
    answer.resize_captures(1)
    catch(0) do
      if (
        refill_buffer(1) < 1 ||
        @buffer[@cur] != "{"
      )
        throw(0)
      end
      @cur_loc = @cur_loc.forward(@buffer, @cur, 1)
      @cur += 1
      1.times do |;pos, q, capt, p_loc, q_loc|
        pos = @cur
        p_loc = @cur_loc
        1.times do |;p0, p0_loc, n0, i, pos, p_loc, n, stat|
          i = 0
          catch(1) do
            pos = @cur
            p_loc = @cur_loc
            n = answer.thunks.length
            1.times do |;u, n|
              if refill_buffer(1) < 1
                throw(1)
              end
              u = @buffer[@cur]
              if (!(
                u == " " ||
                u == "\t" ||
                u == "\v" ||
                u == "\f" ||
                u == "\r" ||
                u == "\n"
              ))
                throw(1)
              end
              @cur_loc = @cur_loc.forward(@buffer, @cur, 1)
              @cur += 1
            end
            i += 1
            if @cur != pos
              redo
            end
            pos = nil
          end
          if pos
            @cur = pos
            @cur_loc = p_loc
            answer.thunks[n..-1] = []
          end
        end
        if !apply_rule(:evaluate_rule_opt_codes, answer.thunks, nil, 0)
          throw(0)
        end
        q = @cur
        capt = answer.capts[0]
        capt.range_start = pos
        capt.range_end = q
        q_loc = @cur_loc
        capt.start_loc = p_loc
        capt.end_loc = q_loc
      end
      if (
        refill_buffer(1) < 1 ||
        @buffer[@cur] != "}"
      )
        throw(0)
      end
      @cur_loc = @cur_loc.forward(@buffer, @cur, 1)
      @cur += 1
      answer.thunks.push(
        ThunkLeaf.new(
          :action_plain_code_block_0,
          Capture.new(
            answer.pos, @cur,
            answer.pos_loc, @cur_loc,
          ),
          {},
          answer.capts.slice(0),
        )
      )
      @level -= 1
      debug { warn "#{ "  " * @level}MATCH   plain_code_block #{answer.pos} #{@buffer[answer.pos...@cur].inspect}" }
      return answer
    end
    @level -= 1
    debug { warn "#{ "  " * @level}NOMATCH plain_code_block #{answer.pos} #{@buffer[answer.pos...@cur].inspect}" }
    return nil
  end

  def evaluate_rule_opt_codes
    answer = ThunkChunk.new
    answer.pos = @cur
    answer.pos_loc = @cur_loc
    debug { warn "#{ "  " * @level}EVAL    opt_codes #{answer.pos} #{@buffer[answer.pos..-1].inspect}" }
    @level += 1
    answer.resize_captures(0)
    1.times do |;p0, p0_loc, n0, i, pos, p_loc, n, stat|
      i = 0
      catch(1) do
        pos = @cur
        p_loc = @cur_loc
        n = answer.thunks.length
        if !apply_rule(:evaluate_rule_code, answer.thunks, nil, 0)
          throw(1)
        end
        1.times do |;p0, p0_loc, n0, i, pos, p_loc, n, stat|
          i = 0
          catch(2) do
            pos = @cur
            p_loc = @cur_loc
            n = answer.thunks.length
            1.times do |;u, n|
              if refill_buffer(1) < 1
                throw(2)
              end
              u = @buffer[@cur]
              if (!(
                u == " " ||
                u == "\t" ||
                u == "\v" ||
                u == "\f" ||
                u == "\r" ||
                u == "\n"
              ))
                throw(2)
              end
              @cur_loc = @cur_loc.forward(@buffer, @cur, 1)
              @cur += 1
            end
            i += 1
            if @cur != pos
              redo
            end
            pos = nil
          end
          if pos
            @cur = pos
            @cur_loc = p_loc
            answer.thunks[n..-1] = []
          end
        end
        i += 1
        if @cur != pos
          redo
        end
        pos = nil
      end
      if pos
        @cur = pos
        @cur_loc = p_loc
        answer.thunks[n..-1] = []
      end
    end
    @level -= 1
    debug { warn "#{ "  " * @level}MATCH   opt_codes #{answer.pos} #{@buffer[answer.pos...@cur].inspect}" }
    return answer
  end

  def evaluate_rule_code
    answer = ThunkChunk.new
    answer.pos = @cur
    answer.pos_loc = @cur_loc
    debug { warn "#{ "  " * @level}EVAL    code #{answer.pos} #{@buffer[answer.pos..-1].inspect}" }
    @level += 1
    answer.resize_captures(0)
    catch(0) do
      catch(1) do |; pos, p_loc, n|
        pos = @cur
        p_loc = @cur_loc
        n = answer.thunks.length
        catch(2) do
          1.times do |;p0, p0_loc, n0, i, pos, p_loc, n, stat|
            p0 = @cur
            p0_loc = @cur_loc
            n0 = answer.thunks.length
            i = 0
            catch(3) do
              pos = @cur
              p_loc = @cur_loc
              n = answer.thunks.length
              if !apply_rule(:evaluate_rule_codechar, answer.thunks, nil, 0)
                throw(3)
              end
              i += 1
              if @cur != pos
                redo
              end
              pos = nil
            end
            if pos
              @cur = pos
              @cur_loc = p_loc
              answer.thunks[n..-1] = []
            end
            if i < 1
              @cur = p0
              @cur_loc = p0_loc
              answer.thunks[n0..-1] = []
              throw(2)
            end
          end
          throw(1)
        end
        @cur = pos
        @cur_loc = p_loc
        answer.thunks[n..-1] = []
        if apply_rule(:evaluate_rule_quotation_single, answer.thunks, nil, 0)
          throw(1)
        end
        @cur = pos
        @cur_loc = p_loc
        answer.thunks[n..-1] = []
        if apply_rule(:evaluate_rule_quotation_double, answer.thunks, nil, 0)
          throw(1)
        end
        @cur = pos
        @cur_loc = p_loc
        answer.thunks[n..-1] = []
        catch(4) do
          if (
            refill_buffer(1) < 1 ||
            @buffer[@cur] != "{"
          )
            throw(4)
          end
          @cur_loc = @cur_loc.forward(@buffer, @cur, 1)
          @cur += 1
          1.times do |;p0, p0_loc, n0, i, pos, p_loc, n, stat|
            i = 0
            catch(5) do
              pos = @cur
              p_loc = @cur_loc
              n = answer.thunks.length
              if !apply_rule(:evaluate_rule_code, answer.thunks, nil, 0)
                throw(5)
              end
              i += 1
              if @cur != pos
                redo
              end
              pos = nil
            end
            if pos
              @cur = pos
              @cur_loc = p_loc
              answer.thunks[n..-1] = []
            end
          end
          if (
            refill_buffer(1) < 1 ||
            @buffer[@cur] != "}"
          )
            throw(4)
          end
          @cur_loc = @cur_loc.forward(@buffer, @cur, 1)
          @cur += 1
          throw(1)
        end
        @cur = pos
        @cur_loc = p_loc
        answer.thunks[n..-1] = []
        throw(0)
      end
      @level -= 1
      debug { warn "#{ "  " * @level}MATCH   code #{answer.pos} #{@buffer[answer.pos...@cur].inspect}" }
      return answer
    end
    @level -= 1
    debug { warn "#{ "  " * @level}NOMATCH code #{answer.pos} #{@buffer[answer.pos...@cur].inspect}" }
    return nil
  end

  def evaluate_rule_codechar
    answer = ThunkChunk.new
    answer.pos = @cur
    answer.pos_loc = @cur_loc
    debug { warn "#{ "  " * @level}EVAL    codechar #{answer.pos} #{@buffer[answer.pos..-1].inspect}" }
    @level += 1
    answer.resize_captures(0)
    catch(0) do
      catch(1) do |; pos, p_loc, n|
        pos = @cur
        p_loc = @cur_loc
        n = answer.thunks.length
        1.times do |;u, n|
          if refill_buffer(1) >= 1
            u = @buffer[@cur]
            unless (
              u == "{" ||
              u == "}" ||
              u == "\"" ||
              u == "'"
            )
              @cur_loc = @cur_loc.forward(@buffer, @cur, 1)
              @cur += 1
              throw(1)
            end
          end
        end
        @cur = pos
        @cur_loc = p_loc
        answer.thunks[n..-1] = []
        catch(2) do
          if (
            refill_buffer(2) < 2 ||
            @buffer[@cur, 2] != "\\\""
          )
            throw(2)
          end
          @cur_loc = @cur_loc.forward(@buffer, @cur, 2)
          @cur += 2
          throw(1)
        end
        @cur = pos
        @cur_loc = p_loc
        answer.thunks[n..-1] = []
        catch(3) do
          if (
            refill_buffer(2) < 2 ||
            @buffer[@cur, 2] != "\\'"
          )
            throw(3)
          end
          @cur_loc = @cur_loc.forward(@buffer, @cur, 2)
          @cur += 2
          throw(1)
        end
        @cur = pos
        @cur_loc = p_loc
        answer.thunks[n..-1] = []
        catch(4) do
          if (
            refill_buffer(2) < 2 ||
            @buffer[@cur, 2] != "\\{"
          )
            throw(4)
          end
          @cur_loc = @cur_loc.forward(@buffer, @cur, 2)
          @cur += 2
          throw(1)
        end
        @cur = pos
        @cur_loc = p_loc
        answer.thunks[n..-1] = []
        catch(5) do
          if (
            refill_buffer(2) < 2 ||
            @buffer[@cur, 2] != "\\}"
          )
            throw(5)
          end
          @cur_loc = @cur_loc.forward(@buffer, @cur, 2)
          @cur += 2
          throw(1)
        end
        @cur = pos
        @cur_loc = p_loc
        answer.thunks[n..-1] = []
        throw(0)
      end
      @level -= 1
      debug { warn "#{ "  " * @level}MATCH   codechar #{answer.pos} #{@buffer[answer.pos...@cur].inspect}" }
      return answer
    end
    @level -= 1
    debug { warn "#{ "  " * @level}NOMATCH codechar #{answer.pos} #{@buffer[answer.pos...@cur].inspect}" }
    return nil
  end

  def evaluate_rule_quotation_single
    answer = ThunkChunk.new
    answer.pos = @cur
    answer.pos_loc = @cur_loc
    debug { warn "#{ "  " * @level}EVAL    quotation_single #{answer.pos} #{@buffer[answer.pos..-1].inspect}" }
    @level += 1
    answer.resize_captures(1)
    catch(0) do
      if (
        refill_buffer(1) < 1 ||
        @buffer[@cur] != "\'"
      )
        throw(0)
      end
      @cur_loc = @cur_loc.forward(@buffer, @cur, 1)
      @cur += 1
      1.times do |;pos, q, capt, p_loc, q_loc|
        pos = @cur
        p_loc = @cur_loc
        1.times do |;p0, p0_loc, n0, i, pos, p_loc, n, stat|
          i = 0
          catch(1) do
            pos = @cur
            p_loc = @cur_loc
            n = answer.thunks.length
            catch(2) do |; pos, p_loc, n|
              pos = @cur
              p_loc = @cur_loc
              n = answer.thunks.length
              1.times do |;u, n|
                if refill_buffer(1) >= 1
                  u = @buffer[@cur]
                  unless (
                    u == "\\" ||
                    u == "'" ||
                    u == "\n"
                  )
                    @cur_loc = @cur_loc.forward(@buffer, @cur, 1)
                    @cur += 1
                    throw(2)
                  end
                end
              end
              @cur = pos
              @cur_loc = p_loc
              answer.thunks[n..-1] = []
              catch(3) do
                if (
                  refill_buffer(2) < 2 ||
                  @buffer[@cur, 2] != "\\'"
                )
                  throw(3)
                end
                @cur_loc = @cur_loc.forward(@buffer, @cur, 2)
                @cur += 2
                throw(2)
              end
              @cur = pos
              @cur_loc = p_loc
              answer.thunks[n..-1] = []
              catch(4) do
                if (
                  refill_buffer(2) < 2 ||
                  @buffer[@cur, 2] != "\\\n"
                )
                  throw(4)
                end
                @cur_loc = @cur_loc.forward(@buffer, @cur, 2)
                @cur += 2
                throw(2)
              end
              @cur = pos
              @cur_loc = p_loc
              answer.thunks[n..-1] = []
              catch(5) do
                if (
                  refill_buffer(1) < 1 ||
                  @buffer[@cur] != "\\"
                )
                  throw(5)
                end
                @cur_loc = @cur_loc.forward(@buffer, @cur, 1)
                @cur += 1
                1.times do |;u, n|
                  if refill_buffer(1) < 1
                    throw(5)
                  end
                  u = @buffer[@cur]
                  if (
                    u == "'" ||
                    u == "\n"
                  )
                    throw(5)
                  end
                  @cur_loc = @cur_loc.forward(@buffer, @cur, 1)
                  @cur += 1
                end
                throw(2)
              end
              @cur = pos
              @cur_loc = p_loc
              answer.thunks[n..-1] = []
              throw(1)
            end
            i += 1
            if @cur != pos
              redo
            end
            pos = nil
          end
          if pos
            @cur = pos
            @cur_loc = p_loc
            answer.thunks[n..-1] = []
          end
        end
        q = @cur
        capt = answer.capts[0]
        capt.range_start = pos
        capt.range_end = q
        q_loc = @cur_loc
        capt.start_loc = p_loc
        capt.end_loc = q_loc
      end
      if (
        refill_buffer(1) < 1 ||
        @buffer[@cur] != "\'"
      )
        throw(0)
      end
      @cur_loc = @cur_loc.forward(@buffer, @cur, 1)
      @cur += 1
      answer.thunks.push(
        ThunkLeaf.new(
          :action_quotation_single_0,
          Capture.new(
            answer.pos, @cur,
            answer.pos_loc, @cur_loc,
          ),
          {},
          answer.capts.slice(0),
        )
      )
      @level -= 1
      debug { warn "#{ "  " * @level}MATCH   quotation_single #{answer.pos} #{@buffer[answer.pos...@cur].inspect}" }
      return answer
    end
    @level -= 1
    debug { warn "#{ "  " * @level}NOMATCH quotation_single #{answer.pos} #{@buffer[answer.pos...@cur].inspect}" }
    return nil
  end

  def evaluate_rule_quotation_double
    answer = ThunkChunk.new
    answer.pos = @cur
    answer.pos_loc = @cur_loc
    debug { warn "#{ "  " * @level}EVAL    quotation_double #{answer.pos} #{@buffer[answer.pos..-1].inspect}" }
    @level += 1
    answer.resize_captures(1)
    catch(0) do
      if (
        refill_buffer(1) < 1 ||
        @buffer[@cur] != "\""
      )
        throw(0)
      end
      @cur_loc = @cur_loc.forward(@buffer, @cur, 1)
      @cur += 1
      1.times do |;pos, q, capt, p_loc, q_loc|
        pos = @cur
        p_loc = @cur_loc
        1.times do |;p0, p0_loc, n0, i, pos, p_loc, n, stat|
          i = 0
          catch(1) do
            pos = @cur
            p_loc = @cur_loc
            n = answer.thunks.length
            catch(2) do |; pos, p_loc, n|
              pos = @cur
              p_loc = @cur_loc
              n = answer.thunks.length
              1.times do |;u, n|
                if refill_buffer(1) >= 1
                  u = @buffer[@cur]
                  unless (
                    u == "\\" ||
                    u == "\"" ||
                    u == "\n"
                  )
                    @cur_loc = @cur_loc.forward(@buffer, @cur, 1)
                    @cur += 1
                    throw(2)
                  end
                end
              end
              @cur = pos
              @cur_loc = p_loc
              answer.thunks[n..-1] = []
              catch(3) do
                if (
                  refill_buffer(2) < 2 ||
                  @buffer[@cur, 2] != "\\\""
                )
                  throw(3)
                end
                @cur_loc = @cur_loc.forward(@buffer, @cur, 2)
                @cur += 2
                throw(2)
              end
              @cur = pos
              @cur_loc = p_loc
              answer.thunks[n..-1] = []
              catch(4) do
                if (
                  refill_buffer(2) < 2 ||
                  @buffer[@cur, 2] != "\\\n"
                )
                  throw(4)
                end
                @cur_loc = @cur_loc.forward(@buffer, @cur, 2)
                @cur += 2
                throw(2)
              end
              @cur = pos
              @cur_loc = p_loc
              answer.thunks[n..-1] = []
              catch(5) do
                if (
                  refill_buffer(1) < 1 ||
                  @buffer[@cur] != "\\"
                )
                  throw(5)
                end
                @cur_loc = @cur_loc.forward(@buffer, @cur, 1)
                @cur += 1
                1.times do |;u, n|
                  if refill_buffer(1) < 1
                    throw(5)
                  end
                  u = @buffer[@cur]
                  if (
                    u == "\"" ||
                    u == "\n"
                  )
                    throw(5)
                  end
                  @cur_loc = @cur_loc.forward(@buffer, @cur, 1)
                  @cur += 1
                end
                throw(2)
              end
              @cur = pos
              @cur_loc = p_loc
              answer.thunks[n..-1] = []
              throw(1)
            end
            i += 1
            if @cur != pos
              redo
            end
            pos = nil
          end
          if pos
            @cur = pos
            @cur_loc = p_loc
            answer.thunks[n..-1] = []
          end
        end
        q = @cur
        capt = answer.capts[0]
        capt.range_start = pos
        capt.range_end = q
        q_loc = @cur_loc
        capt.start_loc = p_loc
        capt.end_loc = q_loc
      end
      if (
        refill_buffer(1) < 1 ||
        @buffer[@cur] != "\""
      )
        throw(0)
      end
      @cur_loc = @cur_loc.forward(@buffer, @cur, 1)
      @cur += 1
      answer.thunks.push(
        ThunkLeaf.new(
          :action_quotation_double_0,
          Capture.new(
            answer.pos, @cur,
            answer.pos_loc, @cur_loc,
          ),
          {},
          answer.capts.slice(0),
        )
      )
      @level -= 1
      debug { warn "#{ "  " * @level}MATCH   quotation_double #{answer.pos} #{@buffer[answer.pos...@cur].inspect}" }
      return answer
    end
    @level -= 1
    debug { warn "#{ "  " * @level}NOMATCH quotation_double #{answer.pos} #{@buffer[answer.pos...@cur].inspect}" }
    return nil
  end

  def evaluate_rule_identifier
    answer = ThunkChunk.new
    answer.pos = @cur
    answer.pos_loc = @cur_loc
    debug { warn "#{ "  " * @level}EVAL    identifier #{answer.pos} #{@buffer[answer.pos..-1].inspect}" }
    @level += 1
    answer.resize_captures(0)
    catch(0) do
      1.times do |;u, n|
        if refill_buffer(1) < 1
          throw(0)
        end
        u = @buffer[@cur]
        if (!(
          (u >= "a" && u <= "z") ||
          (u >= "A" && u <= "Z") ||
          u == "_"
        ))
          throw(0)
        end
        @cur_loc = @cur_loc.forward(@buffer, @cur, 1)
        @cur += 1
      end
      1.times do |;p0, p0_loc, n0, i, pos, p_loc, n, stat|
        i = 0
        catch(1) do
          pos = @cur
          p_loc = @cur_loc
          n = answer.thunks.length
          1.times do |;u, n|
            if refill_buffer(1) < 1
              throw(1)
            end
            u = @buffer[@cur]
            if (!(
              (u >= "a" && u <= "z") ||
              (u >= "A" && u <= "Z") ||
              u == "_" ||
              (u >= "0" && u <= "9")
            ))
              throw(1)
            end
            @cur_loc = @cur_loc.forward(@buffer, @cur, 1)
            @cur += 1
          end
          i += 1
          if @cur != pos
            redo
          end
          pos = nil
        end
        if pos
          @cur = pos
          @cur_loc = p_loc
          answer.thunks[n..-1] = []
        end
      end
      answer.thunks.push(
        ThunkLeaf.new(
          :action_identifier_0,
          Capture.new(
            answer.pos, @cur,
            answer.pos_loc, @cur_loc,
          ),
          {},
          {},
        )
      )
      @level -= 1
      debug { warn "#{ "  " * @level}MATCH   identifier #{answer.pos} #{@buffer[answer.pos...@cur].inspect}" }
      return answer
    end
    @level -= 1
    debug { warn "#{ "  " * @level}NOMATCH identifier #{answer.pos} #{@buffer[answer.pos...@cur].inspect}" }
    return nil
  end

  def evaluate_rule_spaces
    answer = ThunkChunk.new
    answer.pos = @cur
    answer.pos_loc = @cur_loc
    debug { warn "#{ "  " * @level}EVAL    spaces #{answer.pos} #{@buffer[answer.pos..-1].inspect}" }
    @level += 1
    answer.resize_captures(0)
    catch(0) do
      1.times do |;p0, p0_loc, n0, i, pos, p_loc, n, stat|
        p0 = @cur
        p0_loc = @cur_loc
        n0 = answer.thunks.length
        i = 0
        catch(1) do
          pos = @cur
          p_loc = @cur_loc
          n = answer.thunks.length
          1.times do |;u, n|
            if refill_buffer(1) < 1
              throw(1)
            end
            u = @buffer[@cur]
            if (!(
              u == " " ||
              u == "\t" ||
              u == "\v" ||
              u == "\f" ||
              u == "\r" ||
              u == "\n"
            ))
              throw(1)
            end
            @cur_loc = @cur_loc.forward(@buffer, @cur, 1)
            @cur += 1
          end
          i += 1
          if @cur != pos
            redo
          end
          pos = nil
        end
        if pos
          @cur = pos
          @cur_loc = p_loc
          answer.thunks[n..-1] = []
        end
        if i < 1
          @cur = p0
          @cur_loc = p0_loc
          answer.thunks[n0..-1] = []
          throw(0)
        end
      end
      @level -= 1
      debug { warn "#{ "  " * @level}MATCH   spaces #{answer.pos} #{@buffer[answer.pos...@cur].inspect}" }
      return answer
    end
    @level -= 1
    debug { warn "#{ "  " * @level}NOMATCH spaces #{answer.pos} #{@buffer[answer.pos...@cur].inspect}" }
    return nil
  end

  def evaluate_rule_opt_spaces_or_comments
    answer = ThunkChunk.new
    answer.pos = @cur
    answer.pos_loc = @cur_loc
    debug { warn "#{ "  " * @level}EVAL    opt_spaces_or_comments #{answer.pos} #{@buffer[answer.pos..-1].inspect}" }
    @level += 1
    answer.resize_captures(0)
    1.times do |;p0, p0_loc, n0, i, pos, p_loc, n, stat|
      i = 0
      catch(1) do
        pos = @cur
        p_loc = @cur_loc
        n = answer.thunks.length
        catch(2) do |; pos, p_loc, n|
          pos = @cur
          p_loc = @cur_loc
          n = answer.thunks.length
          if apply_rule(:evaluate_rule_comment, answer.thunks, nil, 0)
            throw(2)
          end
          @cur = pos
          @cur_loc = p_loc
          answer.thunks[n..-1] = []
          if apply_rule(:evaluate_rule_spaces, answer.thunks, nil, 0)
            throw(2)
          end
          @cur = pos
          @cur_loc = p_loc
          answer.thunks[n..-1] = []
          throw(1)
        end
        i += 1
        if @cur != pos
          redo
        end
        pos = nil
      end
      if pos
        @cur = pos
        @cur_loc = p_loc
        answer.thunks[n..-1] = []
      end
    end
    @level -= 1
    debug { warn "#{ "  " * @level}MATCH   opt_spaces_or_comments #{answer.pos} #{@buffer[answer.pos...@cur].inspect}" }
    return answer
  end

  def evaluate_rule_lf
    answer = ThunkChunk.new
    answer.pos = @cur
    answer.pos_loc = @cur_loc
    debug { warn "#{ "  " * @level}EVAL    lf #{answer.pos} #{@buffer[answer.pos..-1].inspect}" }
    @level += 1
    answer.resize_captures(0)
    catch(0) do
      1.times do |;pos, p_loc, n|
        pos = @cur
        p_loc = @cur_loc
        n = answer.thunks.length
        catch(2) do
          catch(1) do
            if (
              refill_buffer(1) < 1 ||
              @buffer[@cur] != "\r"
            )
              throw(1)
            end
            @cur_loc = @cur_loc.forward(@buffer, @cur, 1)
            @cur += 1
            throw(2)
          end
          @cur_loc = p_loc
          @cur = pos
          answer.thunks[n..-1] = []
        end
      end
      if (
        refill_buffer(1) < 1 ||
        @buffer[@cur] != "\n"
      )
        throw(0)
      end
      @cur_loc = @cur_loc.forward(@buffer, @cur, 1)
      @cur += 1
      @level -= 1
      debug { warn "#{ "  " * @level}MATCH   lf #{answer.pos} #{@buffer[answer.pos...@cur].inspect}" }
      return answer
    end
    @level -= 1
    debug { warn "#{ "  " * @level}NOMATCH lf #{answer.pos} #{@buffer[answer.pos...@cur].inspect}" }
    return nil
  end

  def evaluate_rule_footer
    answer = ThunkChunk.new
    answer.pos = @cur
    answer.pos_loc = @cur_loc
    debug { warn "#{ "  " * @level}EVAL    footer #{answer.pos} #{@buffer[answer.pos..-1].inspect}" }
    @level += 1
    answer.resize_captures(1)
    catch(0) do
      if (
        refill_buffer(2) < 2 ||
        @buffer[@cur, 2] != "%%"
      )
        throw(0)
      end
      @cur_loc = @cur_loc.forward(@buffer, @cur, 2)
      @cur += 2
      catch(1) do |; pos, p_loc, n|
        pos = @cur
        p_loc = @cur_loc
        n = answer.thunks.length
        if apply_rule(:evaluate_rule_lf, answer.thunks, nil, 0)
          throw(1)
        end
        @cur = pos
        @cur_loc = p_loc
        answer.thunks[n..-1] = []
        if apply_rule(:evaluate_rule_EOF, answer.thunks, nil, 0)
          throw(1)
        end
        @cur = pos
        @cur_loc = p_loc
        answer.thunks[n..-1] = []
        throw(0)
      end
      1.times do |;pos, q, capt, p_loc, q_loc|
        pos = @cur
        p_loc = @cur_loc
        1.times do |;p0, p0_loc, n0, i, pos, p_loc, n, stat|
          i = 0
          catch(2) do
            pos = @cur
            p_loc = @cur_loc
            n = answer.thunks.length
            1.times do |;u, n|
              if refill_buffer(1) < 1
                throw(2)
              end
              u = @buffer[@cur]
              @cur_loc = @cur_loc.forward(@buffer, @cur, 1)
              @cur += 1
            end
            i += 1
            if @cur != pos
              redo
            end
            pos = nil
          end
          if pos
            @cur = pos
            @cur_loc = p_loc
            answer.thunks[n..-1] = []
          end
        end
        q = @cur
        capt = answer.capts[0]
        capt.range_start = pos
        capt.range_end = q
        q_loc = @cur_loc
        capt.start_loc = p_loc
        capt.end_loc = q_loc
      end
      answer.thunks.push(
        ThunkLeaf.new(
          :action_footer_0,
          Capture.new(
            answer.pos, @cur,
            answer.pos_loc, @cur_loc,
          ),
          {},
          answer.capts.slice(0),
        )
      )
      @level -= 1
      debug { warn "#{ "  " * @level}MATCH   footer #{answer.pos} #{@buffer[answer.pos...@cur].inspect}" }
      return answer
    end
    @level -= 1
    debug { warn "#{ "  " * @level}NOMATCH footer #{answer.pos} #{@buffer[answer.pos...@cur].inspect}" }
    return nil
  end

  def evaluate_rule_EOF
    answer = ThunkChunk.new
    answer.pos = @cur
    answer.pos_loc = @cur_loc
    debug { warn "#{ "  " * @level}EVAL    EOF #{answer.pos} #{@buffer[answer.pos..-1].inspect}" }
    @level += 1
    answer.resize_captures(0)
    catch(0) do
      if refill_buffer(1) >= 1
        throw(0)
      end
      @level -= 1
      debug { warn "#{ "  " * @level}MATCH   EOF #{answer.pos} #{@buffer[answer.pos...@cur].inspect}" }
      return answer
    end
    @level -= 1
    debug { warn "#{ "  " * @level}NOMATCH EOF #{answer.pos} #{@buffer[answer.pos...@cur].inspect}" }
    return nil
  end


  def rule_answer(rule, thunks, values, index)
    pos = @pos + @cur
    p_loc = @pos_loc + @cur_loc
    memo = @lrtable.memos[pos, rule]
    head = @lrtable.heads[pos]

    if head
      if !memo && rule != head.rule_name && !head.involved_set[rule]
        return nil
      end
      if head.eval_set.delete(rule)
        return public_send(rule)
      end
    end

    if memo
      @cur = memo.pos - @pos
      @cur_loc = memo.pos_loc - @pos_loc
      if !memo.lr
        return memo.answer
      end
      memo.lr.head ||= LrHead.new(rule)
      @lrstack.reverse_each do |lrentry|
        memo_head = memo.lr.head
        if lrentry.head == memo_head
          break
        end
        lrentry.head = memo_head
        memo_head.involved_set[lrentry.rule] = true
      end
      return memo.lr.seed
    end

    lr = LrEntry.new
    lr.rule = rule
    @lrstack.push(lr)
    memo = LrMemo.new(lr, pos, p_loc)
    @lrtable.memos[pos, rule] = memo
    answer = public_send(rule)
    @lrstack.pop
    memo.pos = @pos + @cur
    memo.pos_loc = @pos_loc + @cur_loc
    if !lr.head
      memo.answer = answer
      return answer
    end

    lr.seed = answer
    head = lr.head
    if head.rule_name != rule
      return answer
    end

    memo.answer = answer
    if !answer
      return nil
    end
    @lrtable.heads[pos] = head
    while true
      @cur = pos - @pos
      @cur_loc = p_loc - @pos_loc
      head.involved_set_to_eval_set
      answer = public_send(rule)
      if !answer || @pos + @cur <= memo.pos
        break
      end
      memo.answer = answer
      memo.pos = @pos + @cur
      memo.pos_loc = @pos_loc + @cur_loc
    end
    @lrtable.heads[pos] = nil
    @cur = memo.pos - @pos
    @cur_loc = memo.pos_loc - @pos_loc
    memo.answer
  end

  def apply_rule(rule, thunks, values, index)
    answer = rule_answer(rule, thunks, values, index)
    if !answer
      return false
    end
    values ||= @global_values
    thunks << ThunkNode.new(answer.thunks, values, index)
    return true
  end

  def do_action(thunks, values, index)
    thunks.each do |thunk|
      thunk.do_action(self, values, index)
    end
  end

  class Location
    attr_reader :charnum, :linenum

    def initialize(charnum = 0, linenum = 0)
      @charnum = charnum
      @linenum = linenum
    end

    def +(other)
      if other.linenum == 0
        Location.new(@charnum + other.charnum, @linenum + other.linenum)
      else
        Location.new(           other.charnum, @linenum + other.linenum)
      end
    end

    def -(other)
      if other.linenum == self.linenum
        Location.new(@charnum - other.charnum, @linenum - other.linenum)
      elsif other.charnum == 0
        Location.new(@charnum - other.charnum, @linenum - other.linenum)
      else
        raise "unexpected location #{self.inspect} - #{other.inspect}"
      end
    end

    def forward(buffer, cur, n)
      Location.new(@charnum, @linenum).forward!(buffer, cur, n)
    end

    def forward!(buffer, cur, n)
      buffer[cur, n].scan(/(.*)(\n)?/) do
        if Regexp.last_match[2]
          @linenum += 1
          @charnum = 0
        else
          @charnum += Regexp.last_match[1].length
        end
      end
      self
    end
  end

  class LrTable
    attr_reader :heads, :memos

    def initialize
      @heads = {}
      @memos = LrMemoTable.new
    end

    def clear
      @heads.clear
      @memos.clear
    end
  end

  class LrMemoTable
    def initialize
      @memos = {}
    end

    def clear
      @memos.clear
    end

    def []=(index, rule_name, memo)
      entry = @memos[index] ||= {}
      entry[rule_name] = memo
    end

    def [](index, rule_name)
      @memos.dig(index, rule_name)
    end
  end

  class LrHead
    attr_accessor :rule_name, :involved_set, :eval_set

    def initialize(rule_name)
      @rule_name = rule_name
      @involved_set = {}
      @eval_set = {}
    end

    def involved_set_to_eval_set
      @eval_set.clear
      @involved_set.each do |k, v|
        @eval_set[k] = true
      end
    end
  end

  class ThunkChunk
    attr_accessor :thunks, :capts, :pos, :values
    attr_accessor :pos_loc

    def initialize
      super
      @thunks = []
      @capts = {}
      @pos = 0
      @values = {}
    end

    def resize_captures(len)
      len.times do |i|
        @capts[i] = Capture.new
      end
    end
  end

  class Thunk
  end

  class ThunkLeaf < Thunk
    attr_accessor :capt0, :capts, :value_refs, :action

    def initialize(action, capt0 = Capture.new, value_refs = {}, capts = {})
      @value_refs = value_refs
      @capts = capts
      @capt0 = capt0
      @action = action
    end

    def do_action(ctx, values, index)
      ctx.public_send(action, self, values, index)
    end
  end

  class ThunkNode < Thunk
    attr_accessor :thunks, :values, :index

    def initialize(thunks, values, index)
      @thunks = thunks
      @values = values
      @index = index
      values[index] ||= Value.new if values
    end

    def do_action(ctx, _values, _index)
      @thunks.each do |thunk|
        thunk.do_action(ctx, @values, @index)
      end
    end

    def clear
      @thunks.clear
    end
  end

  class LrEntry
    attr_accessor :rule, :head, :seed
  end

  class Capture
    attr_accessor :range_start, :range_end
    attr_accessor :start_loc, :end_loc

    def initialize(range_start = 0, range_end = 0, start_loc = nil, end_loc = nil)
      @range_start = range_start
      @range_end = range_end
      @start_loc = start_loc || Location.new
      @end_loc = end_loc || Location.new
    end

    def capture_string(buffer)
      @string ||= buffer[@range_start, @range_end - @range_start]
    end
  end

  class LrMemo
    attr_accessor :lr, :answer, :pos
    attr_accessor :pos_loc

    def initialize(lr, pos, pos_loc)
      @pos = pos
      @pos_loc = pos_loc
      @lr = lr
    end

    def answer=(answer)
      @lr = nil
      @answer = answer
    end
  end

  class Value
    attr_accessor :value
  end
end

class Packcr::Parser
  def getc
    @ifile.getc
  end
end
