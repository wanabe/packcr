# A packrat parser generated by PackCR 0.0.8

class Packcr
  class Parser
    class Location
      attr_reader :charnum, :linenum

      def initialize(charnum = 0, linenum = 0)
        @charnum = charnum
        @linenum = linenum
      end

      def +(other)
        if other.linenum.zero?
          Location.new(@charnum + other.charnum, @linenum + other.linenum)
        else
          Location.new(           other.charnum, @linenum + other.linenum)
        end
      end

      def -(other)
        raise "unexpected location #{inspect} - #{other.inspect}" unless other.linenum == linenum || other.charnum.zero?

        Location.new(@charnum - other.charnum, @linenum - other.linenum)
      end

      def forward(buffer, cur, n)
        Location.new(@charnum, @linenum).forward!(buffer, cur, n)
      end

      def forward!(buffer, cur, n)
        buffer[cur, n].scan(/(.*)(\n)?/) do
          if Regexp.last_match[2]
            @linenum += 1
            @charnum = 0
          else
            @charnum += Regexp.last_match[1].length
          end
        end
        self
      end
    end

    def initialize(ctx = nil, ifile = nil, debug: false)
      @buffer = +""

      @buffer_start_position = 0
      @position_offset = 0
      @level = 0
      @thunk = ThunkNode.new([], nil, 0)
      @memos = LrMemoTable.new
      @debug = debug
      @global_values = {}
      @buffer_start_position_loc = Location.new
      @position_offset_loc = Location.new
      @ctx = ctx || self
      @ifile = ifile || stdin
      @utf8 = true
      @ascii = false
      @lang = :rb
    end

    def debug
      yield if @debug
    end

    def getc
      $stdin.getc
    end

    def refill_buffer(num, mode = nil)
      len = @buffer.length
      if len >= @position_offset + num
        return len - @position_offset
      end

      while len < @position_offset + num
        c = getc
        break if !c

        @buffer << c
        len = @buffer.length
      end
      len - @position_offset
    end

    def commit_buffer
      @buffer = @buffer[@position_offset, @buffer.length - @position_offset]
      @buffer_start_position += @position_offset
      @memos.clear
      @position_offset = 0
      @buffer_start_position_loc += @position_offset_loc
      @position_offset_loc = Location.new
    end

    def parse
      pos = @buffer_start_position
      raise SyntaxError, "can't parse" unless apply_rule(:evaluate_rule_statement, @thunk.thunks, nil, 0, @buffer_start_position, @buffer_start_position_loc)

      @thunk.do_action(self, nil, 0)

      commit_buffer
      @thunk.clear
      refill_buffer(1) >= 1 && pos != @buffer_start_position
    end

    def run
      nil while parse
    end

    def action_statement_0(__packcr_in, __packcr_vars, __packcr_index)
      ____ = (__packcr_vars[__packcr_index] ||= Value.new).value if __packcr_vars
      __0 = __packcr_in.capt0.capture_string(@buffer)
      __0s = @buffer_start_position + __packcr_in.capt0.range_start
      __0e = @buffer_start_position + __packcr_in.capt0.range_end
      __0sl = @buffer_start_position_loc + __packcr_in.capt0.start_loc
      __0el = @buffer_start_position_loc + __packcr_in.capt0.end_loc
      @ctx.error __0sl.linenum + 1, __0sl.charnum + 1, "Illegal syntax"

      __packcr_vars[__packcr_index].value = ____ if __packcr_vars
    end

    def action_supported_language_0(__packcr_in, __packcr_vars, __packcr_index)
      ____ = (__packcr_vars[__packcr_index] ||= Value.new).value if __packcr_vars
      __0 = __packcr_in.capt0.capture_string(@buffer)
      __0s = @buffer_start_position + __packcr_in.capt0.range_start
      __0e = @buffer_start_position + __packcr_in.capt0.range_end
      __0sl = @buffer_start_position_loc + __packcr_in.capt0.start_loc
      __0el = @buffer_start_position_loc + __packcr_in.capt0.end_loc
      @ctx.error __0sl.linenum + 1, __0sl.charnum + 1, "Not supported language: #{__0}"

      __packcr_vars[__packcr_index].value = ____ if __packcr_vars
    end

    def action_directive_include_0(__packcr_in, __packcr_vars, __packcr_index)
      ____ = (__packcr_vars[__packcr_index] ||= Value.new).value if __packcr_vars
      blocks = (__packcr_in.value_refs[0] ||= Value.new).value
      __0 = __packcr_in.capt0.capture_string(@buffer)
      __0s = @buffer_start_position + __packcr_in.capt0.range_start
      __0e = @buffer_start_position + __packcr_in.capt0.range_end
      __0sl = @buffer_start_position_loc + __packcr_in.capt0.start_loc
      __0el = @buffer_start_position_loc + __packcr_in.capt0.end_loc
      blocks.each { |b| @ctx.code(:esource) << Packcr::CodeBlock.new(b, __0sl.linenum, __0sl.charnum) }

      __packcr_vars[__packcr_index].value = ____ if __packcr_vars
    end

    def action_directive_include_1(__packcr_in, __packcr_vars, __packcr_index)
      ____ = (__packcr_vars[__packcr_index] ||= Value.new).value if __packcr_vars
      blocks = (__packcr_in.value_refs[0] ||= Value.new).value
      __0 = __packcr_in.capt0.capture_string(@buffer)
      __0s = @buffer_start_position + __packcr_in.capt0.range_start
      __0e = @buffer_start_position + __packcr_in.capt0.range_end
      __0sl = @buffer_start_position_loc + __packcr_in.capt0.start_loc
      __0el = @buffer_start_position_loc + __packcr_in.capt0.end_loc
      blocks.each { |b| @ctx.code(:source) << Packcr::CodeBlock.new(b, __0sl.linenum, __0sl.charnum) }

      __packcr_vars[__packcr_index].value = ____ if __packcr_vars
    end

    def action_directive_include_2(__packcr_in, __packcr_vars, __packcr_index)
      ____ = (__packcr_vars[__packcr_index] ||= Value.new).value if __packcr_vars
      blocks = (__packcr_in.value_refs[0] ||= Value.new).value
      __0 = __packcr_in.capt0.capture_string(@buffer)
      __0s = @buffer_start_position + __packcr_in.capt0.range_start
      __0e = @buffer_start_position + __packcr_in.capt0.range_end
      __0sl = @buffer_start_position_loc + __packcr_in.capt0.start_loc
      __0el = @buffer_start_position_loc + __packcr_in.capt0.end_loc
      blocks.each { |b| @ctx.code(:lheader) << Packcr::CodeBlock.new(b, __0sl.linenum, __0sl.charnum) }

      __packcr_vars[__packcr_index].value = ____ if __packcr_vars
    end

    def action_directive_include_3(__packcr_in, __packcr_vars, __packcr_index)
      ____ = (__packcr_vars[__packcr_index] ||= Value.new).value if __packcr_vars
      blocks = (__packcr_in.value_refs[0] ||= Value.new).value
      __0 = __packcr_in.capt0.capture_string(@buffer)
      __0s = @buffer_start_position + __packcr_in.capt0.range_start
      __0e = @buffer_start_position + __packcr_in.capt0.range_end
      __0sl = @buffer_start_position_loc + __packcr_in.capt0.start_loc
      __0el = @buffer_start_position_loc + __packcr_in.capt0.end_loc
      blocks.each { |b| @ctx.code(:lsource) << Packcr::CodeBlock.new(b, __0sl.linenum, __0sl.charnum) }

      __packcr_vars[__packcr_index].value = ____ if __packcr_vars
    end

    def action_directive_include_4(__packcr_in, __packcr_vars, __packcr_index)
      ____ = (__packcr_vars[__packcr_index] ||= Value.new).value if __packcr_vars
      blocks = (__packcr_in.value_refs[0] ||= Value.new).value
      __0 = __packcr_in.capt0.capture_string(@buffer)
      __0s = @buffer_start_position + __packcr_in.capt0.range_start
      __0e = @buffer_start_position + __packcr_in.capt0.range_end
      __0sl = @buffer_start_position_loc + __packcr_in.capt0.start_loc
      __0el = @buffer_start_position_loc + __packcr_in.capt0.end_loc
      blocks.each { |b| @ctx.code(:header) << Packcr::CodeBlock.new(b, __0sl.linenum, __0sl.charnum) }

      __packcr_vars[__packcr_index].value = ____ if __packcr_vars
    end

    def action_directive_include_5(__packcr_in, __packcr_vars, __packcr_index)
      ____ = (__packcr_vars[__packcr_index] ||= Value.new).value if __packcr_vars
      blocks = (__packcr_in.value_refs[0] ||= Value.new).value
      __0 = __packcr_in.capt0.capture_string(@buffer)
      __0s = @buffer_start_position + __packcr_in.capt0.range_start
      __0e = @buffer_start_position + __packcr_in.capt0.range_end
      __0sl = @buffer_start_position_loc + __packcr_in.capt0.start_loc
      __0el = @buffer_start_position_loc + __packcr_in.capt0.end_loc
      blocks.each { |b| @ctx.code(:location) << Packcr::CodeBlock.new(b, __0sl.linenum, __0sl.charnum) }

      __packcr_vars[__packcr_index].value = ____ if __packcr_vars
    end

    def action_directive_include_6(__packcr_in, __packcr_vars, __packcr_index)
      ____ = (__packcr_vars[__packcr_index] ||= Value.new).value if __packcr_vars
      blocks = (__packcr_in.value_refs[0] ||= Value.new).value
      __0 = __packcr_in.capt0.capture_string(@buffer)
      __0s = @buffer_start_position + __packcr_in.capt0.range_start
      __0e = @buffer_start_position + __packcr_in.capt0.range_end
      __0sl = @buffer_start_position_loc + __packcr_in.capt0.start_loc
      __0el = @buffer_start_position_loc + __packcr_in.capt0.end_loc
      blocks.each { |b| @ctx.code(:init) << Packcr::CodeBlock.new(b, __0sl.linenum, __0sl.charnum) }

      __packcr_vars[__packcr_index].value = ____ if __packcr_vars
    end

    def action_directive_include_7(__packcr_in, __packcr_vars, __packcr_index)
      ____ = (__packcr_vars[__packcr_index] ||= Value.new).value if __packcr_vars
      blocks = (__packcr_in.value_refs[0] ||= Value.new).value
      __0 = __packcr_in.capt0.capture_string(@buffer)
      __0s = @buffer_start_position + __packcr_in.capt0.range_start
      __0e = @buffer_start_position + __packcr_in.capt0.range_end
      __0sl = @buffer_start_position_loc + __packcr_in.capt0.start_loc
      __0el = @buffer_start_position_loc + __packcr_in.capt0.end_loc
      blocks.each { |b| Packcr::BroadCast.new(@ctx.code(:eheader), @ctx.code(:esource)) << Packcr::CodeBlock.new(b, __0sl.linenum, __0sl.charnum) }

      __packcr_vars[__packcr_index].value = ____ if __packcr_vars
    end

    def action_directive_include_8(__packcr_in, __packcr_vars, __packcr_index)
      ____ = (__packcr_vars[__packcr_index] ||= Value.new).value if __packcr_vars
      blocks = (__packcr_in.value_refs[0] ||= Value.new).value
      __0 = __packcr_in.capt0.capture_string(@buffer)
      __0s = @buffer_start_position + __packcr_in.capt0.range_start
      __0e = @buffer_start_position + __packcr_in.capt0.range_end
      __0sl = @buffer_start_position_loc + __packcr_in.capt0.start_loc
      __0el = @buffer_start_position_loc + __packcr_in.capt0.end_loc
      blocks.each { |b| Packcr::BroadCast.new(@ctx.code(:header), @ctx.code(:source)) << Packcr::CodeBlock.new(b, __0sl.linenum, __0sl.charnum) }

      __packcr_vars[__packcr_index].value = ____ if __packcr_vars
    end

    def action_directive_include_9(__packcr_in, __packcr_vars, __packcr_index)
      ____ = (__packcr_vars[__packcr_index] ||= Value.new).value if __packcr_vars
      blocks = (__packcr_in.value_refs[0] ||= Value.new).value
      __0 = __packcr_in.capt0.capture_string(@buffer)
      __0s = @buffer_start_position + __packcr_in.capt0.range_start
      __0e = @buffer_start_position + __packcr_in.capt0.range_end
      __0sl = @buffer_start_position_loc + __packcr_in.capt0.start_loc
      __0el = @buffer_start_position_loc + __packcr_in.capt0.end_loc
      __1 = __packcr_in.capts[0].capture_string(@buffer)
      __1s = @buffer_start_position + __packcr_in.capts[0].range_start
      __1e = @buffer_start_position + __packcr_in.capts[0].range_end
      __1sl = @buffer_start_position_loc + __packcr_in.capts[0].start_loc
      __1el = @buffer_start_position_loc + __packcr_in.capts[0].end_loc
      blocks.each { @ctx.error __0sl.linenum + 1, __0sl.charnum + 1, "Invalid directive: #{__1}" }

      __packcr_vars[__packcr_index].value = ____ if __packcr_vars
    end

    def action_code_blocks_0(__packcr_in, __packcr_vars, __packcr_index)
      ____ = (__packcr_vars[__packcr_index] ||= Value.new).value if __packcr_vars
      blocks = (__packcr_in.value_refs[0] ||= Value.new).value
      block = (__packcr_in.value_refs[1] ||= Value.new).value
      __0 = __packcr_in.capt0.capture_string(@buffer)
      __0s = @buffer_start_position + __packcr_in.capt0.range_start
      __0e = @buffer_start_position + __packcr_in.capt0.range_end
      __0sl = @buffer_start_position_loc + __packcr_in.capt0.start_loc
      __0el = @buffer_start_position_loc + __packcr_in.capt0.end_loc
      blocks.push(block) if block; ____ = blocks

      __packcr_vars[__packcr_index].value = ____ if __packcr_vars
    end

    def action_code_blocks_1(__packcr_in, __packcr_vars, __packcr_index)
      ____ = (__packcr_vars[__packcr_index] ||= Value.new).value if __packcr_vars
      block = (__packcr_in.value_refs[1] ||= Value.new).value
      __0 = __packcr_in.capt0.capture_string(@buffer)
      __0s = @buffer_start_position + __packcr_in.capt0.range_start
      __0e = @buffer_start_position + __packcr_in.capt0.range_end
      __0sl = @buffer_start_position_loc + __packcr_in.capt0.start_loc
      __0el = @buffer_start_position_loc + __packcr_in.capt0.end_loc
      ____ = block ? [block] : []

      __packcr_vars[__packcr_index].value = ____ if __packcr_vars
    end

    def action_directive_string_0(__packcr_in, __packcr_vars, __packcr_index)
      ____ = (__packcr_vars[__packcr_index] ||= Value.new).value if __packcr_vars
      strings = (__packcr_in.value_refs[0]  ||= Value.new).value
      __0 = __packcr_in.capt0.capture_string(@buffer)
      __0s = @buffer_start_position + __packcr_in.capt0.range_start
      __0e = @buffer_start_position + __packcr_in.capt0.range_end
      __0sl = @buffer_start_position_loc + __packcr_in.capt0.start_loc
      __0el = @buffer_start_position_loc + __packcr_in.capt0.end_loc
      strings.each { |str| @ctx.value_type = str }

      __packcr_vars[__packcr_index].value = ____ if __packcr_vars
    end

    def action_directive_string_1(__packcr_in, __packcr_vars, __packcr_index)
      ____ = (__packcr_vars[__packcr_index] ||= Value.new).value if __packcr_vars
      strings = (__packcr_in.value_refs[0]  ||= Value.new).value
      __0 = __packcr_in.capt0.capture_string(@buffer)
      __0s = @buffer_start_position + __packcr_in.capt0.range_start
      __0e = @buffer_start_position + __packcr_in.capt0.range_end
      __0sl = @buffer_start_position_loc + __packcr_in.capt0.start_loc
      __0el = @buffer_start_position_loc + __packcr_in.capt0.end_loc
      strings.each { |str| @ctx.auxil_type = str }

      __packcr_vars[__packcr_index].value = ____ if __packcr_vars
    end

    def action_directive_string_2(__packcr_in, __packcr_vars, __packcr_index)
      ____ = (__packcr_vars[__packcr_index] ||= Value.new).value if __packcr_vars
      strings = (__packcr_in.value_refs[0]  ||= Value.new).value
      __0 = __packcr_in.capt0.capture_string(@buffer)
      __0s = @buffer_start_position + __packcr_in.capt0.range_start
      __0e = @buffer_start_position + __packcr_in.capt0.range_end
      __0sl = @buffer_start_position_loc + __packcr_in.capt0.start_loc
      __0el = @buffer_start_position_loc + __packcr_in.capt0.end_loc
      strings.each { |str| @ctx.prefix = str }

      __packcr_vars[__packcr_index].value = ____ if __packcr_vars
    end

    def action_directive_string_3(__packcr_in, __packcr_vars, __packcr_index)
      ____ = (__packcr_vars[__packcr_index] ||= Value.new).value if __packcr_vars
      str = (__packcr_in.value_refs[1] ||= Value.new).value
      __0 = __packcr_in.capt0.capture_string(@buffer)
      __0s = @buffer_start_position + __packcr_in.capt0.range_start
      __0e = @buffer_start_position + __packcr_in.capt0.range_end
      __0sl = @buffer_start_position_loc + __packcr_in.capt0.start_loc
      __0el = @buffer_start_position_loc + __packcr_in.capt0.end_loc
      __1 = __packcr_in.capts[0].capture_string(@buffer)
      __1s = @buffer_start_position + __packcr_in.capts[0].range_start
      __1e = @buffer_start_position + __packcr_in.capts[0].range_end
      __1sl = @buffer_start_position_loc + __packcr_in.capts[0].start_loc
      __1el = @buffer_start_position_loc + __packcr_in.capts[0].end_loc
      @ctx.error __0sl.linenum + 1, __0sl.charnum + 1, "Invalid directive: #{__1}"

      __packcr_vars[__packcr_index].value = ____ if __packcr_vars
    end

    def action_directive_value_0(__packcr_in, __packcr_vars, __packcr_index)
      ____ = (__packcr_vars[__packcr_index] ||= Value.new).value if __packcr_vars
      __0 = __packcr_in.capt0.capture_string(@buffer)
      __0s = @buffer_start_position + __packcr_in.capt0.range_start
      __0e = @buffer_start_position + __packcr_in.capt0.range_end
      __0sl = @buffer_start_position_loc + __packcr_in.capt0.start_loc
      __0el = @buffer_start_position_loc + __packcr_in.capt0.end_loc
      @ctx.capture_in_code = true

      __packcr_vars[__packcr_index].value = ____ if __packcr_vars
    end

    def action_lang_strings_0(__packcr_in, __packcr_vars, __packcr_index)
      ____ = (__packcr_vars[__packcr_index] ||= Value.new).value if __packcr_vars
      strings = (__packcr_in.value_refs[0]  ||= Value.new).value
      string = (__packcr_in.value_refs[1] ||= Value.new).value
      __0 = __packcr_in.capt0.capture_string(@buffer)
      __0s = @buffer_start_position + __packcr_in.capt0.range_start
      __0e = @buffer_start_position + __packcr_in.capt0.range_end
      __0sl = @buffer_start_position_loc + __packcr_in.capt0.start_loc
      __0el = @buffer_start_position_loc + __packcr_in.capt0.end_loc
      strings.push(string) if string; ____ = strings

      __packcr_vars[__packcr_index].value = ____ if __packcr_vars
    end

    def action_lang_strings_1(__packcr_in, __packcr_vars, __packcr_index)
      ____ = (__packcr_vars[__packcr_index] ||= Value.new).value if __packcr_vars
      string = (__packcr_in.value_refs[1] ||= Value.new).value
      __0 = __packcr_in.capt0.capture_string(@buffer)
      __0s = @buffer_start_position + __packcr_in.capt0.range_start
      __0e = @buffer_start_position + __packcr_in.capt0.range_end
      __0sl = @buffer_start_position_loc + __packcr_in.capt0.start_loc
      __0el = @buffer_start_position_loc + __packcr_in.capt0.end_loc
      ____ = string ? [string] : []

      __packcr_vars[__packcr_index].value = ____ if __packcr_vars
    end

    def action_lang_string_0(__packcr_in, __packcr_vars, __packcr_index)
      ____ = (__packcr_vars[__packcr_index] ||= Value.new).value if __packcr_vars
      string = (__packcr_in.value_refs[0] ||= Value.new).value
      __0 = __packcr_in.capt0.capture_string(@buffer)
      __0s = @buffer_start_position + __packcr_in.capt0.range_start
      __0e = @buffer_start_position + __packcr_in.capt0.range_end
      __0sl = @buffer_start_position_loc + __packcr_in.capt0.start_loc
      __0el = @buffer_start_position_loc + __packcr_in.capt0.end_loc
      ____ = string

      __packcr_vars[__packcr_index].value = ____ if __packcr_vars
    end

    def action_lang_string_1(__packcr_in, __packcr_vars, __packcr_index)
      ____ = (__packcr_vars[__packcr_index] ||= Value.new).value if __packcr_vars
      string = (__packcr_in.value_refs[0] ||= Value.new).value
      __0 = __packcr_in.capt0.capture_string(@buffer)
      __0s = @buffer_start_position + __packcr_in.capt0.range_start
      __0e = @buffer_start_position + __packcr_in.capt0.range_end
      __0sl = @buffer_start_position_loc + __packcr_in.capt0.start_loc
      __0el = @buffer_start_position_loc + __packcr_in.capt0.end_loc
      __1 = __packcr_in.capts[0].capture_string(@buffer)
      __1s = @buffer_start_position + __packcr_in.capts[0].range_start
      __1e = @buffer_start_position + __packcr_in.capts[0].range_end
      __1sl = @buffer_start_position_loc + __packcr_in.capts[0].start_loc
      __1el = @buffer_start_position_loc + __packcr_in.capts[0].end_loc
      ____ = @ctx.lang == __1.to_sym ? string : nil

      __packcr_vars[__packcr_index].value = ____ if __packcr_vars
    end

    def action_rule_0(__packcr_in, __packcr_vars, __packcr_index)
      ____ = (__packcr_vars[__packcr_index] ||= Value.new).value if __packcr_vars
      name = (__packcr_in.value_refs[0]  ||= Value.new).value
      expr = (__packcr_in.value_refs[1]  ||= Value.new).value
      __0 = __packcr_in.capt0.capture_string(@buffer)
      __0s = @buffer_start_position + __packcr_in.capt0.range_start
      __0e = @buffer_start_position + __packcr_in.capt0.range_end
      __0sl = @buffer_start_position_loc + __packcr_in.capt0.start_loc
      __0el = @buffer_start_position_loc + __packcr_in.capt0.end_loc
      return unless expr

      rule = Packcr::Node::RuleNode.new(expr, name, __0sl.linenum, __0sl.charnum)
      @ctx.root.rules << rule

      __packcr_vars[__packcr_index].value = ____ if __packcr_vars
    end

    def action_expression_0(__packcr_in, __packcr_vars, __packcr_index)
      ____ = (__packcr_vars[__packcr_index] ||= Value.new).value if __packcr_vars
      expr = (__packcr_in.value_refs[0] ||= Value.new).value
      seq = (__packcr_in.value_refs[1] ||= Value.new).value
      __0 = __packcr_in.capt0.capture_string(@buffer)
      __0s = @buffer_start_position + __packcr_in.capt0.range_start
      __0e = @buffer_start_position + __packcr_in.capt0.range_end
      __0sl = @buffer_start_position_loc + __packcr_in.capt0.start_loc
      __0el = @buffer_start_position_loc + __packcr_in.capt0.end_loc
      ____ = expr.alt(seq)

      __packcr_vars[__packcr_index].value = ____ if __packcr_vars
    end

    def action_expression_1(__packcr_in, __packcr_vars, __packcr_index)
      ____ = (__packcr_vars[__packcr_index] ||= Value.new).value if __packcr_vars
      seq = (__packcr_in.value_refs[1] ||= Value.new).value
      __0 = __packcr_in.capt0.capture_string(@buffer)
      __0s = @buffer_start_position + __packcr_in.capt0.range_start
      __0e = @buffer_start_position + __packcr_in.capt0.range_end
      __0sl = @buffer_start_position_loc + __packcr_in.capt0.start_loc
      __0el = @buffer_start_position_loc + __packcr_in.capt0.end_loc
      ____ = seq

      __packcr_vars[__packcr_index].value = ____ if __packcr_vars
    end

    def action_sequence_0(__packcr_in, __packcr_vars, __packcr_index)
      ____ = (__packcr_vars[__packcr_index] ||= Value.new).value if __packcr_vars
      seq = (__packcr_in.value_refs[0] ||= Value.new).value
      expr = (__packcr_in.value_refs[1] ||= Value.new).value
      __0 = __packcr_in.capt0.capture_string(@buffer)
      __0s = @buffer_start_position + __packcr_in.capt0.range_start
      __0e = @buffer_start_position + __packcr_in.capt0.range_end
      __0sl = @buffer_start_position_loc + __packcr_in.capt0.start_loc
      __0el = @buffer_start_position_loc + __packcr_in.capt0.end_loc
      ____ = seq.seq(expr, cut: true)

      __packcr_vars[__packcr_index].value = ____ if __packcr_vars
    end

    def action_sequence_1(__packcr_in, __packcr_vars, __packcr_index)
      ____ = (__packcr_vars[__packcr_index] ||= Value.new).value if __packcr_vars
      seq = (__packcr_in.value_refs[0] ||= Value.new).value
      code = (__packcr_in.value_refs[2] ||= Value.new).value
      __0 = __packcr_in.capt0.capture_string(@buffer)
      __0s = @buffer_start_position + __packcr_in.capt0.range_start
      __0e = @buffer_start_position + __packcr_in.capt0.range_end
      __0sl = @buffer_start_position_loc + __packcr_in.capt0.start_loc
      __0el = @buffer_start_position_loc + __packcr_in.capt0.end_loc
      ____ = code ? Packcr::Node::ErrorNode.new(seq, Packcr::CodeBlock.new(code, __0sl.linenum, __0sl.charnum)) : seq

      __packcr_vars[__packcr_index].value = ____ if __packcr_vars
    end

    def action_sequence_2(__packcr_in, __packcr_vars, __packcr_index)
      ____ = (__packcr_vars[__packcr_index] ||= Value.new).value if __packcr_vars
      seq = (__packcr_in.value_refs[0] ||= Value.new).value
      expr = (__packcr_in.value_refs[1] ||= Value.new).value
      __0 = __packcr_in.capt0.capture_string(@buffer)
      __0s = @buffer_start_position + __packcr_in.capt0.range_start
      __0e = @buffer_start_position + __packcr_in.capt0.range_end
      __0sl = @buffer_start_position_loc + __packcr_in.capt0.start_loc
      __0el = @buffer_start_position_loc + __packcr_in.capt0.end_loc
      ____ = seq&.seq(expr) || expr

      __packcr_vars[__packcr_index].value = ____ if __packcr_vars
    end

    def action_sequence_3(__packcr_in, __packcr_vars, __packcr_index)
      ____ = (__packcr_vars[__packcr_index] ||= Value.new).value if __packcr_vars
      expr = (__packcr_in.value_refs[1] ||= Value.new).value
      __0 = __packcr_in.capt0.capture_string(@buffer)
      __0s = @buffer_start_position + __packcr_in.capt0.range_start
      __0e = @buffer_start_position + __packcr_in.capt0.range_end
      __0sl = @buffer_start_position_loc + __packcr_in.capt0.start_loc
      __0el = @buffer_start_position_loc + __packcr_in.capt0.end_loc
      ____ = expr

      __packcr_vars[__packcr_index].value = ____ if __packcr_vars
    end

    def action_term_0(__packcr_in, __packcr_vars, __packcr_index)
      ____ = (__packcr_vars[__packcr_index] ||= Value.new).value if __packcr_vars
      node = (__packcr_in.value_refs[0] ||= Value.new).value
      __0 = __packcr_in.capt0.capture_string(@buffer)
      __0s = @buffer_start_position + __packcr_in.capt0.range_start
      __0e = @buffer_start_position + __packcr_in.capt0.range_end
      __0sl = @buffer_start_position_loc + __packcr_in.capt0.start_loc
      __0el = @buffer_start_position_loc + __packcr_in.capt0.end_loc
      ____ = Packcr::Node::PredicateNode.new(node)

      __packcr_vars[__packcr_index].value = ____ if __packcr_vars
    end

    def action_term_1(__packcr_in, __packcr_vars, __packcr_index)
      ____ = (__packcr_vars[__packcr_index] ||= Value.new).value if __packcr_vars
      node = (__packcr_in.value_refs[0] ||= Value.new).value
      __0 = __packcr_in.capt0.capture_string(@buffer)
      __0s = @buffer_start_position + __packcr_in.capt0.range_start
      __0e = @buffer_start_position + __packcr_in.capt0.range_end
      __0sl = @buffer_start_position_loc + __packcr_in.capt0.start_loc
      __0el = @buffer_start_position_loc + __packcr_in.capt0.end_loc
      ____ = Packcr::Node::PredicateNode.new(node, true)

      __packcr_vars[__packcr_index].value = ____ if __packcr_vars
    end

    def action_term_2(__packcr_in, __packcr_vars, __packcr_index)
      ____ = (__packcr_vars[__packcr_index] ||= Value.new).value if __packcr_vars
      node = (__packcr_in.value_refs[0] ||= Value.new).value
      __0 = __packcr_in.capt0.capture_string(@buffer)
      __0s = @buffer_start_position + __packcr_in.capt0.range_start
      __0e = @buffer_start_position + __packcr_in.capt0.range_end
      __0sl = @buffer_start_position_loc + __packcr_in.capt0.start_loc
      __0el = @buffer_start_position_loc + __packcr_in.capt0.end_loc
      ____ = node

      __packcr_vars[__packcr_index].value = ____ if __packcr_vars
    end

    def action_quantity_0(__packcr_in, __packcr_vars, __packcr_index)
      ____ = (__packcr_vars[__packcr_index] ||= Value.new).value if __packcr_vars
      node = (__packcr_in.value_refs[0] ||= Value.new).value
      __0 = __packcr_in.capt0.capture_string(@buffer)
      __0s = @buffer_start_position + __packcr_in.capt0.range_start
      __0e = @buffer_start_position + __packcr_in.capt0.range_end
      __0sl = @buffer_start_position_loc + __packcr_in.capt0.start_loc
      __0el = @buffer_start_position_loc + __packcr_in.capt0.end_loc
      ____ = Packcr::Node::QuantityNode.new(node, 0, -1)

      __packcr_vars[__packcr_index].value = ____ if __packcr_vars
    end

    def action_quantity_1(__packcr_in, __packcr_vars, __packcr_index)
      ____ = (__packcr_vars[__packcr_index] ||= Value.new).value if __packcr_vars
      node = (__packcr_in.value_refs[0] ||= Value.new).value
      __0 = __packcr_in.capt0.capture_string(@buffer)
      __0s = @buffer_start_position + __packcr_in.capt0.range_start
      __0e = @buffer_start_position + __packcr_in.capt0.range_end
      __0sl = @buffer_start_position_loc + __packcr_in.capt0.start_loc
      __0el = @buffer_start_position_loc + __packcr_in.capt0.end_loc
      ____ = Packcr::Node::QuantityNode.new(node, 1, -1)

      __packcr_vars[__packcr_index].value = ____ if __packcr_vars
    end

    def action_quantity_2(__packcr_in, __packcr_vars, __packcr_index)
      ____ = (__packcr_vars[__packcr_index] ||= Value.new).value if __packcr_vars
      node = (__packcr_in.value_refs[0] ||= Value.new).value
      __0 = __packcr_in.capt0.capture_string(@buffer)
      __0s = @buffer_start_position + __packcr_in.capt0.range_start
      __0e = @buffer_start_position + __packcr_in.capt0.range_end
      __0sl = @buffer_start_position_loc + __packcr_in.capt0.start_loc
      __0el = @buffer_start_position_loc + __packcr_in.capt0.end_loc
      ____ = Packcr::Node::QuantityNode.new(node, 0, 1)

      __packcr_vars[__packcr_index].value = ____ if __packcr_vars
    end

    def action_quantity_3(__packcr_in, __packcr_vars, __packcr_index)
      ____ = (__packcr_vars[__packcr_index] ||= Value.new).value if __packcr_vars
      node = (__packcr_in.value_refs[0] ||= Value.new).value
      __0 = __packcr_in.capt0.capture_string(@buffer)
      __0s = @buffer_start_position + __packcr_in.capt0.range_start
      __0e = @buffer_start_position + __packcr_in.capt0.range_end
      __0sl = @buffer_start_position_loc + __packcr_in.capt0.start_loc
      __0el = @buffer_start_position_loc + __packcr_in.capt0.end_loc
      ____ = node

      __packcr_vars[__packcr_index].value = ____ if __packcr_vars
    end

    def action_primary_0(__packcr_in, __packcr_vars, __packcr_index)
      ____ = (__packcr_vars[__packcr_index] ||= Value.new).value if __packcr_vars
      code = (__packcr_in.value_refs[0] ||= Value.new).value
      __0 = __packcr_in.capt0.capture_string(@buffer)
      __0s = @buffer_start_position + __packcr_in.capt0.range_start
      __0e = @buffer_start_position + __packcr_in.capt0.range_end
      __0sl = @buffer_start_position_loc + __packcr_in.capt0.start_loc
      __0el = @buffer_start_position_loc + __packcr_in.capt0.end_loc
      ____ = code && Packcr::Node::ActionNode.new(Packcr::CodeBlock.new(code, __0sl.linenum, __0sl.charnum))

      __packcr_vars[__packcr_index].value = ____ if __packcr_vars
    end

    def action_primary_1(__packcr_in, __packcr_vars, __packcr_index)
      ____ = (__packcr_vars[__packcr_index] ||= Value.new).value if __packcr_vars
      var_name = (__packcr_in.value_refs[1] ||= Value.new).value
      name = (__packcr_in.value_refs[2] ||= Value.new).value
      __0 = __packcr_in.capt0.capture_string(@buffer)
      __0s = @buffer_start_position + __packcr_in.capt0.range_start
      __0e = @buffer_start_position + __packcr_in.capt0.range_end
      __0sl = @buffer_start_position_loc + __packcr_in.capt0.start_loc
      __0el = @buffer_start_position_loc + __packcr_in.capt0.end_loc
      ____ = Packcr::Node::ReferenceNode.new(name, var_name, __0sl.linenum, __0sl.charnum)

      __packcr_vars[__packcr_index].value = ____ if __packcr_vars
    end

    def action_primary_2(__packcr_in, __packcr_vars, __packcr_index)
      ____ = (__packcr_vars[__packcr_index] ||= Value.new).value if __packcr_vars
      name = (__packcr_in.value_refs[2] ||= Value.new).value
      __0 = __packcr_in.capt0.capture_string(@buffer)
      __0s = @buffer_start_position + __packcr_in.capt0.range_start
      __0e = @buffer_start_position + __packcr_in.capt0.range_end
      __0sl = @buffer_start_position_loc + __packcr_in.capt0.start_loc
      __0el = @buffer_start_position_loc + __packcr_in.capt0.end_loc
      ref = Packcr::Node::ReferenceNode.new(name, "_out", __0sl.linenum, __0sl.charnum)
      code = @ctx.pass_value_code("_out")
      act = Packcr::Node::ActionNode.new(Packcr::CodeBlock.new(code, __0sl.linenum, __0sl.charnum))
      ____ = ref.seq(act)

      __packcr_vars[__packcr_index].value = ____ if __packcr_vars
    end

    def action_primary_3(__packcr_in, __packcr_vars, __packcr_index)
      ____ = (__packcr_vars[__packcr_index] ||= Value.new).value if __packcr_vars
      name = (__packcr_in.value_refs[2] ||= Value.new).value
      __0 = __packcr_in.capt0.capture_string(@buffer)
      __0s = @buffer_start_position + __packcr_in.capt0.range_start
      __0e = @buffer_start_position + __packcr_in.capt0.range_end
      __0sl = @buffer_start_position_loc + __packcr_in.capt0.start_loc
      __0el = @buffer_start_position_loc + __packcr_in.capt0.end_loc
      ____ = Packcr::Node::ReferenceNode.new(name, nil, __0sl.linenum, __0sl.charnum)

      __packcr_vars[__packcr_index].value = ____ if __packcr_vars
    end

    def action_primary_4(__packcr_in, __packcr_vars, __packcr_index)
      ____ = (__packcr_vars[__packcr_index] ||= Value.new).value if __packcr_vars
      expr = (__packcr_in.value_refs[3] ||= Value.new).value
      __0 = __packcr_in.capt0.capture_string(@buffer)
      __0s = @buffer_start_position + __packcr_in.capt0.range_start
      __0e = @buffer_start_position + __packcr_in.capt0.range_end
      __0sl = @buffer_start_position_loc + __packcr_in.capt0.start_loc
      __0el = @buffer_start_position_loc + __packcr_in.capt0.end_loc
      ____ = expr

      __packcr_vars[__packcr_index].value = ____ if __packcr_vars
    end

    def action_primary_5(__packcr_in, __packcr_vars, __packcr_index)
      ____ = (__packcr_vars[__packcr_index] ||= Value.new).value if __packcr_vars
      expr = (__packcr_in.value_refs[3] ||= Value.new).value
      __0 = __packcr_in.capt0.capture_string(@buffer)
      __0s = @buffer_start_position + __packcr_in.capt0.range_start
      __0e = @buffer_start_position + __packcr_in.capt0.range_end
      __0sl = @buffer_start_position_loc + __packcr_in.capt0.start_loc
      __0el = @buffer_start_position_loc + __packcr_in.capt0.end_loc
      ____ = Packcr::Node::CaptureNode.new(expr)

      __packcr_vars[__packcr_index].value = ____ if __packcr_vars
    end

    def action_primary_6(__packcr_in, __packcr_vars, __packcr_index)
      ____ = (__packcr_vars[__packcr_index] ||= Value.new).value if __packcr_vars
      __0 = __packcr_in.capt0.capture_string(@buffer)
      __0s = @buffer_start_position + __packcr_in.capt0.range_start
      __0e = @buffer_start_position + __packcr_in.capt0.range_end
      __0sl = @buffer_start_position_loc + __packcr_in.capt0.start_loc
      __0el = @buffer_start_position_loc + __packcr_in.capt0.end_loc
      __1 = __packcr_in.capts[0].capture_string(@buffer)
      __1s = @buffer_start_position + __packcr_in.capts[0].range_start
      __1e = @buffer_start_position + __packcr_in.capts[0].range_end
      __1sl = @buffer_start_position_loc + __packcr_in.capts[0].start_loc
      __1el = @buffer_start_position_loc + __packcr_in.capts[0].end_loc
      ____ = Packcr::Node::ExpandNode.new(__1.to_i - 1, __0sl.linenum, __0sl.charnum)

      __packcr_vars[__packcr_index].value = ____ if __packcr_vars
    end

    def action_primary_7(__packcr_in, __packcr_vars, __packcr_index)
      ____ = (__packcr_vars[__packcr_index] ||= Value.new).value if __packcr_vars
      __0 = __packcr_in.capt0.capture_string(@buffer)
      __0s = @buffer_start_position + __packcr_in.capt0.range_start
      __0e = @buffer_start_position + __packcr_in.capt0.range_end
      __0sl = @buffer_start_position_loc + __packcr_in.capt0.start_loc
      __0el = @buffer_start_position_loc + __packcr_in.capt0.end_loc
      ____ = Packcr::Node::CharclassNode.new

      __packcr_vars[__packcr_index].value = ____ if __packcr_vars
    end

    def action_primary_8(__packcr_in, __packcr_vars, __packcr_index)
      ____ = (__packcr_vars[__packcr_index] ||= Value.new).value if __packcr_vars
      str = (__packcr_in.value_refs[4] ||= Value.new).value
      __0 = __packcr_in.capt0.capture_string(@buffer)
      __0s = @buffer_start_position + __packcr_in.capt0.range_start
      __0e = @buffer_start_position + __packcr_in.capt0.range_end
      __0sl = @buffer_start_position_loc + __packcr_in.capt0.start_loc
      __0el = @buffer_start_position_loc + __packcr_in.capt0.end_loc
      ____ = Packcr::Node::CharclassNode.new(Packcr.unescape_string(str, true))

      __packcr_vars[__packcr_index].value = ____ if __packcr_vars
    end

    def action_primary_9(__packcr_in, __packcr_vars, __packcr_index)
      ____ = (__packcr_vars[__packcr_index] ||= Value.new).value if __packcr_vars
      str = (__packcr_in.value_refs[4] ||= Value.new).value
      __0 = __packcr_in.capt0.capture_string(@buffer)
      __0s = @buffer_start_position + __packcr_in.capt0.range_start
      __0e = @buffer_start_position + __packcr_in.capt0.range_end
      __0sl = @buffer_start_position_loc + __packcr_in.capt0.start_loc
      __0el = @buffer_start_position_loc + __packcr_in.capt0.end_loc
      ____ = Packcr::Node::StringNode.new(Packcr.unescape_string(str, false))

      __packcr_vars[__packcr_index].value = ____ if __packcr_vars
    end

    def action_primary_10(__packcr_in, __packcr_vars, __packcr_index)
      ____ = (__packcr_vars[__packcr_index] ||= Value.new).value if __packcr_vars
      str = (__packcr_in.value_refs[4] ||= Value.new).value
      __0 = __packcr_in.capt0.capture_string(@buffer)
      __0s = @buffer_start_position + __packcr_in.capt0.range_start
      __0e = @buffer_start_position + __packcr_in.capt0.range_end
      __0sl = @buffer_start_position_loc + __packcr_in.capt0.start_loc
      __0el = @buffer_start_position_loc + __packcr_in.capt0.end_loc
      ____ = Packcr::Node::StringNode.new(Packcr.unescape_string(str, false))

      __packcr_vars[__packcr_index].value = ____ if __packcr_vars
    end

    def action_character_class_0(__packcr_in, __packcr_vars, __packcr_index)
      ____ = (__packcr_vars[__packcr_index] ||= Value.new).value if __packcr_vars
      __0 = __packcr_in.capt0.capture_string(@buffer)
      __0s = @buffer_start_position + __packcr_in.capt0.range_start
      __0e = @buffer_start_position + __packcr_in.capt0.range_end
      __0sl = @buffer_start_position_loc + __packcr_in.capt0.start_loc
      __0el = @buffer_start_position_loc + __packcr_in.capt0.end_loc
      __1 = __packcr_in.capts[0].capture_string(@buffer)
      __1s = @buffer_start_position + __packcr_in.capts[0].range_start
      __1e = @buffer_start_position + __packcr_in.capts[0].range_end
      __1sl = @buffer_start_position_loc + __packcr_in.capts[0].start_loc
      __1el = @buffer_start_position_loc + __packcr_in.capts[0].end_loc
      ____ = __1

      __packcr_vars[__packcr_index].value = ____ if __packcr_vars
    end

    def action_lang_code_block_0(__packcr_in, __packcr_vars, __packcr_index)
      ____ = (__packcr_vars[__packcr_index] ||= Value.new).value if __packcr_vars
      code = (__packcr_in.value_refs[0] ||= Value.new).value
      __0 = __packcr_in.capt0.capture_string(@buffer)
      __0s = @buffer_start_position + __packcr_in.capt0.range_start
      __0e = @buffer_start_position + __packcr_in.capt0.range_end
      __0sl = @buffer_start_position_loc + __packcr_in.capt0.start_loc
      __0el = @buffer_start_position_loc + __packcr_in.capt0.end_loc
      ____ = code

      __packcr_vars[__packcr_index].value = ____ if __packcr_vars
    end

    def action_lang_code_block_1(__packcr_in, __packcr_vars, __packcr_index)
      ____ = (__packcr_vars[__packcr_index] ||= Value.new).value if __packcr_vars
      code = (__packcr_in.value_refs[0] ||= Value.new).value
      __0 = __packcr_in.capt0.capture_string(@buffer)
      __0s = @buffer_start_position + __packcr_in.capt0.range_start
      __0e = @buffer_start_position + __packcr_in.capt0.range_end
      __0sl = @buffer_start_position_loc + __packcr_in.capt0.start_loc
      __0el = @buffer_start_position_loc + __packcr_in.capt0.end_loc
      __1 = __packcr_in.capts[0].capture_string(@buffer)
      __1s = @buffer_start_position + __packcr_in.capts[0].range_start
      __1e = @buffer_start_position + __packcr_in.capts[0].range_end
      __1sl = @buffer_start_position_loc + __packcr_in.capts[0].start_loc
      __1el = @buffer_start_position_loc + __packcr_in.capts[0].end_loc
      ____ = @ctx.lang == __1.to_sym ? code : nil

      __packcr_vars[__packcr_index].value = ____ if __packcr_vars
    end

    def action_code_block_0(__packcr_in, __packcr_vars, __packcr_index)
      ____ = (__packcr_vars[__packcr_index] ||= Value.new).value if __packcr_vars
      code = (__packcr_in.value_refs[0] ||= Value.new).value
      __0 = __packcr_in.capt0.capture_string(@buffer)
      __0s = @buffer_start_position + __packcr_in.capt0.range_start
      __0e = @buffer_start_position + __packcr_in.capt0.range_end
      __0sl = @buffer_start_position_loc + __packcr_in.capt0.start_loc
      __0el = @buffer_start_position_loc + __packcr_in.capt0.end_loc
      ____ = code

      __packcr_vars[__packcr_index].value = ____ if __packcr_vars
    end

    def action_code_block_1(__packcr_in, __packcr_vars, __packcr_index)
      ____ = (__packcr_vars[__packcr_index] ||= Value.new).value if __packcr_vars
      code = (__packcr_in.value_refs[0] ||= Value.new).value
      __0 = __packcr_in.capt0.capture_string(@buffer)
      __0s = @buffer_start_position + __packcr_in.capt0.range_start
      __0e = @buffer_start_position + __packcr_in.capt0.range_end
      __0sl = @buffer_start_position_loc + __packcr_in.capt0.start_loc
      __0el = @buffer_start_position_loc + __packcr_in.capt0.end_loc
      ____ = code.gsub("$", @ctx.lang == :rb ? "__" : "_")

      __packcr_vars[__packcr_index].value = ____ if __packcr_vars
    end

    def action_plain_code_block_0(__packcr_in, __packcr_vars, __packcr_index)
      ____ = (__packcr_vars[__packcr_index] ||= Value.new).value if __packcr_vars
      __0 = __packcr_in.capt0.capture_string(@buffer)
      __0s = @buffer_start_position + __packcr_in.capt0.range_start
      __0e = @buffer_start_position + __packcr_in.capt0.range_end
      __0sl = @buffer_start_position_loc + __packcr_in.capt0.start_loc
      __0el = @buffer_start_position_loc + __packcr_in.capt0.end_loc
      __1 = __packcr_in.capts[0].capture_string(@buffer)
      __1s = @buffer_start_position + __packcr_in.capts[0].range_start
      __1e = @buffer_start_position + __packcr_in.capts[0].range_end
      __1sl = @buffer_start_position_loc + __packcr_in.capts[0].start_loc
      __1el = @buffer_start_position_loc + __packcr_in.capts[0].end_loc
      ____ = __1

      __packcr_vars[__packcr_index].value = ____ if __packcr_vars
    end

    def action_quotation_single_0(__packcr_in, __packcr_vars, __packcr_index)
      ____ = (__packcr_vars[__packcr_index] ||= Value.new).value if __packcr_vars
      __0 = __packcr_in.capt0.capture_string(@buffer)
      __0s = @buffer_start_position + __packcr_in.capt0.range_start
      __0e = @buffer_start_position + __packcr_in.capt0.range_end
      __0sl = @buffer_start_position_loc + __packcr_in.capt0.start_loc
      __0el = @buffer_start_position_loc + __packcr_in.capt0.end_loc
      __1 = __packcr_in.capts[0].capture_string(@buffer)
      __1s = @buffer_start_position + __packcr_in.capts[0].range_start
      __1e = @buffer_start_position + __packcr_in.capts[0].range_end
      __1sl = @buffer_start_position_loc + __packcr_in.capts[0].start_loc
      __1el = @buffer_start_position_loc + __packcr_in.capts[0].end_loc
      ____ = __1

      __packcr_vars[__packcr_index].value = ____ if __packcr_vars
    end

    def action_quotation_double_0(__packcr_in, __packcr_vars, __packcr_index)
      ____ = (__packcr_vars[__packcr_index] ||= Value.new).value if __packcr_vars
      __0 = __packcr_in.capt0.capture_string(@buffer)
      __0s = @buffer_start_position + __packcr_in.capt0.range_start
      __0e = @buffer_start_position + __packcr_in.capt0.range_end
      __0sl = @buffer_start_position_loc + __packcr_in.capt0.start_loc
      __0el = @buffer_start_position_loc + __packcr_in.capt0.end_loc
      __1 = __packcr_in.capts[0].capture_string(@buffer)
      __1s = @buffer_start_position + __packcr_in.capts[0].range_start
      __1e = @buffer_start_position + __packcr_in.capts[0].range_end
      __1sl = @buffer_start_position_loc + __packcr_in.capts[0].start_loc
      __1el = @buffer_start_position_loc + __packcr_in.capts[0].end_loc
      ____ = __1

      __packcr_vars[__packcr_index].value = ____ if __packcr_vars
    end

    def action_identifier_0(__packcr_in, __packcr_vars, __packcr_index)
      ____ = (__packcr_vars[__packcr_index] ||= Value.new).value if __packcr_vars
      __0 = __packcr_in.capt0.capture_string(@buffer)
      __0s = @buffer_start_position + __packcr_in.capt0.range_start
      __0e = @buffer_start_position + __packcr_in.capt0.range_end
      __0sl = @buffer_start_position_loc + __packcr_in.capt0.start_loc
      __0el = @buffer_start_position_loc + __packcr_in.capt0.end_loc
      ____ = __0

      __packcr_vars[__packcr_index].value = ____ if __packcr_vars
    end

    def action_footer_0(__packcr_in, __packcr_vars, __packcr_index)
      ____ = (__packcr_vars[__packcr_index] ||= Value.new).value if __packcr_vars
      __0 = __packcr_in.capt0.capture_string(@buffer)
      __0s = @buffer_start_position + __packcr_in.capt0.range_start
      __0e = @buffer_start_position + __packcr_in.capt0.range_end
      __0sl = @buffer_start_position_loc + __packcr_in.capt0.start_loc
      __0el = @buffer_start_position_loc + __packcr_in.capt0.end_loc
      __1 = __packcr_in.capts[0].capture_string(@buffer)
      __1s = @buffer_start_position + __packcr_in.capts[0].range_start
      __1e = @buffer_start_position + __packcr_in.capts[0].range_end
      __1sl = @buffer_start_position_loc + __packcr_in.capts[0].start_loc
      __1el = @buffer_start_position_loc + __packcr_in.capts[0].end_loc
      @ctx.code(:lsource) << Packcr::CodeBlock.new(__1, __1sl.linenum, __1sl.charnum)

      __packcr_vars[__packcr_index].value = ____ if __packcr_vars
    end

    def evaluate_rule_statement(offset, offset_loc, limits: nil)
      answer = ThunkChunk.new
      answer.pos = @position_offset
      answer.pos_loc = @position_offset_loc
      debug { warn "#{"  " * @level}EVAL    statement #{answer.pos} #{@buffer[answer.pos..-1].inspect}" }
      @level += 1
      answer.resize_captures(0)
      catch(0) do
        catch(1) do
          pos2 = @position_offset
          p_loc2 = @position_offset_loc
          n2 = answer.thunks.length
          if limits && @position_offset == offset && !limits[:evaluate_rule_comment]
            if apply_rule(:evaluate_rule_comment, answer.thunks, nil, 0, offset, offset_loc, limits: limits)
              throw(1)
            end
          elsif apply_rule(:evaluate_rule_comment, answer.thunks, nil, 0, offset, offset_loc)
            throw(1)
          end
          @position_offset = pos2
          @position_offset_loc = p_loc2
          answer.thunks[n2..-1] = []
          if limits && @position_offset == offset && !limits[:evaluate_rule_spaces]
            if apply_rule(:evaluate_rule_spaces, answer.thunks, nil, 0, offset, offset_loc, limits: limits)
              throw(1)
            end
          elsif apply_rule(:evaluate_rule_spaces, answer.thunks, nil, 0, offset, offset_loc)
            throw(1)
          end
          @position_offset = pos2
          @position_offset_loc = p_loc2
          answer.thunks[n2..-1] = []
          if limits && @position_offset == offset && !limits[:evaluate_rule_directive_include]
            if apply_rule(:evaluate_rule_directive_include, answer.thunks, nil, 0, offset, offset_loc, limits: limits)
              throw(1)
            end
          elsif apply_rule(:evaluate_rule_directive_include, answer.thunks, nil, 0, offset, offset_loc)
            throw(1)
          end
          @position_offset = pos2
          @position_offset_loc = p_loc2
          answer.thunks[n2..-1] = []
          if limits && @position_offset == offset && !limits[:evaluate_rule_directive_string]
            if apply_rule(:evaluate_rule_directive_string, answer.thunks, nil, 0, offset, offset_loc, limits: limits)
              throw(1)
            end
          elsif apply_rule(:evaluate_rule_directive_string, answer.thunks, nil, 0, offset, offset_loc)
            throw(1)
          end
          @position_offset = pos2
          @position_offset_loc = p_loc2
          answer.thunks[n2..-1] = []
          if limits && @position_offset == offset && !limits[:evaluate_rule_directive_value]
            if apply_rule(:evaluate_rule_directive_value, answer.thunks, nil, 0, offset, offset_loc, limits: limits)
              throw(1)
            end
          elsif apply_rule(:evaluate_rule_directive_value, answer.thunks, nil, 0, offset, offset_loc)
            throw(1)
          end
          @position_offset = pos2
          @position_offset_loc = p_loc2
          answer.thunks[n2..-1] = []
          if limits && @position_offset == offset && !limits[:evaluate_rule_rule]
            if apply_rule(:evaluate_rule_rule, answer.thunks, nil, 0, offset, offset_loc, limits: limits)
              throw(1)
            end
          elsif apply_rule(:evaluate_rule_rule, answer.thunks, nil, 0, offset, offset_loc)
            throw(1)
          end
          @position_offset = pos2
          @position_offset_loc = p_loc2
          answer.thunks[n2..-1] = []
          if limits && @position_offset == offset && !limits[:evaluate_rule_footer]
            if apply_rule(:evaluate_rule_footer, answer.thunks, nil, 0, offset, offset_loc, limits: limits)
              throw(1)
            end
          elsif apply_rule(:evaluate_rule_footer, answer.thunks, nil, 0, offset, offset_loc)
            throw(1)
          end
          @position_offset = pos2
          @position_offset_loc = p_loc2
          answer.thunks[n2..-1] = []
          catch(2) do
            catch(4) do
              catch(3) do
                if limits && @position_offset == offset && !limits[:evaluate_rule_EOF]
                  if !apply_rule(:evaluate_rule_EOF, answer.thunks, nil, 0, offset, offset_loc, limits: limits)
                    throw(3)
                  end
                elsif !apply_rule(:evaluate_rule_EOF, answer.thunks, nil, 0, offset, offset_loc)
                  throw(3)
                end
                throw(4)
              end

              action_statement_0(
                ThunkLeaf.new(
                  :action_statement_0,
                  Capture.new(
                    answer.pos, @position_offset,
                    answer.pos_loc, @position_offset_loc,
                  ),
                  {},
                  {},
                ),
                nil,
                0,
              )

              throw(2)
            end
            throw(1)
          end
          @position_offset = pos2
          @position_offset_loc = p_loc2
          answer.thunks[n2..-1] = []
          throw(0)
        end
        @level -= 1
        debug { warn "#{"  " * @level}MATCH   statement #{answer.pos} #{@buffer[answer.pos...@position_offset].inspect}" }
        return answer
      end
      @level -= 1
      debug { warn "#{"  " * @level}NOMATCH statement #{answer.pos} #{@buffer[answer.pos...@position_offset].inspect}" }
      nil
    end

    def evaluate_rule_supported_language(offset, offset_loc, limits: nil)
      answer = ThunkChunk.new
      answer.pos = @position_offset
      answer.pos_loc = @position_offset_loc
      debug { warn "#{"  " * @level}EVAL    supported_language #{answer.pos} #{@buffer[answer.pos..-1].inspect}" }
      @level += 1
      answer.resize_captures(0)
      catch(0) do
        catch(1) do
          pos2 = @position_offset
          p_loc2 = @position_offset_loc
          n2 = answer.thunks.length
          catch(2) do
            if refill_buffer(1) < 1 ||
               @buffer[@position_offset] != "c"

              throw(2)
            end
            @position_offset_loc = @position_offset_loc.forward(@buffer, @position_offset, 1)
            @position_offset += 1
            throw(1)
          end
          @position_offset = pos2
          @position_offset_loc = p_loc2
          answer.thunks[n2..-1] = []
          catch(3) do
            if refill_buffer(2) < 2 ||
               @buffer[@position_offset, 2] != "rb"

              throw(3)
            end
            @position_offset_loc = @position_offset_loc.forward(@buffer, @position_offset, 2)
            @position_offset += 2
            throw(1)
          end
          @position_offset = pos2
          @position_offset_loc = p_loc2
          answer.thunks[n2..-1] = []
          catch(4) do
            if limits && @position_offset == offset && !limits[:evaluate_rule_identifier]
              if !apply_rule(:evaluate_rule_identifier, answer.thunks, nil, 0, offset, offset_loc, limits: limits)
                throw(4)
              end
            elsif !apply_rule(:evaluate_rule_identifier, answer.thunks, nil, 0, offset, offset_loc)
              throw(4)
            end
            answer.thunks.push(
              ThunkLeaf.new(
                :action_supported_language_0,
                Capture.new(
                  answer.pos, @position_offset,
                  answer.pos_loc, @position_offset_loc,
                ),
                {},
                {},
              ),
            )
            throw(1)
          end
          @position_offset = pos2
          @position_offset_loc = p_loc2
          answer.thunks[n2..-1] = []
          throw(0)
        end
        @level -= 1
        debug { warn "#{"  " * @level}MATCH   supported_language #{answer.pos} #{@buffer[answer.pos...@position_offset].inspect}" }
        return answer
      end
      @level -= 1
      debug { warn "#{"  " * @level}NOMATCH supported_language #{answer.pos} #{@buffer[answer.pos...@position_offset].inspect}" }
      nil
    end

    def evaluate_rule_comment(offset, offset_loc, limits: nil)
      answer = ThunkChunk.new
      answer.pos = @position_offset
      answer.pos_loc = @position_offset_loc
      debug { warn "#{"  " * @level}EVAL    comment #{answer.pos} #{@buffer[answer.pos..-1].inspect}" }
      @level += 1
      answer.resize_captures(0)
      catch(0) do
        if refill_buffer(1) < 1 ||
           @buffer[@position_offset] != "#"

          throw(0)
        end
        @position_offset_loc = @position_offset_loc.forward(@buffer, @position_offset, 1)
        @position_offset += 1
        i3 = 0
        pos3 = nil
        p_loc3 = nil
        n3 = nil
        catch(1) do
          pos3 = @position_offset
          p_loc3 = @position_offset_loc
          n3 = answer.thunks.length
          if refill_buffer(1) < 1
            throw(1)
          end
          u4 = @buffer[@position_offset]
          if u4 == "\n"

            throw(1)
          end
          @position_offset_loc = @position_offset_loc.forward(@buffer, @position_offset, 1)
          @position_offset += 1
          i3 += 1
          if @position_offset != pos3
            redo
          end
          pos3 = nil
        end
        if pos3
          @position_offset = pos3
          @position_offset_loc = p_loc3
          answer.thunks[n3..-1] = []
        end
        catch(2) do
          pos3 = @position_offset
          p_loc3 = @position_offset_loc
          n3 = answer.thunks.length
          if limits && @position_offset == offset && !limits[:evaluate_rule_lf]
            if apply_rule(:evaluate_rule_lf, answer.thunks, nil, 0, offset, offset_loc, limits: limits)
              throw(2)
            end
          elsif apply_rule(:evaluate_rule_lf, answer.thunks, nil, 0, offset, offset_loc)
            throw(2)
          end
          @position_offset = pos3
          @position_offset_loc = p_loc3
          answer.thunks[n3..-1] = []
          if limits && @position_offset == offset && !limits[:evaluate_rule_EOF]
            if apply_rule(:evaluate_rule_EOF, answer.thunks, nil, 0, offset, offset_loc, limits: limits)
              throw(2)
            end
          elsif apply_rule(:evaluate_rule_EOF, answer.thunks, nil, 0, offset, offset_loc)
            throw(2)
          end
          @position_offset = pos3
          @position_offset_loc = p_loc3
          answer.thunks[n3..-1] = []
          throw(0)
        end
        @level -= 1
        debug { warn "#{"  " * @level}MATCH   comment #{answer.pos} #{@buffer[answer.pos...@position_offset].inspect}" }
        return answer
      end
      @level -= 1
      debug { warn "#{"  " * @level}NOMATCH comment #{answer.pos} #{@buffer[answer.pos...@position_offset].inspect}" }
      nil
    end

    def evaluate_rule_directive_include(offset, offset_loc, limits: nil)
      answer = ThunkChunk.new
      answer.pos = @position_offset
      answer.pos_loc = @position_offset_loc
      debug { warn "#{"  " * @level}EVAL    directive_include #{answer.pos} #{@buffer[answer.pos..-1].inspect}" }
      @level += 1
      answer.resize_captures(1)
      answer.values = {}
      catch(0) do
        catch(1) do
          pos2 = @position_offset
          p_loc2 = @position_offset_loc
          n2 = answer.thunks.length
          catch(2) do
            if refill_buffer(12) < 12 ||
               @buffer[@position_offset, 12] != "%earlysource"

              throw(2)
            end
            @position_offset_loc = @position_offset_loc.forward(@buffer, @position_offset, 12)
            @position_offset += 12
            if limits && @position_offset == offset && !limits[:evaluate_rule_opt_spaces_or_comments]
              if !apply_rule(:evaluate_rule_opt_spaces_or_comments, answer.thunks, nil, 0, offset, offset_loc, limits: limits)
                throw(2)
              end
            elsif !apply_rule(:evaluate_rule_opt_spaces_or_comments, answer.thunks, nil, 0, offset, offset_loc)
              throw(2)
            end
            if limits && @position_offset == offset && !limits[:evaluate_rule_code_blocks]
              if !apply_rule(:evaluate_rule_code_blocks, answer.thunks, answer.values, 0, offset, offset_loc, limits: limits)
                throw(2)
              end
            elsif !apply_rule(:evaluate_rule_code_blocks, answer.thunks, answer.values, 0, offset, offset_loc)
              throw(2)
            end
            answer.thunks.push(
              ThunkLeaf.new(
                :action_directive_include_0,
                Capture.new(
                  answer.pos, @position_offset,
                  answer.pos_loc, @position_offset_loc,
                ),
                answer.values.slice(0),
                {},
              ),
            )
            throw(1)
          end
          @position_offset = pos2
          @position_offset_loc = p_loc2
          answer.thunks[n2..-1] = []
          catch(3) do
            if refill_buffer(7) < 7 ||
               @buffer[@position_offset, 7] != "%source"

              throw(3)
            end
            @position_offset_loc = @position_offset_loc.forward(@buffer, @position_offset, 7)
            @position_offset += 7
            if limits && @position_offset == offset && !limits[:evaluate_rule_opt_spaces_or_comments]
              if !apply_rule(:evaluate_rule_opt_spaces_or_comments, answer.thunks, nil, 0, offset, offset_loc, limits: limits)
                throw(3)
              end
            elsif !apply_rule(:evaluate_rule_opt_spaces_or_comments, answer.thunks, nil, 0, offset, offset_loc)
              throw(3)
            end
            if limits && @position_offset == offset && !limits[:evaluate_rule_code_blocks]
              if !apply_rule(:evaluate_rule_code_blocks, answer.thunks, answer.values, 0, offset, offset_loc, limits: limits)
                throw(3)
              end
            elsif !apply_rule(:evaluate_rule_code_blocks, answer.thunks, answer.values, 0, offset, offset_loc)
              throw(3)
            end
            answer.thunks.push(
              ThunkLeaf.new(
                :action_directive_include_1,
                Capture.new(
                  answer.pos, @position_offset,
                  answer.pos_loc, @position_offset_loc,
                ),
                answer.values.slice(0),
                {},
              ),
            )
            throw(1)
          end
          @position_offset = pos2
          @position_offset_loc = p_loc2
          answer.thunks[n2..-1] = []
          catch(4) do
            if refill_buffer(11) < 11 ||
               @buffer[@position_offset, 11] != "%lateheader"

              throw(4)
            end
            @position_offset_loc = @position_offset_loc.forward(@buffer, @position_offset, 11)
            @position_offset += 11
            if limits && @position_offset == offset && !limits[:evaluate_rule_opt_spaces_or_comments]
              if !apply_rule(:evaluate_rule_opt_spaces_or_comments, answer.thunks, nil, 0, offset, offset_loc, limits: limits)
                throw(4)
              end
            elsif !apply_rule(:evaluate_rule_opt_spaces_or_comments, answer.thunks, nil, 0, offset, offset_loc)
              throw(4)
            end
            if limits && @position_offset == offset && !limits[:evaluate_rule_code_blocks]
              if !apply_rule(:evaluate_rule_code_blocks, answer.thunks, answer.values, 0, offset, offset_loc, limits: limits)
                throw(4)
              end
            elsif !apply_rule(:evaluate_rule_code_blocks, answer.thunks, answer.values, 0, offset, offset_loc)
              throw(4)
            end
            answer.thunks.push(
              ThunkLeaf.new(
                :action_directive_include_2,
                Capture.new(
                  answer.pos, @position_offset,
                  answer.pos_loc, @position_offset_loc,
                ),
                answer.values.slice(0),
                {},
              ),
            )
            throw(1)
          end
          @position_offset = pos2
          @position_offset_loc = p_loc2
          answer.thunks[n2..-1] = []
          catch(5) do
            if refill_buffer(11) < 11 ||
               @buffer[@position_offset, 11] != "%latesource"

              throw(5)
            end
            @position_offset_loc = @position_offset_loc.forward(@buffer, @position_offset, 11)
            @position_offset += 11
            if limits && @position_offset == offset && !limits[:evaluate_rule_opt_spaces_or_comments]
              if !apply_rule(:evaluate_rule_opt_spaces_or_comments, answer.thunks, nil, 0, offset, offset_loc, limits: limits)
                throw(5)
              end
            elsif !apply_rule(:evaluate_rule_opt_spaces_or_comments, answer.thunks, nil, 0, offset, offset_loc)
              throw(5)
            end
            if limits && @position_offset == offset && !limits[:evaluate_rule_code_blocks]
              if !apply_rule(:evaluate_rule_code_blocks, answer.thunks, answer.values, 0, offset, offset_loc, limits: limits)
                throw(5)
              end
            elsif !apply_rule(:evaluate_rule_code_blocks, answer.thunks, answer.values, 0, offset, offset_loc)
              throw(5)
            end
            answer.thunks.push(
              ThunkLeaf.new(
                :action_directive_include_3,
                Capture.new(
                  answer.pos, @position_offset,
                  answer.pos_loc, @position_offset_loc,
                ),
                answer.values.slice(0),
                {},
              ),
            )
            throw(1)
          end
          @position_offset = pos2
          @position_offset_loc = p_loc2
          answer.thunks[n2..-1] = []
          catch(6) do
            if refill_buffer(7) < 7 ||
               @buffer[@position_offset, 7] != "%header"

              throw(6)
            end
            @position_offset_loc = @position_offset_loc.forward(@buffer, @position_offset, 7)
            @position_offset += 7
            if limits && @position_offset == offset && !limits[:evaluate_rule_opt_spaces_or_comments]
              if !apply_rule(:evaluate_rule_opt_spaces_or_comments, answer.thunks, nil, 0, offset, offset_loc, limits: limits)
                throw(6)
              end
            elsif !apply_rule(:evaluate_rule_opt_spaces_or_comments, answer.thunks, nil, 0, offset, offset_loc)
              throw(6)
            end
            if limits && @position_offset == offset && !limits[:evaluate_rule_code_blocks]
              if !apply_rule(:evaluate_rule_code_blocks, answer.thunks, answer.values, 0, offset, offset_loc, limits: limits)
                throw(6)
              end
            elsif !apply_rule(:evaluate_rule_code_blocks, answer.thunks, answer.values, 0, offset, offset_loc)
              throw(6)
            end
            answer.thunks.push(
              ThunkLeaf.new(
                :action_directive_include_4,
                Capture.new(
                  answer.pos, @position_offset,
                  answer.pos_loc, @position_offset_loc,
                ),
                answer.values.slice(0),
                {},
              ),
            )
            throw(1)
          end
          @position_offset = pos2
          @position_offset_loc = p_loc2
          answer.thunks[n2..-1] = []
          catch(7) do
            if refill_buffer(9) < 9 ||
               @buffer[@position_offset, 9] != "%location"

              throw(7)
            end
            @position_offset_loc = @position_offset_loc.forward(@buffer, @position_offset, 9)
            @position_offset += 9
            if limits && @position_offset == offset && !limits[:evaluate_rule_opt_spaces_or_comments]
              if !apply_rule(:evaluate_rule_opt_spaces_or_comments, answer.thunks, nil, 0, offset, offset_loc, limits: limits)
                throw(7)
              end
            elsif !apply_rule(:evaluate_rule_opt_spaces_or_comments, answer.thunks, nil, 0, offset, offset_loc)
              throw(7)
            end
            if limits && @position_offset == offset && !limits[:evaluate_rule_code_blocks]
              if !apply_rule(:evaluate_rule_code_blocks, answer.thunks, answer.values, 0, offset, offset_loc, limits: limits)
                throw(7)
              end
            elsif !apply_rule(:evaluate_rule_code_blocks, answer.thunks, answer.values, 0, offset, offset_loc)
              throw(7)
            end
            answer.thunks.push(
              ThunkLeaf.new(
                :action_directive_include_5,
                Capture.new(
                  answer.pos, @position_offset,
                  answer.pos_loc, @position_offset_loc,
                ),
                answer.values.slice(0),
                {},
              ),
            )
            throw(1)
          end
          @position_offset = pos2
          @position_offset_loc = p_loc2
          answer.thunks[n2..-1] = []
          catch(8) do
            if refill_buffer(11) < 11 ||
               @buffer[@position_offset, 11] != "%initialize"

              throw(8)
            end
            @position_offset_loc = @position_offset_loc.forward(@buffer, @position_offset, 11)
            @position_offset += 11
            if limits && @position_offset == offset && !limits[:evaluate_rule_opt_spaces_or_comments]
              if !apply_rule(:evaluate_rule_opt_spaces_or_comments, answer.thunks, nil, 0, offset, offset_loc, limits: limits)
                throw(8)
              end
            elsif !apply_rule(:evaluate_rule_opt_spaces_or_comments, answer.thunks, nil, 0, offset, offset_loc)
              throw(8)
            end
            if limits && @position_offset == offset && !limits[:evaluate_rule_code_blocks]
              if !apply_rule(:evaluate_rule_code_blocks, answer.thunks, answer.values, 0, offset, offset_loc, limits: limits)
                throw(8)
              end
            elsif !apply_rule(:evaluate_rule_code_blocks, answer.thunks, answer.values, 0, offset, offset_loc)
              throw(8)
            end
            answer.thunks.push(
              ThunkLeaf.new(
                :action_directive_include_6,
                Capture.new(
                  answer.pos, @position_offset,
                  answer.pos_loc, @position_offset_loc,
                ),
                answer.values.slice(0),
                {},
              ),
            )
            throw(1)
          end
          @position_offset = pos2
          @position_offset_loc = p_loc2
          answer.thunks[n2..-1] = []
          catch(9) do
            if refill_buffer(12) < 12 ||
               @buffer[@position_offset, 12] != "%earlycommon"

              throw(9)
            end
            @position_offset_loc = @position_offset_loc.forward(@buffer, @position_offset, 12)
            @position_offset += 12
            if limits && @position_offset == offset && !limits[:evaluate_rule_opt_spaces_or_comments]
              if !apply_rule(:evaluate_rule_opt_spaces_or_comments, answer.thunks, nil, 0, offset, offset_loc, limits: limits)
                throw(9)
              end
            elsif !apply_rule(:evaluate_rule_opt_spaces_or_comments, answer.thunks, nil, 0, offset, offset_loc)
              throw(9)
            end
            if limits && @position_offset == offset && !limits[:evaluate_rule_code_blocks]
              if !apply_rule(:evaluate_rule_code_blocks, answer.thunks, answer.values, 0, offset, offset_loc, limits: limits)
                throw(9)
              end
            elsif !apply_rule(:evaluate_rule_code_blocks, answer.thunks, answer.values, 0, offset, offset_loc)
              throw(9)
            end
            answer.thunks.push(
              ThunkLeaf.new(
                :action_directive_include_7,
                Capture.new(
                  answer.pos, @position_offset,
                  answer.pos_loc, @position_offset_loc,
                ),
                answer.values.slice(0),
                {},
              ),
            )
            throw(1)
          end
          @position_offset = pos2
          @position_offset_loc = p_loc2
          answer.thunks[n2..-1] = []
          catch(10) do
            if refill_buffer(7) < 7 ||
               @buffer[@position_offset, 7] != "%common"

              throw(10)
            end
            @position_offset_loc = @position_offset_loc.forward(@buffer, @position_offset, 7)
            @position_offset += 7
            if limits && @position_offset == offset && !limits[:evaluate_rule_opt_spaces_or_comments]
              if !apply_rule(:evaluate_rule_opt_spaces_or_comments, answer.thunks, nil, 0, offset, offset_loc, limits: limits)
                throw(10)
              end
            elsif !apply_rule(:evaluate_rule_opt_spaces_or_comments, answer.thunks, nil, 0, offset, offset_loc)
              throw(10)
            end
            if limits && @position_offset == offset && !limits[:evaluate_rule_code_blocks]
              if !apply_rule(:evaluate_rule_code_blocks, answer.thunks, answer.values, 0, offset, offset_loc, limits: limits)
                throw(10)
              end
            elsif !apply_rule(:evaluate_rule_code_blocks, answer.thunks, answer.values, 0, offset, offset_loc)
              throw(10)
            end
            answer.thunks.push(
              ThunkLeaf.new(
                :action_directive_include_8,
                Capture.new(
                  answer.pos, @position_offset,
                  answer.pos_loc, @position_offset_loc,
                ),
                answer.values.slice(0),
                {},
              ),
            )
            throw(1)
          end
          @position_offset = pos2
          @position_offset_loc = p_loc2
          answer.thunks[n2..-1] = []
          catch(11) do
            if refill_buffer(1) < 1 ||
               @buffer[@position_offset] != "%"

              throw(11)
            end
            @position_offset_loc = @position_offset_loc.forward(@buffer, @position_offset, 1)
            @position_offset += 1
            pos4 = @position_offset
            p_loc4 = @position_offset_loc
            if limits && @position_offset == offset && !limits[:evaluate_rule_identifier]
              if !apply_rule(:evaluate_rule_identifier, answer.thunks, nil, 0, offset, offset_loc, limits: limits)
                throw(11)
              end
            elsif !apply_rule(:evaluate_rule_identifier, answer.thunks, nil, 0, offset, offset_loc)
              throw(11)
            end
            q4 = @position_offset
            capt4 = answer.capts[0]
            capt4.range_start = pos4
            capt4.range_end = q4
            q_loc4 = @position_offset_loc
            capt4.start_loc = p_loc4
            capt4.end_loc = q_loc4
            if limits && @position_offset == offset && !limits[:evaluate_rule_opt_spaces_or_comments]
              if !apply_rule(:evaluate_rule_opt_spaces_or_comments, answer.thunks, nil, 0, offset, offset_loc, limits: limits)
                throw(11)
              end
            elsif !apply_rule(:evaluate_rule_opt_spaces_or_comments, answer.thunks, nil, 0, offset, offset_loc)
              throw(11)
            end
            if limits && @position_offset == offset && !limits[:evaluate_rule_code_blocks]
              if !apply_rule(:evaluate_rule_code_blocks, answer.thunks, answer.values, 0, offset, offset_loc, limits: limits)
                throw(11)
              end
            elsif !apply_rule(:evaluate_rule_code_blocks, answer.thunks, answer.values, 0, offset, offset_loc)
              throw(11)
            end
            answer.thunks.push(
              ThunkLeaf.new(
                :action_directive_include_9,
                Capture.new(
                  answer.pos, @position_offset,
                  answer.pos_loc, @position_offset_loc,
                ),
                answer.values.slice(0),
                answer.capts.slice(0),
              ),
            )
            throw(1)
          end
          @position_offset = pos2
          @position_offset_loc = p_loc2
          answer.thunks[n2..-1] = []
          throw(0)
        end
        @level -= 1
        debug { warn "#{"  " * @level}MATCH   directive_include #{answer.pos} #{@buffer[answer.pos...@position_offset].inspect}" }
        return answer
      end
      @level -= 1
      debug { warn "#{"  " * @level}NOMATCH directive_include #{answer.pos} #{@buffer[answer.pos...@position_offset].inspect}" }
      nil
    end

    def evaluate_rule_code_blocks(offset, offset_loc, limits: nil)
      answer = ThunkChunk.new
      answer.pos = @position_offset
      answer.pos_loc = @position_offset_loc
      debug { warn "#{"  " * @level}EVAL    code_blocks #{answer.pos} #{@buffer[answer.pos..-1].inspect}" }
      @level += 1
      answer.resize_captures(0)
      answer.values = {}
      catch(0) do
        catch(1) do
          pos2 = @position_offset
          p_loc2 = @position_offset_loc
          n2 = answer.thunks.length
          catch(2) do
            if limits && @position_offset == offset && !limits[:evaluate_rule_code_blocks]
              if !apply_rule(:evaluate_rule_code_blocks, answer.thunks, answer.values, 0, offset, offset_loc, limits: limits)
                throw(2)
              end
            elsif !apply_rule(:evaluate_rule_code_blocks, answer.thunks, answer.values, 0, offset, offset_loc)
              throw(2)
            end
            if limits && @position_offset == offset && !limits[:evaluate_rule_opt_spaces_or_comments]
              if !apply_rule(:evaluate_rule_opt_spaces_or_comments, answer.thunks, nil, 0, offset, offset_loc, limits: limits)
                throw(2)
              end
            elsif !apply_rule(:evaluate_rule_opt_spaces_or_comments, answer.thunks, nil, 0, offset, offset_loc)
              throw(2)
            end
            if limits && @position_offset == offset && !limits[:evaluate_rule_lang_code_block]
              if !apply_rule(:evaluate_rule_lang_code_block, answer.thunks, answer.values, 1, offset, offset_loc, limits: limits)
                throw(2)
              end
            elsif !apply_rule(:evaluate_rule_lang_code_block, answer.thunks, answer.values, 1, offset, offset_loc)
              throw(2)
            end
            answer.thunks.push(
              ThunkLeaf.new(
                :action_code_blocks_0,
                Capture.new(
                  answer.pos, @position_offset,
                  answer.pos_loc, @position_offset_loc,
                ),
                answer.values.slice(0, 1),
                {},
              ),
            )
            throw(1)
          end
          @position_offset = pos2
          @position_offset_loc = p_loc2
          answer.thunks[n2..-1] = []
          catch(3) do
            if limits && @position_offset == offset && !limits[:evaluate_rule_lang_code_block]
              if !apply_rule(:evaluate_rule_lang_code_block, answer.thunks, answer.values, 1, offset, offset_loc, limits: limits)
                throw(3)
              end
            elsif !apply_rule(:evaluate_rule_lang_code_block, answer.thunks, answer.values, 1, offset, offset_loc)
              throw(3)
            end
            answer.thunks.push(
              ThunkLeaf.new(
                :action_code_blocks_1,
                Capture.new(
                  answer.pos, @position_offset,
                  answer.pos_loc, @position_offset_loc,
                ),
                answer.values.slice(1),
                {},
              ),
            )
            throw(1)
          end
          @position_offset = pos2
          @position_offset_loc = p_loc2
          answer.thunks[n2..-1] = []
          throw(0)
        end
        @level -= 1
        debug { warn "#{"  " * @level}MATCH   code_blocks #{answer.pos} #{@buffer[answer.pos...@position_offset].inspect}" }
        return answer
      end
      @level -= 1
      debug { warn "#{"  " * @level}NOMATCH code_blocks #{answer.pos} #{@buffer[answer.pos...@position_offset].inspect}" }
      nil
    end

    def evaluate_rule_directive_string(offset, offset_loc, limits: nil)
      answer = ThunkChunk.new
      answer.pos = @position_offset
      answer.pos_loc = @position_offset_loc
      debug { warn "#{"  " * @level}EVAL    directive_string #{answer.pos} #{@buffer[answer.pos..-1].inspect}" }
      @level += 1
      answer.resize_captures(1)
      answer.values = {}
      catch(0) do
        catch(1) do
          pos2 = @position_offset
          p_loc2 = @position_offset_loc
          n2 = answer.thunks.length
          catch(2) do
            if refill_buffer(6) < 6 ||
               @buffer[@position_offset, 6] != "%value"

              throw(2)
            end
            @position_offset_loc = @position_offset_loc.forward(@buffer, @position_offset, 6)
            @position_offset += 6
            if limits && @position_offset == offset && !limits[:evaluate_rule_opt_spaces_or_comments]
              if !apply_rule(:evaluate_rule_opt_spaces_or_comments, answer.thunks, nil, 0, offset, offset_loc, limits: limits)
                throw(2)
              end
            elsif !apply_rule(:evaluate_rule_opt_spaces_or_comments, answer.thunks, nil, 0, offset, offset_loc)
              throw(2)
            end
            if limits && @position_offset == offset && !limits[:evaluate_rule_lang_strings]
              if !apply_rule(:evaluate_rule_lang_strings, answer.thunks, answer.values, 0, offset, offset_loc, limits: limits)
                throw(2)
              end
            elsif !apply_rule(:evaluate_rule_lang_strings, answer.thunks, answer.values, 0, offset, offset_loc)
              throw(2)
            end
            answer.thunks.push(
              ThunkLeaf.new(
                :action_directive_string_0,
                Capture.new(
                  answer.pos, @position_offset,
                  answer.pos_loc, @position_offset_loc,
                ),
                answer.values.slice(0),
                {},
              ),
            )
            throw(1)
          end
          @position_offset = pos2
          @position_offset_loc = p_loc2
          answer.thunks[n2..-1] = []
          catch(3) do
            if refill_buffer(6) < 6 ||
               @buffer[@position_offset, 6] != "%auxil"

              throw(3)
            end
            @position_offset_loc = @position_offset_loc.forward(@buffer, @position_offset, 6)
            @position_offset += 6
            if limits && @position_offset == offset && !limits[:evaluate_rule_opt_spaces_or_comments]
              if !apply_rule(:evaluate_rule_opt_spaces_or_comments, answer.thunks, nil, 0, offset, offset_loc, limits: limits)
                throw(3)
              end
            elsif !apply_rule(:evaluate_rule_opt_spaces_or_comments, answer.thunks, nil, 0, offset, offset_loc)
              throw(3)
            end
            if limits && @position_offset == offset && !limits[:evaluate_rule_lang_strings]
              if !apply_rule(:evaluate_rule_lang_strings, answer.thunks, answer.values, 0, offset, offset_loc, limits: limits)
                throw(3)
              end
            elsif !apply_rule(:evaluate_rule_lang_strings, answer.thunks, answer.values, 0, offset, offset_loc)
              throw(3)
            end
            answer.thunks.push(
              ThunkLeaf.new(
                :action_directive_string_1,
                Capture.new(
                  answer.pos, @position_offset,
                  answer.pos_loc, @position_offset_loc,
                ),
                answer.values.slice(0),
                {},
              ),
            )
            throw(1)
          end
          @position_offset = pos2
          @position_offset_loc = p_loc2
          answer.thunks[n2..-1] = []
          catch(4) do
            if refill_buffer(7) < 7 ||
               @buffer[@position_offset, 7] != "%prefix"

              throw(4)
            end
            @position_offset_loc = @position_offset_loc.forward(@buffer, @position_offset, 7)
            @position_offset += 7
            if limits && @position_offset == offset && !limits[:evaluate_rule_opt_spaces_or_comments]
              if !apply_rule(:evaluate_rule_opt_spaces_or_comments, answer.thunks, nil, 0, offset, offset_loc, limits: limits)
                throw(4)
              end
            elsif !apply_rule(:evaluate_rule_opt_spaces_or_comments, answer.thunks, nil, 0, offset, offset_loc)
              throw(4)
            end
            if limits && @position_offset == offset && !limits[:evaluate_rule_lang_strings]
              if !apply_rule(:evaluate_rule_lang_strings, answer.thunks, answer.values, 0, offset, offset_loc, limits: limits)
                throw(4)
              end
            elsif !apply_rule(:evaluate_rule_lang_strings, answer.thunks, answer.values, 0, offset, offset_loc)
              throw(4)
            end
            answer.thunks.push(
              ThunkLeaf.new(
                :action_directive_string_2,
                Capture.new(
                  answer.pos, @position_offset,
                  answer.pos_loc, @position_offset_loc,
                ),
                answer.values.slice(0),
                {},
              ),
            )
            throw(1)
          end
          @position_offset = pos2
          @position_offset_loc = p_loc2
          answer.thunks[n2..-1] = []
          catch(5) do
            if refill_buffer(1) < 1 ||
               @buffer[@position_offset] != "%"

              throw(5)
            end
            @position_offset_loc = @position_offset_loc.forward(@buffer, @position_offset, 1)
            @position_offset += 1
            pos4 = @position_offset
            p_loc4 = @position_offset_loc
            if limits && @position_offset == offset && !limits[:evaluate_rule_identifier]
              if !apply_rule(:evaluate_rule_identifier, answer.thunks, nil, 0, offset, offset_loc, limits: limits)
                throw(5)
              end
            elsif !apply_rule(:evaluate_rule_identifier, answer.thunks, nil, 0, offset, offset_loc)
              throw(5)
            end
            q4 = @position_offset
            capt4 = answer.capts[0]
            capt4.range_start = pos4
            capt4.range_end = q4
            q_loc4 = @position_offset_loc
            capt4.start_loc = p_loc4
            capt4.end_loc = q_loc4
            if limits && @position_offset == offset && !limits[:evaluate_rule_opt_spaces_or_comments]
              if !apply_rule(:evaluate_rule_opt_spaces_or_comments, answer.thunks, nil, 0, offset, offset_loc, limits: limits)
                throw(5)
              end
            elsif !apply_rule(:evaluate_rule_opt_spaces_or_comments, answer.thunks, nil, 0, offset, offset_loc)
              throw(5)
            end
            if limits && @position_offset == offset && !limits[:evaluate_rule_quotation_double]
              if !apply_rule(:evaluate_rule_quotation_double, answer.thunks, answer.values, 1, offset, offset_loc, limits: limits)
                throw(5)
              end
            elsif !apply_rule(:evaluate_rule_quotation_double, answer.thunks, answer.values, 1, offset, offset_loc)
              throw(5)
            end
            answer.thunks.push(
              ThunkLeaf.new(
                :action_directive_string_3,
                Capture.new(
                  answer.pos, @position_offset,
                  answer.pos_loc, @position_offset_loc,
                ),
                answer.values.slice(1),
                answer.capts.slice(0),
              ),
            )
            throw(1)
          end
          @position_offset = pos2
          @position_offset_loc = p_loc2
          answer.thunks[n2..-1] = []
          throw(0)
        end
        @level -= 1
        debug { warn "#{"  " * @level}MATCH   directive_string #{answer.pos} #{@buffer[answer.pos...@position_offset].inspect}" }
        return answer
      end
      @level -= 1
      debug { warn "#{"  " * @level}NOMATCH directive_string #{answer.pos} #{@buffer[answer.pos...@position_offset].inspect}" }
      nil
    end

    def evaluate_rule_directive_value(offset, offset_loc, limits: nil)
      answer = ThunkChunk.new
      answer.pos = @position_offset
      answer.pos_loc = @position_offset_loc
      debug { warn "#{"  " * @level}EVAL    directive_value #{answer.pos} #{@buffer[answer.pos..-1].inspect}" }
      @level += 1
      answer.resize_captures(0)
      catch(0) do
        if refill_buffer(8) < 8 ||
           @buffer[@position_offset, 8] != "%capture"

          throw(0)
        end
        @position_offset_loc = @position_offset_loc.forward(@buffer, @position_offset, 8)
        @position_offset += 8
        if limits && @position_offset == offset && !limits[:evaluate_rule_spaces]
          if !apply_rule(:evaluate_rule_spaces, answer.thunks, nil, 0, offset, offset_loc, limits: limits)
            throw(0)
          end
        elsif !apply_rule(:evaluate_rule_spaces, answer.thunks, nil, 0, offset, offset_loc)
          throw(0)
        end
        catch(1) do
          pos3 = @position_offset
          p_loc3 = @position_offset_loc
          n3 = answer.thunks.length
          catch(2) do
            if refill_buffer(2) < 2 ||
               @buffer[@position_offset, 2] != "on"

              throw(2)
            end
            @position_offset_loc = @position_offset_loc.forward(@buffer, @position_offset, 2)
            @position_offset += 2
            throw(1)
          end
          @position_offset = pos3
          @position_offset_loc = p_loc3
          answer.thunks[n3..-1] = []
          catch(3) do
            if refill_buffer(4) < 4 ||
               @buffer[@position_offset, 4] != "true"

              throw(3)
            end
            @position_offset_loc = @position_offset_loc.forward(@buffer, @position_offset, 4)
            @position_offset += 4
            throw(1)
          end
          @position_offset = pos3
          @position_offset_loc = p_loc3
          answer.thunks[n3..-1] = []
          throw(0)
        end
        answer.thunks.push(
          ThunkLeaf.new(
            :action_directive_value_0,
            Capture.new(
              answer.pos, @position_offset,
              answer.pos_loc, @position_offset_loc,
            ),
            {},
            {},
          ),
        )
        @level -= 1
        debug { warn "#{"  " * @level}MATCH   directive_value #{answer.pos} #{@buffer[answer.pos...@position_offset].inspect}" }
        return answer
      end
      @level -= 1
      debug { warn "#{"  " * @level}NOMATCH directive_value #{answer.pos} #{@buffer[answer.pos...@position_offset].inspect}" }
      nil
    end

    def evaluate_rule_lang_strings(offset, offset_loc, limits: nil)
      answer = ThunkChunk.new
      answer.pos = @position_offset
      answer.pos_loc = @position_offset_loc
      debug { warn "#{"  " * @level}EVAL    lang_strings #{answer.pos} #{@buffer[answer.pos..-1].inspect}" }
      @level += 1
      answer.resize_captures(0)
      answer.values = {}
      catch(0) do
        catch(1) do
          pos2 = @position_offset
          p_loc2 = @position_offset_loc
          n2 = answer.thunks.length
          catch(2) do
            if limits && @position_offset == offset && !limits[:evaluate_rule_lang_strings]
              if !apply_rule(:evaluate_rule_lang_strings, answer.thunks, answer.values, 0, offset, offset_loc, limits: limits)
                throw(2)
              end
            elsif !apply_rule(:evaluate_rule_lang_strings, answer.thunks, answer.values, 0, offset, offset_loc)
              throw(2)
            end
            if limits && @position_offset == offset && !limits[:evaluate_rule_opt_spaces_or_comments]
              if !apply_rule(:evaluate_rule_opt_spaces_or_comments, answer.thunks, nil, 0, offset, offset_loc, limits: limits)
                throw(2)
              end
            elsif !apply_rule(:evaluate_rule_opt_spaces_or_comments, answer.thunks, nil, 0, offset, offset_loc)
              throw(2)
            end
            if limits && @position_offset == offset && !limits[:evaluate_rule_lang_string]
              if !apply_rule(:evaluate_rule_lang_string, answer.thunks, answer.values, 1, offset, offset_loc, limits: limits)
                throw(2)
              end
            elsif !apply_rule(:evaluate_rule_lang_string, answer.thunks, answer.values, 1, offset, offset_loc)
              throw(2)
            end
            answer.thunks.push(
              ThunkLeaf.new(
                :action_lang_strings_0,
                Capture.new(
                  answer.pos, @position_offset,
                  answer.pos_loc, @position_offset_loc,
                ),
                answer.values.slice(0, 1),
                {},
              ),
            )
            throw(1)
          end
          @position_offset = pos2
          @position_offset_loc = p_loc2
          answer.thunks[n2..-1] = []
          catch(3) do
            if limits && @position_offset == offset && !limits[:evaluate_rule_lang_string]
              if !apply_rule(:evaluate_rule_lang_string, answer.thunks, answer.values, 1, offset, offset_loc, limits: limits)
                throw(3)
              end
            elsif !apply_rule(:evaluate_rule_lang_string, answer.thunks, answer.values, 1, offset, offset_loc)
              throw(3)
            end
            answer.thunks.push(
              ThunkLeaf.new(
                :action_lang_strings_1,
                Capture.new(
                  answer.pos, @position_offset,
                  answer.pos_loc, @position_offset_loc,
                ),
                answer.values.slice(1),
                {},
              ),
            )
            throw(1)
          end
          @position_offset = pos2
          @position_offset_loc = p_loc2
          answer.thunks[n2..-1] = []
          throw(0)
        end
        @level -= 1
        debug { warn "#{"  " * @level}MATCH   lang_strings #{answer.pos} #{@buffer[answer.pos...@position_offset].inspect}" }
        return answer
      end
      @level -= 1
      debug { warn "#{"  " * @level}NOMATCH lang_strings #{answer.pos} #{@buffer[answer.pos...@position_offset].inspect}" }
      nil
    end

    def evaluate_rule_lang_string(offset, offset_loc, limits: nil)
      answer = ThunkChunk.new
      answer.pos = @position_offset
      answer.pos_loc = @position_offset_loc
      debug { warn "#{"  " * @level}EVAL    lang_string #{answer.pos} #{@buffer[answer.pos..-1].inspect}" }
      @level += 1
      answer.resize_captures(1)
      answer.values = {}
      catch(0) do
        catch(1) do
          pos2 = @position_offset
          p_loc2 = @position_offset_loc
          n2 = answer.thunks.length
          catch(2) do
            if limits && @position_offset == offset && !limits[:evaluate_rule_quotation_double]
              if !apply_rule(:evaluate_rule_quotation_double, answer.thunks, answer.values, 0, offset, offset_loc, limits: limits)
                throw(2)
              end
            elsif !apply_rule(:evaluate_rule_quotation_double, answer.thunks, answer.values, 0, offset, offset_loc)
              throw(2)
            end
            answer.thunks.push(
              ThunkLeaf.new(
                :action_lang_string_0,
                Capture.new(
                  answer.pos, @position_offset,
                  answer.pos_loc, @position_offset_loc,
                ),
                answer.values.slice(0),
                {},
              ),
            )
            throw(1)
          end
          @position_offset = pos2
          @position_offset_loc = p_loc2
          answer.thunks[n2..-1] = []
          catch(3) do
            pos4 = @position_offset
            p_loc4 = @position_offset_loc
            if limits && @position_offset == offset && !limits[:evaluate_rule_supported_language]
              if !apply_rule(:evaluate_rule_supported_language, answer.thunks, nil, 0, offset, offset_loc, limits: limits)
                throw(3)
              end
            elsif !apply_rule(:evaluate_rule_supported_language, answer.thunks, nil, 0, offset, offset_loc)
              throw(3)
            end
            q4 = @position_offset
            capt4 = answer.capts[0]
            capt4.range_start = pos4
            capt4.range_end = q4
            q_loc4 = @position_offset_loc
            capt4.start_loc = p_loc4
            capt4.end_loc = q_loc4
            if limits && @position_offset == offset && !limits[:evaluate_rule_opt_spaces_or_comments]
              if !apply_rule(:evaluate_rule_opt_spaces_or_comments, answer.thunks, nil, 0, offset, offset_loc, limits: limits)
                throw(3)
              end
            elsif !apply_rule(:evaluate_rule_opt_spaces_or_comments, answer.thunks, nil, 0, offset, offset_loc)
              throw(3)
            end
            if refill_buffer(2) < 2 ||
               @buffer[@position_offset, 2] != "->"

              throw(3)
            end
            @position_offset_loc = @position_offset_loc.forward(@buffer, @position_offset, 2)
            @position_offset += 2
            if limits && @position_offset == offset && !limits[:evaluate_rule_opt_spaces_or_comments]
              if !apply_rule(:evaluate_rule_opt_spaces_or_comments, answer.thunks, nil, 0, offset, offset_loc, limits: limits)
                throw(3)
              end
            elsif !apply_rule(:evaluate_rule_opt_spaces_or_comments, answer.thunks, nil, 0, offset, offset_loc)
              throw(3)
            end
            if limits && @position_offset == offset && !limits[:evaluate_rule_quotation_double]
              if !apply_rule(:evaluate_rule_quotation_double, answer.thunks, answer.values, 0, offset, offset_loc, limits: limits)
                throw(3)
              end
            elsif !apply_rule(:evaluate_rule_quotation_double, answer.thunks, answer.values, 0, offset, offset_loc)
              throw(3)
            end
            answer.thunks.push(
              ThunkLeaf.new(
                :action_lang_string_1,
                Capture.new(
                  answer.pos, @position_offset,
                  answer.pos_loc, @position_offset_loc,
                ),
                answer.values.slice(0),
                answer.capts.slice(0),
              ),
            )
            throw(1)
          end
          @position_offset = pos2
          @position_offset_loc = p_loc2
          answer.thunks[n2..-1] = []
          throw(0)
        end
        @level -= 1
        debug { warn "#{"  " * @level}MATCH   lang_string #{answer.pos} #{@buffer[answer.pos...@position_offset].inspect}" }
        return answer
      end
      @level -= 1
      debug { warn "#{"  " * @level}NOMATCH lang_string #{answer.pos} #{@buffer[answer.pos...@position_offset].inspect}" }
      nil
    end

    def evaluate_rule_rule(offset, offset_loc, limits: nil)
      answer = ThunkChunk.new
      answer.pos = @position_offset
      answer.pos_loc = @position_offset_loc
      debug { warn "#{"  " * @level}EVAL    rule #{answer.pos} #{@buffer[answer.pos..-1].inspect}" }
      @level += 1
      answer.resize_captures(0)
      answer.values = {}
      catch(0) do
        if limits && @position_offset == offset && !limits[:evaluate_rule_identifier]
          if !apply_rule(:evaluate_rule_identifier, answer.thunks, answer.values, 0, offset, offset_loc, limits: limits)
            throw(0)
          end
        elsif !apply_rule(:evaluate_rule_identifier, answer.thunks, answer.values, 0, offset, offset_loc)
          throw(0)
        end
        if limits && @position_offset == offset && !limits[:evaluate_rule_opt_spaces_or_comments]
          if !apply_rule(:evaluate_rule_opt_spaces_or_comments, answer.thunks, nil, 0, offset, offset_loc, limits: limits)
            throw(0)
          end
        elsif !apply_rule(:evaluate_rule_opt_spaces_or_comments, answer.thunks, nil, 0, offset, offset_loc)
          throw(0)
        end
        if refill_buffer(2) < 2 ||
           @buffer[@position_offset, 2] != "<-"

          throw(0)
        end
        @position_offset_loc = @position_offset_loc.forward(@buffer, @position_offset, 2)
        @position_offset += 2
        if limits && @position_offset == offset && !limits[:evaluate_rule_opt_spaces_or_comments]
          if !apply_rule(:evaluate_rule_opt_spaces_or_comments, answer.thunks, nil, 0, offset, offset_loc, limits: limits)
            throw(0)
          end
        elsif !apply_rule(:evaluate_rule_opt_spaces_or_comments, answer.thunks, nil, 0, offset, offset_loc)
          throw(0)
        end
        if limits && @position_offset == offset && !limits[:evaluate_rule_expression]
          if !apply_rule(:evaluate_rule_expression, answer.thunks, answer.values, 1, offset, offset_loc, limits: limits)
            throw(0)
          end
        elsif !apply_rule(:evaluate_rule_expression, answer.thunks, answer.values, 1, offset, offset_loc)
          throw(0)
        end
        answer.thunks.push(
          ThunkLeaf.new(
            :action_rule_0,
            Capture.new(
              answer.pos, @position_offset,
              answer.pos_loc, @position_offset_loc,
            ),
            answer.values.slice(0, 1),
            {},
          ),
        )
        @level -= 1
        debug { warn "#{"  " * @level}MATCH   rule #{answer.pos} #{@buffer[answer.pos...@position_offset].inspect}" }
        return answer
      end
      @level -= 1
      debug { warn "#{"  " * @level}NOMATCH rule #{answer.pos} #{@buffer[answer.pos...@position_offset].inspect}" }
      nil
    end

    def evaluate_rule_expression(offset, offset_loc, limits: nil)
      answer = ThunkChunk.new
      answer.pos = @position_offset
      answer.pos_loc = @position_offset_loc
      debug { warn "#{"  " * @level}EVAL    expression #{answer.pos} #{@buffer[answer.pos..-1].inspect}" }
      @level += 1
      answer.resize_captures(0)
      answer.values = {}
      catch(0) do
        catch(1) do
          pos2 = @position_offset
          p_loc2 = @position_offset_loc
          n2 = answer.thunks.length
          catch(2) do
            if limits && @position_offset == offset && !limits[:evaluate_rule_expression]
              if !apply_rule(:evaluate_rule_expression, answer.thunks, answer.values, 0, offset, offset_loc, limits: limits)
                throw(2)
              end
            elsif !apply_rule(:evaluate_rule_expression, answer.thunks, answer.values, 0, offset, offset_loc)
              throw(2)
            end
            if limits && @position_offset == offset && !limits[:evaluate_rule_opt_spaces_or_comments]
              if !apply_rule(:evaluate_rule_opt_spaces_or_comments, answer.thunks, nil, 0, offset, offset_loc, limits: limits)
                throw(2)
              end
            elsif !apply_rule(:evaluate_rule_opt_spaces_or_comments, answer.thunks, nil, 0, offset, offset_loc)
              throw(2)
            end
            if refill_buffer(1) < 1 ||
               @buffer[@position_offset] != "/"

              throw(2)
            end
            @position_offset_loc = @position_offset_loc.forward(@buffer, @position_offset, 1)
            @position_offset += 1
            if limits && @position_offset == offset && !limits[:evaluate_rule_opt_spaces_or_comments]
              if !apply_rule(:evaluate_rule_opt_spaces_or_comments, answer.thunks, nil, 0, offset, offset_loc, limits: limits)
                throw(0)
              end
            elsif !apply_rule(:evaluate_rule_opt_spaces_or_comments, answer.thunks, nil, 0, offset, offset_loc)
              throw(0)
            end
            if limits && @position_offset == offset && !limits[:evaluate_rule_sequence]
              if !apply_rule(:evaluate_rule_sequence, answer.thunks, answer.values, 1, offset, offset_loc, limits: limits)
                throw(0)
              end
            elsif !apply_rule(:evaluate_rule_sequence, answer.thunks, answer.values, 1, offset, offset_loc)
              throw(0)
            end
            answer.thunks.push(
              ThunkLeaf.new(
                :action_expression_0,
                Capture.new(
                  answer.pos, @position_offset,
                  answer.pos_loc, @position_offset_loc,
                ),
                answer.values.slice(0, 1),
                {},
              ),
            )
            throw(1)
          end
          @position_offset = pos2
          @position_offset_loc = p_loc2
          answer.thunks[n2..-1] = []
          catch(3) do
            if limits && @position_offset == offset && !limits[:evaluate_rule_sequence]
              if !apply_rule(:evaluate_rule_sequence, answer.thunks, answer.values, 1, offset, offset_loc, limits: limits)
                throw(3)
              end
            elsif !apply_rule(:evaluate_rule_sequence, answer.thunks, answer.values, 1, offset, offset_loc)
              throw(3)
            end
            answer.thunks.push(
              ThunkLeaf.new(
                :action_expression_1,
                Capture.new(
                  answer.pos, @position_offset,
                  answer.pos_loc, @position_offset_loc,
                ),
                answer.values.slice(1),
                {},
              ),
            )
            throw(1)
          end
          @position_offset = pos2
          @position_offset_loc = p_loc2
          answer.thunks[n2..-1] = []
          throw(0)
        end
        @level -= 1
        debug { warn "#{"  " * @level}MATCH   expression #{answer.pos} #{@buffer[answer.pos...@position_offset].inspect}" }
        return answer
      end
      @level -= 1
      debug { warn "#{"  " * @level}NOMATCH expression #{answer.pos} #{@buffer[answer.pos...@position_offset].inspect}" }
      nil
    end

    def evaluate_rule_sequence(offset, offset_loc, limits: nil)
      answer = ThunkChunk.new
      answer.pos = @position_offset
      answer.pos_loc = @position_offset_loc
      debug { warn "#{"  " * @level}EVAL    sequence #{answer.pos} #{@buffer[answer.pos..-1].inspect}" }
      @level += 1
      answer.resize_captures(0)
      answer.values = {}
      catch(0) do
        catch(1) do
          pos2 = @position_offset
          p_loc2 = @position_offset_loc
          n2 = answer.thunks.length
          catch(2) do
            if limits && @position_offset == offset && !limits[:evaluate_rule_sequence]
              if !apply_rule(:evaluate_rule_sequence, answer.thunks, answer.values, 0, offset, offset_loc, limits: limits)
                throw(2)
              end
            elsif !apply_rule(:evaluate_rule_sequence, answer.thunks, answer.values, 0, offset, offset_loc)
              throw(2)
            end
            if limits && @position_offset == offset && !limits[:evaluate_rule_opt_spaces_or_comments]
              if !apply_rule(:evaluate_rule_opt_spaces_or_comments, answer.thunks, nil, 0, offset, offset_loc, limits: limits)
                throw(2)
              end
            elsif !apply_rule(:evaluate_rule_opt_spaces_or_comments, answer.thunks, nil, 0, offset, offset_loc)
              throw(2)
            end
            if refill_buffer(2) < 2 ||
               @buffer[@position_offset, 2] != "8<"

              throw(2)
            end
            @position_offset_loc = @position_offset_loc.forward(@buffer, @position_offset, 2)
            @position_offset += 2
            if limits && @position_offset == offset && !limits[:evaluate_rule_opt_spaces_or_comments]
              if !apply_rule(:evaluate_rule_opt_spaces_or_comments, answer.thunks, nil, 0, offset, offset_loc, limits: limits)
                throw(0)
              end
            elsif !apply_rule(:evaluate_rule_opt_spaces_or_comments, answer.thunks, nil, 0, offset, offset_loc)
              throw(0)
            end
            if limits && @position_offset == offset && !limits[:evaluate_rule_term]
              if !apply_rule(:evaluate_rule_term, answer.thunks, answer.values, 1, offset, offset_loc, limits: limits)
                throw(0)
              end
            elsif !apply_rule(:evaluate_rule_term, answer.thunks, answer.values, 1, offset, offset_loc)
              throw(0)
            end
            answer.thunks.push(
              ThunkLeaf.new(
                :action_sequence_0,
                Capture.new(
                  answer.pos, @position_offset,
                  answer.pos_loc, @position_offset_loc,
                ),
                answer.values.slice(0, 1),
                {},
              ),
            )
            throw(1)
          end
          @position_offset = pos2
          @position_offset_loc = p_loc2
          answer.thunks[n2..-1] = []
          catch(3) do
            if limits && @position_offset == offset && !limits[:evaluate_rule_sequence]
              if !apply_rule(:evaluate_rule_sequence, answer.thunks, answer.values, 0, offset, offset_loc, limits: limits)
                throw(3)
              end
            elsif !apply_rule(:evaluate_rule_sequence, answer.thunks, answer.values, 0, offset, offset_loc)
              throw(3)
            end
            if limits && @position_offset == offset && !limits[:evaluate_rule_opt_spaces_or_comments]
              if !apply_rule(:evaluate_rule_opt_spaces_or_comments, answer.thunks, nil, 0, offset, offset_loc, limits: limits)
                throw(3)
              end
            elsif !apply_rule(:evaluate_rule_opt_spaces_or_comments, answer.thunks, nil, 0, offset, offset_loc)
              throw(3)
            end
            if refill_buffer(1) < 1 ||
               @buffer[@position_offset] != "~"

              throw(3)
            end
            @position_offset_loc = @position_offset_loc.forward(@buffer, @position_offset, 1)
            @position_offset += 1
            if limits && @position_offset == offset && !limits[:evaluate_rule_opt_spaces_or_comments]
              if !apply_rule(:evaluate_rule_opt_spaces_or_comments, answer.thunks, nil, 0, offset, offset_loc, limits: limits)
                throw(0)
              end
            elsif !apply_rule(:evaluate_rule_opt_spaces_or_comments, answer.thunks, nil, 0, offset, offset_loc)
              throw(0)
            end
            if limits && @position_offset == offset && !limits[:evaluate_rule_lang_code_block]
              if !apply_rule(:evaluate_rule_lang_code_block, answer.thunks, answer.values, 2, offset, offset_loc, limits: limits)
                throw(0)
              end
            elsif !apply_rule(:evaluate_rule_lang_code_block, answer.thunks, answer.values, 2, offset, offset_loc)
              throw(0)
            end
            answer.thunks.push(
              ThunkLeaf.new(
                :action_sequence_1,
                Capture.new(
                  answer.pos, @position_offset,
                  answer.pos_loc, @position_offset_loc,
                ),
                answer.values.slice(0, 2),
                {},
              ),
            )
            throw(1)
          end
          @position_offset = pos2
          @position_offset_loc = p_loc2
          answer.thunks[n2..-1] = []
          catch(4) do
            if limits && @position_offset == offset && !limits[:evaluate_rule_sequence]
              if !apply_rule(:evaluate_rule_sequence, answer.thunks, answer.values, 0, offset, offset_loc, limits: limits)
                throw(4)
              end
            elsif !apply_rule(:evaluate_rule_sequence, answer.thunks, answer.values, 0, offset, offset_loc)
              throw(4)
            end
            if limits && @position_offset == offset && !limits[:evaluate_rule_opt_spaces_or_comments]
              if !apply_rule(:evaluate_rule_opt_spaces_or_comments, answer.thunks, nil, 0, offset, offset_loc, limits: limits)
                throw(4)
              end
            elsif !apply_rule(:evaluate_rule_opt_spaces_or_comments, answer.thunks, nil, 0, offset, offset_loc)
              throw(4)
            end
            if limits && @position_offset == offset && !limits[:evaluate_rule_term]
              if !apply_rule(:evaluate_rule_term, answer.thunks, answer.values, 1, offset, offset_loc, limits: limits)
                throw(4)
              end
            elsif !apply_rule(:evaluate_rule_term, answer.thunks, answer.values, 1, offset, offset_loc)
              throw(4)
            end
            answer.thunks.push(
              ThunkLeaf.new(
                :action_sequence_2,
                Capture.new(
                  answer.pos, @position_offset,
                  answer.pos_loc, @position_offset_loc,
                ),
                answer.values.slice(0, 1),
                {},
              ),
            )
            throw(1)
          end
          @position_offset = pos2
          @position_offset_loc = p_loc2
          answer.thunks[n2..-1] = []
          catch(5) do
            if limits && @position_offset == offset && !limits[:evaluate_rule_term]
              if !apply_rule(:evaluate_rule_term, answer.thunks, answer.values, 1, offset, offset_loc, limits: limits)
                throw(5)
              end
            elsif !apply_rule(:evaluate_rule_term, answer.thunks, answer.values, 1, offset, offset_loc)
              throw(5)
            end
            answer.thunks.push(
              ThunkLeaf.new(
                :action_sequence_3,
                Capture.new(
                  answer.pos, @position_offset,
                  answer.pos_loc, @position_offset_loc,
                ),
                answer.values.slice(1),
                {},
              ),
            )
            throw(1)
          end
          @position_offset = pos2
          @position_offset_loc = p_loc2
          answer.thunks[n2..-1] = []
          throw(0)
        end
        @level -= 1
        debug { warn "#{"  " * @level}MATCH   sequence #{answer.pos} #{@buffer[answer.pos...@position_offset].inspect}" }
        return answer
      end
      @level -= 1
      debug { warn "#{"  " * @level}NOMATCH sequence #{answer.pos} #{@buffer[answer.pos...@position_offset].inspect}" }
      nil
    end

    def evaluate_rule_term(offset, offset_loc, limits: nil)
      answer = ThunkChunk.new
      answer.pos = @position_offset
      answer.pos_loc = @position_offset_loc
      debug { warn "#{"  " * @level}EVAL    term #{answer.pos} #{@buffer[answer.pos..-1].inspect}" }
      @level += 1
      answer.resize_captures(0)
      answer.values = {}
      catch(0) do
        catch(1) do
          pos2 = @position_offset
          p_loc2 = @position_offset_loc
          n2 = answer.thunks.length
          catch(2) do
            if refill_buffer(1) < 1 ||
               @buffer[@position_offset] != "&"

              throw(2)
            end
            @position_offset_loc = @position_offset_loc.forward(@buffer, @position_offset, 1)
            @position_offset += 1
            if limits && @position_offset == offset && !limits[:evaluate_rule_opt_spaces_or_comments]
              if !apply_rule(:evaluate_rule_opt_spaces_or_comments, answer.thunks, nil, 0, offset, offset_loc, limits: limits)
                throw(0)
              end
            elsif !apply_rule(:evaluate_rule_opt_spaces_or_comments, answer.thunks, nil, 0, offset, offset_loc)
              throw(0)
            end
            if limits && @position_offset == offset && !limits[:evaluate_rule_quantity]
              if !apply_rule(:evaluate_rule_quantity, answer.thunks, answer.values, 0, offset, offset_loc, limits: limits)
                throw(0)
              end
            elsif !apply_rule(:evaluate_rule_quantity, answer.thunks, answer.values, 0, offset, offset_loc)
              throw(0)
            end
            answer.thunks.push(
              ThunkLeaf.new(
                :action_term_0,
                Capture.new(
                  answer.pos, @position_offset,
                  answer.pos_loc, @position_offset_loc,
                ),
                answer.values.slice(0),
                {},
              ),
            )
            throw(1)
          end
          @position_offset = pos2
          @position_offset_loc = p_loc2
          answer.thunks[n2..-1] = []
          catch(3) do
            if refill_buffer(1) < 1 ||
               @buffer[@position_offset] != "!"

              throw(3)
            end
            @position_offset_loc = @position_offset_loc.forward(@buffer, @position_offset, 1)
            @position_offset += 1
            if limits && @position_offset == offset && !limits[:evaluate_rule_opt_spaces_or_comments]
              if !apply_rule(:evaluate_rule_opt_spaces_or_comments, answer.thunks, nil, 0, offset, offset_loc, limits: limits)
                throw(0)
              end
            elsif !apply_rule(:evaluate_rule_opt_spaces_or_comments, answer.thunks, nil, 0, offset, offset_loc)
              throw(0)
            end
            if limits && @position_offset == offset && !limits[:evaluate_rule_quantity]
              if !apply_rule(:evaluate_rule_quantity, answer.thunks, answer.values, 0, offset, offset_loc, limits: limits)
                throw(0)
              end
            elsif !apply_rule(:evaluate_rule_quantity, answer.thunks, answer.values, 0, offset, offset_loc)
              throw(0)
            end
            answer.thunks.push(
              ThunkLeaf.new(
                :action_term_1,
                Capture.new(
                  answer.pos, @position_offset,
                  answer.pos_loc, @position_offset_loc,
                ),
                answer.values.slice(0),
                {},
              ),
            )
            throw(1)
          end
          @position_offset = pos2
          @position_offset_loc = p_loc2
          answer.thunks[n2..-1] = []
          catch(4) do
            if limits && @position_offset == offset && !limits[:evaluate_rule_quantity]
              if !apply_rule(:evaluate_rule_quantity, answer.thunks, answer.values, 0, offset, offset_loc, limits: limits)
                throw(4)
              end
            elsif !apply_rule(:evaluate_rule_quantity, answer.thunks, answer.values, 0, offset, offset_loc)
              throw(4)
            end
            answer.thunks.push(
              ThunkLeaf.new(
                :action_term_2,
                Capture.new(
                  answer.pos, @position_offset,
                  answer.pos_loc, @position_offset_loc,
                ),
                answer.values.slice(0),
                {},
              ),
            )
            throw(1)
          end
          @position_offset = pos2
          @position_offset_loc = p_loc2
          answer.thunks[n2..-1] = []
          throw(0)
        end
        @level -= 1
        debug { warn "#{"  " * @level}MATCH   term #{answer.pos} #{@buffer[answer.pos...@position_offset].inspect}" }
        return answer
      end
      @level -= 1
      debug { warn "#{"  " * @level}NOMATCH term #{answer.pos} #{@buffer[answer.pos...@position_offset].inspect}" }
      nil
    end

    def evaluate_rule_quantity(offset, offset_loc, limits: nil)
      answer = ThunkChunk.new
      answer.pos = @position_offset
      answer.pos_loc = @position_offset_loc
      debug { warn "#{"  " * @level}EVAL    quantity #{answer.pos} #{@buffer[answer.pos..-1].inspect}" }
      @level += 1
      answer.resize_captures(0)
      answer.values = {}
      catch(0) do
        catch(1) do
          pos2 = @position_offset
          p_loc2 = @position_offset_loc
          n2 = answer.thunks.length
          catch(2) do
            if limits && @position_offset == offset && !limits[:evaluate_rule_primary]
              if !apply_rule(:evaluate_rule_primary, answer.thunks, answer.values, 0, offset, offset_loc, limits: limits)
                throw(2)
              end
            elsif !apply_rule(:evaluate_rule_primary, answer.thunks, answer.values, 0, offset, offset_loc)
              throw(2)
            end
            if limits && @position_offset == offset && !limits[:evaluate_rule_opt_spaces_or_comments]
              if !apply_rule(:evaluate_rule_opt_spaces_or_comments, answer.thunks, nil, 0, offset, offset_loc, limits: limits)
                throw(2)
              end
            elsif !apply_rule(:evaluate_rule_opt_spaces_or_comments, answer.thunks, nil, 0, offset, offset_loc)
              throw(2)
            end
            if refill_buffer(1) < 1 ||
               @buffer[@position_offset] != "*"

              throw(2)
            end
            @position_offset_loc = @position_offset_loc.forward(@buffer, @position_offset, 1)
            @position_offset += 1
            answer.thunks.push(
              ThunkLeaf.new(
                :action_quantity_0,
                Capture.new(
                  answer.pos, @position_offset,
                  answer.pos_loc, @position_offset_loc,
                ),
                answer.values.slice(0),
                {},
              ),
            )
            throw(1)
          end
          @position_offset = pos2
          @position_offset_loc = p_loc2
          answer.thunks[n2..-1] = []
          catch(3) do
            if limits && @position_offset == offset && !limits[:evaluate_rule_primary]
              if !apply_rule(:evaluate_rule_primary, answer.thunks, answer.values, 0, offset, offset_loc, limits: limits)
                throw(3)
              end
            elsif !apply_rule(:evaluate_rule_primary, answer.thunks, answer.values, 0, offset, offset_loc)
              throw(3)
            end
            if limits && @position_offset == offset && !limits[:evaluate_rule_opt_spaces_or_comments]
              if !apply_rule(:evaluate_rule_opt_spaces_or_comments, answer.thunks, nil, 0, offset, offset_loc, limits: limits)
                throw(3)
              end
            elsif !apply_rule(:evaluate_rule_opt_spaces_or_comments, answer.thunks, nil, 0, offset, offset_loc)
              throw(3)
            end
            if refill_buffer(1) < 1 ||
               @buffer[@position_offset] != "+"

              throw(3)
            end
            @position_offset_loc = @position_offset_loc.forward(@buffer, @position_offset, 1)
            @position_offset += 1
            answer.thunks.push(
              ThunkLeaf.new(
                :action_quantity_1,
                Capture.new(
                  answer.pos, @position_offset,
                  answer.pos_loc, @position_offset_loc,
                ),
                answer.values.slice(0),
                {},
              ),
            )
            throw(1)
          end
          @position_offset = pos2
          @position_offset_loc = p_loc2
          answer.thunks[n2..-1] = []
          catch(4) do
            if limits && @position_offset == offset && !limits[:evaluate_rule_primary]
              if !apply_rule(:evaluate_rule_primary, answer.thunks, answer.values, 0, offset, offset_loc, limits: limits)
                throw(4)
              end
            elsif !apply_rule(:evaluate_rule_primary, answer.thunks, answer.values, 0, offset, offset_loc)
              throw(4)
            end
            if limits && @position_offset == offset && !limits[:evaluate_rule_opt_spaces_or_comments]
              if !apply_rule(:evaluate_rule_opt_spaces_or_comments, answer.thunks, nil, 0, offset, offset_loc, limits: limits)
                throw(4)
              end
            elsif !apply_rule(:evaluate_rule_opt_spaces_or_comments, answer.thunks, nil, 0, offset, offset_loc)
              throw(4)
            end
            if refill_buffer(1) < 1 ||
               @buffer[@position_offset] != "?"

              throw(4)
            end
            @position_offset_loc = @position_offset_loc.forward(@buffer, @position_offset, 1)
            @position_offset += 1
            answer.thunks.push(
              ThunkLeaf.new(
                :action_quantity_2,
                Capture.new(
                  answer.pos, @position_offset,
                  answer.pos_loc, @position_offset_loc,
                ),
                answer.values.slice(0),
                {},
              ),
            )
            throw(1)
          end
          @position_offset = pos2
          @position_offset_loc = p_loc2
          answer.thunks[n2..-1] = []
          catch(5) do
            if limits && @position_offset == offset && !limits[:evaluate_rule_primary]
              if !apply_rule(:evaluate_rule_primary, answer.thunks, answer.values, 0, offset, offset_loc, limits: limits)
                throw(5)
              end
            elsif !apply_rule(:evaluate_rule_primary, answer.thunks, answer.values, 0, offset, offset_loc)
              throw(5)
            end
            answer.thunks.push(
              ThunkLeaf.new(
                :action_quantity_3,
                Capture.new(
                  answer.pos, @position_offset,
                  answer.pos_loc, @position_offset_loc,
                ),
                answer.values.slice(0),
                {},
              ),
            )
            throw(1)
          end
          @position_offset = pos2
          @position_offset_loc = p_loc2
          answer.thunks[n2..-1] = []
          throw(0)
        end
        @level -= 1
        debug { warn "#{"  " * @level}MATCH   quantity #{answer.pos} #{@buffer[answer.pos...@position_offset].inspect}" }
        return answer
      end
      @level -= 1
      debug { warn "#{"  " * @level}NOMATCH quantity #{answer.pos} #{@buffer[answer.pos...@position_offset].inspect}" }
      nil
    end

    def evaluate_rule_primary(offset, offset_loc, limits: nil)
      answer = ThunkChunk.new
      answer.pos = @position_offset
      answer.pos_loc = @position_offset_loc
      debug { warn "#{"  " * @level}EVAL    primary #{answer.pos} #{@buffer[answer.pos..-1].inspect}" }
      @level += 1
      answer.resize_captures(1)
      answer.values = {}
      catch(0) do
        catch(1) do
          pos2 = @position_offset
          p_loc2 = @position_offset_loc
          n2 = answer.thunks.length
          catch(2) do
            if limits && @position_offset == offset && !limits[:evaluate_rule_lang_code_block]
              if !apply_rule(:evaluate_rule_lang_code_block, answer.thunks, answer.values, 0, offset, offset_loc, limits: limits)
                throw(2)
              end
            elsif !apply_rule(:evaluate_rule_lang_code_block, answer.thunks, answer.values, 0, offset, offset_loc)
              throw(2)
            end
            answer.thunks.push(
              ThunkLeaf.new(
                :action_primary_0,
                Capture.new(
                  answer.pos, @position_offset,
                  answer.pos_loc, @position_offset_loc,
                ),
                answer.values.slice(0),
                {},
              ),
            )
            throw(1)
          end
          @position_offset = pos2
          @position_offset_loc = p_loc2
          answer.thunks[n2..-1] = []
          catch(3) do
            if limits && @position_offset == offset && !limits[:evaluate_rule_identifier]
              if !apply_rule(:evaluate_rule_identifier, answer.thunks, answer.values, 1, offset, offset_loc, limits: limits)
                throw(3)
              end
            elsif !apply_rule(:evaluate_rule_identifier, answer.thunks, answer.values, 1, offset, offset_loc)
              throw(3)
            end
            if limits && @position_offset == offset && !limits[:evaluate_rule_opt_spaces_or_comments]
              if !apply_rule(:evaluate_rule_opt_spaces_or_comments, answer.thunks, nil, 0, offset, offset_loc, limits: limits)
                throw(3)
              end
            elsif !apply_rule(:evaluate_rule_opt_spaces_or_comments, answer.thunks, nil, 0, offset, offset_loc)
              throw(3)
            end
            if refill_buffer(1) < 1 ||
               @buffer[@position_offset] != ":"

              throw(3)
            end
            @position_offset_loc = @position_offset_loc.forward(@buffer, @position_offset, 1)
            @position_offset += 1
            if limits && @position_offset == offset && !limits[:evaluate_rule_opt_spaces_or_comments]
              if !apply_rule(:evaluate_rule_opt_spaces_or_comments, answer.thunks, nil, 0, offset, offset_loc, limits: limits)
                throw(0)
              end
            elsif !apply_rule(:evaluate_rule_opt_spaces_or_comments, answer.thunks, nil, 0, offset, offset_loc)
              throw(0)
            end
            if limits && @position_offset == offset && !limits[:evaluate_rule_identifier]
              if !apply_rule(:evaluate_rule_identifier, answer.thunks, answer.values, 2, offset, offset_loc, limits: limits)
                throw(0)
              end
            elsif !apply_rule(:evaluate_rule_identifier, answer.thunks, answer.values, 2, offset, offset_loc)
              throw(0)
            end
            pos5 = @position_offset
            p_loc5 = @position_offset_loc
            catch(4) do
              i7 = 0
              pos7 = nil
              p_loc7 = nil
              n7 = nil
              catch(5) do
                pos7 = @position_offset
                p_loc7 = @position_offset_loc
                n7 = answer.thunks.length
                if refill_buffer(1) < 1
                  throw(5)
                end
                u8 = @buffer[@position_offset]
                if !
                  [" ", "\t", "\v", "\f", "\r", "\n"].include?(u8)

                  throw(5)
                end
                @position_offset_loc = @position_offset_loc.forward(@buffer, @position_offset, 1)
                @position_offset += 1
                i7 += 1
                if @position_offset != pos7
                  redo
                end
                pos7 = nil
              end
              if pos7
                @position_offset = pos7
                @position_offset_loc = p_loc7
                answer.thunks[n7..-1] = []
              end
              if refill_buffer(2) < 2 ||
                 @buffer[@position_offset, 2] != "<-"

                throw(4)
              end
              @position_offset_loc = @position_offset_loc.forward(@buffer, @position_offset, 2)
              @position_offset += 2
              @position_offset = pos5
              @position_offset_loc = p_loc5
              throw(0)
            end
            @position_offset = pos5
            @position_offset_loc = p_loc5
            answer.thunks.push(
              ThunkLeaf.new(
                :action_primary_1,
                Capture.new(
                  answer.pos, @position_offset,
                  answer.pos_loc, @position_offset_loc,
                ),
                answer.values.slice(1, 2),
                {},
              ),
            )
            throw(1)
          end
          @position_offset = pos2
          @position_offset_loc = p_loc2
          answer.thunks[n2..-1] = []
          catch(6) do
            if refill_buffer(2) < 2 ||
               @buffer[@position_offset, 2] != "$$"

              throw(6)
            end
            @position_offset_loc = @position_offset_loc.forward(@buffer, @position_offset, 2)
            @position_offset += 2
            if limits && @position_offset == offset && !limits[:evaluate_rule_opt_spaces_or_comments]
              if !apply_rule(:evaluate_rule_opt_spaces_or_comments, answer.thunks, nil, 0, offset, offset_loc, limits: limits)
                throw(6)
              end
            elsif !apply_rule(:evaluate_rule_opt_spaces_or_comments, answer.thunks, nil, 0, offset, offset_loc)
              throw(6)
            end
            if refill_buffer(1) < 1 ||
               @buffer[@position_offset] != ":"

              throw(6)
            end
            @position_offset_loc = @position_offset_loc.forward(@buffer, @position_offset, 1)
            @position_offset += 1
            if limits && @position_offset == offset && !limits[:evaluate_rule_opt_spaces_or_comments]
              if !apply_rule(:evaluate_rule_opt_spaces_or_comments, answer.thunks, nil, 0, offset, offset_loc, limits: limits)
                throw(0)
              end
            elsif !apply_rule(:evaluate_rule_opt_spaces_or_comments, answer.thunks, nil, 0, offset, offset_loc)
              throw(0)
            end
            if limits && @position_offset == offset && !limits[:evaluate_rule_identifier]
              if !apply_rule(:evaluate_rule_identifier, answer.thunks, answer.values, 2, offset, offset_loc, limits: limits)
                throw(0)
              end
            elsif !apply_rule(:evaluate_rule_identifier, answer.thunks, answer.values, 2, offset, offset_loc)
              throw(0)
            end
            pos5 = @position_offset
            p_loc5 = @position_offset_loc
            catch(7) do
              i7 = 0
              pos7 = nil
              p_loc7 = nil
              n7 = nil
              catch(8) do
                pos7 = @position_offset
                p_loc7 = @position_offset_loc
                n7 = answer.thunks.length
                if refill_buffer(1) < 1
                  throw(8)
                end
                u8 = @buffer[@position_offset]
                if !
                  [" ", "\t", "\v", "\f", "\r", "\n"].include?(u8)

                  throw(8)
                end
                @position_offset_loc = @position_offset_loc.forward(@buffer, @position_offset, 1)
                @position_offset += 1
                i7 += 1
                if @position_offset != pos7
                  redo
                end
                pos7 = nil
              end
              if pos7
                @position_offset = pos7
                @position_offset_loc = p_loc7
                answer.thunks[n7..-1] = []
              end
              if refill_buffer(2) < 2 ||
                 @buffer[@position_offset, 2] != "<-"

                throw(7)
              end
              @position_offset_loc = @position_offset_loc.forward(@buffer, @position_offset, 2)
              @position_offset += 2
              @position_offset = pos5
              @position_offset_loc = p_loc5
              throw(0)
            end
            @position_offset = pos5
            @position_offset_loc = p_loc5
            answer.thunks.push(
              ThunkLeaf.new(
                :action_primary_2,
                Capture.new(
                  answer.pos, @position_offset,
                  answer.pos_loc, @position_offset_loc,
                ),
                answer.values.slice(2),
                {},
              ),
            )
            throw(1)
          end
          @position_offset = pos2
          @position_offset_loc = p_loc2
          answer.thunks[n2..-1] = []
          catch(9) do
            if limits && @position_offset == offset && !limits[:evaluate_rule_identifier]
              if !apply_rule(:evaluate_rule_identifier, answer.thunks, answer.values, 2, offset, offset_loc, limits: limits)
                throw(9)
              end
            elsif !apply_rule(:evaluate_rule_identifier, answer.thunks, answer.values, 2, offset, offset_loc)
              throw(9)
            end
            pos5 = @position_offset
            p_loc5 = @position_offset_loc
            catch(10) do
              i7 = 0
              pos7 = nil
              p_loc7 = nil
              n7 = nil
              catch(11) do
                pos7 = @position_offset
                p_loc7 = @position_offset_loc
                n7 = answer.thunks.length
                if refill_buffer(1) < 1
                  throw(11)
                end
                u8 = @buffer[@position_offset]
                if !
                  [" ", "\t", "\v", "\f", "\r", "\n"].include?(u8)

                  throw(11)
                end
                @position_offset_loc = @position_offset_loc.forward(@buffer, @position_offset, 1)
                @position_offset += 1
                i7 += 1
                if @position_offset != pos7
                  redo
                end
                pos7 = nil
              end
              if pos7
                @position_offset = pos7
                @position_offset_loc = p_loc7
                answer.thunks[n7..-1] = []
              end
              if refill_buffer(2) < 2 ||
                 @buffer[@position_offset, 2] != "<-"

                throw(10)
              end
              @position_offset_loc = @position_offset_loc.forward(@buffer, @position_offset, 2)
              @position_offset += 2
              @position_offset = pos5
              @position_offset_loc = p_loc5
              throw(0)
            end
            @position_offset = pos5
            @position_offset_loc = p_loc5
            answer.thunks.push(
              ThunkLeaf.new(
                :action_primary_3,
                Capture.new(
                  answer.pos, @position_offset,
                  answer.pos_loc, @position_offset_loc,
                ),
                answer.values.slice(2),
                {},
              ),
            )
            throw(1)
          end
          @position_offset = pos2
          @position_offset_loc = p_loc2
          answer.thunks[n2..-1] = []
          catch(12) do
            if refill_buffer(1) < 1 ||
               @buffer[@position_offset] != "("

              throw(12)
            end
            @position_offset_loc = @position_offset_loc.forward(@buffer, @position_offset, 1)
            @position_offset += 1
            if limits && @position_offset == offset && !limits[:evaluate_rule_opt_spaces_or_comments]
              if !apply_rule(:evaluate_rule_opt_spaces_or_comments, answer.thunks, nil, 0, offset, offset_loc, limits: limits)
                throw(0)
              end
            elsif !apply_rule(:evaluate_rule_opt_spaces_or_comments, answer.thunks, nil, 0, offset, offset_loc)
              throw(0)
            end
            if limits && @position_offset == offset && !limits[:evaluate_rule_expression]
              if !apply_rule(:evaluate_rule_expression, answer.thunks, answer.values, 3, offset, offset_loc, limits: limits)
                throw(0)
              end
            elsif !apply_rule(:evaluate_rule_expression, answer.thunks, answer.values, 3, offset, offset_loc)
              throw(0)
            end
            if limits && @position_offset == offset && !limits[:evaluate_rule_opt_spaces_or_comments]
              if !apply_rule(:evaluate_rule_opt_spaces_or_comments, answer.thunks, nil, 0, offset, offset_loc, limits: limits)
                throw(0)
              end
            elsif !apply_rule(:evaluate_rule_opt_spaces_or_comments, answer.thunks, nil, 0, offset, offset_loc)
              throw(0)
            end
            if refill_buffer(1) < 1 ||
               @buffer[@position_offset] != ")"

              throw(0)
            end
            @position_offset_loc = @position_offset_loc.forward(@buffer, @position_offset, 1)
            @position_offset += 1
            answer.thunks.push(
              ThunkLeaf.new(
                :action_primary_4,
                Capture.new(
                  answer.pos, @position_offset,
                  answer.pos_loc, @position_offset_loc,
                ),
                answer.values.slice(3),
                {},
              ),
            )
            throw(1)
          end
          @position_offset = pos2
          @position_offset_loc = p_loc2
          answer.thunks[n2..-1] = []
          catch(13) do
            if refill_buffer(1) < 1 ||
               @buffer[@position_offset] != "<"

              throw(13)
            end
            @position_offset_loc = @position_offset_loc.forward(@buffer, @position_offset, 1)
            @position_offset += 1
            if limits && @position_offset == offset && !limits[:evaluate_rule_opt_spaces_or_comments]
              if !apply_rule(:evaluate_rule_opt_spaces_or_comments, answer.thunks, nil, 0, offset, offset_loc, limits: limits)
                throw(0)
              end
            elsif !apply_rule(:evaluate_rule_opt_spaces_or_comments, answer.thunks, nil, 0, offset, offset_loc)
              throw(0)
            end
            if limits && @position_offset == offset && !limits[:evaluate_rule_expression]
              if !apply_rule(:evaluate_rule_expression, answer.thunks, answer.values, 3, offset, offset_loc, limits: limits)
                throw(0)
              end
            elsif !apply_rule(:evaluate_rule_expression, answer.thunks, answer.values, 3, offset, offset_loc)
              throw(0)
            end
            if limits && @position_offset == offset && !limits[:evaluate_rule_opt_spaces_or_comments]
              if !apply_rule(:evaluate_rule_opt_spaces_or_comments, answer.thunks, nil, 0, offset, offset_loc, limits: limits)
                throw(0)
              end
            elsif !apply_rule(:evaluate_rule_opt_spaces_or_comments, answer.thunks, nil, 0, offset, offset_loc)
              throw(0)
            end
            if refill_buffer(1) < 1 ||
               @buffer[@position_offset] != ">"

              throw(0)
            end
            @position_offset_loc = @position_offset_loc.forward(@buffer, @position_offset, 1)
            @position_offset += 1
            answer.thunks.push(
              ThunkLeaf.new(
                :action_primary_5,
                Capture.new(
                  answer.pos, @position_offset,
                  answer.pos_loc, @position_offset_loc,
                ),
                answer.values.slice(3),
                {},
              ),
            )
            throw(1)
          end
          @position_offset = pos2
          @position_offset_loc = p_loc2
          answer.thunks[n2..-1] = []
          catch(14) do
            if refill_buffer(1) < 1 ||
               @buffer[@position_offset] != "$"

              throw(14)
            end
            @position_offset_loc = @position_offset_loc.forward(@buffer, @position_offset, 1)
            @position_offset += 1
            pos4 = @position_offset
            p_loc4 = @position_offset_loc
            if refill_buffer(1) < 1
              throw(14)
            end
            u6 = @buffer[@position_offset]
            if !(
              (u6 >= "1" && u6 <= "9")
            )
              throw(14)
            end
            @position_offset_loc = @position_offset_loc.forward(@buffer, @position_offset, 1)
            @position_offset += 1
            i6 = 0
            pos6 = nil
            p_loc6 = nil
            n6 = nil
            catch(15) do
              pos6 = @position_offset
              p_loc6 = @position_offset_loc
              n6 = answer.thunks.length
              if refill_buffer(1) < 1
                throw(15)
              end
              u7 = @buffer[@position_offset]
              if !(
                (u7 >= "0" && u7 <= "9")
              )
                throw(15)
              end
              @position_offset_loc = @position_offset_loc.forward(@buffer, @position_offset, 1)
              @position_offset += 1
              i6 += 1
              if @position_offset != pos6
                redo
              end
              pos6 = nil
            end
            if pos6
              @position_offset = pos6
              @position_offset_loc = p_loc6
              answer.thunks[n6..-1] = []
            end
            q4 = @position_offset
            capt4 = answer.capts[0]
            capt4.range_start = pos4
            capt4.range_end = q4
            q_loc4 = @position_offset_loc
            capt4.start_loc = p_loc4
            capt4.end_loc = q_loc4
            answer.thunks.push(
              ThunkLeaf.new(
                :action_primary_6,
                Capture.new(
                  answer.pos, @position_offset,
                  answer.pos_loc, @position_offset_loc,
                ),
                {},
                answer.capts.slice(0),
              ),
            )
            throw(1)
          end
          @position_offset = pos2
          @position_offset_loc = p_loc2
          answer.thunks[n2..-1] = []
          catch(16) do
            if refill_buffer(1) < 1 ||
               @buffer[@position_offset] != "."

              throw(16)
            end
            @position_offset_loc = @position_offset_loc.forward(@buffer, @position_offset, 1)
            @position_offset += 1
            answer.thunks.push(
              ThunkLeaf.new(
                :action_primary_7,
                Capture.new(
                  answer.pos, @position_offset,
                  answer.pos_loc, @position_offset_loc,
                ),
                {},
                {},
              ),
            )
            throw(1)
          end
          @position_offset = pos2
          @position_offset_loc = p_loc2
          answer.thunks[n2..-1] = []
          catch(17) do
            if limits && @position_offset == offset && !limits[:evaluate_rule_character_class]
              if !apply_rule(:evaluate_rule_character_class, answer.thunks, answer.values, 4, offset, offset_loc, limits: limits)
                throw(17)
              end
            elsif !apply_rule(:evaluate_rule_character_class, answer.thunks, answer.values, 4, offset, offset_loc)
              throw(17)
            end
            answer.thunks.push(
              ThunkLeaf.new(
                :action_primary_8,
                Capture.new(
                  answer.pos, @position_offset,
                  answer.pos_loc, @position_offset_loc,
                ),
                answer.values.slice(4),
                {},
              ),
            )
            throw(1)
          end
          @position_offset = pos2
          @position_offset_loc = p_loc2
          answer.thunks[n2..-1] = []
          catch(18) do
            if limits && @position_offset == offset && !limits[:evaluate_rule_quotation_single]
              if !apply_rule(:evaluate_rule_quotation_single, answer.thunks, answer.values, 4, offset, offset_loc, limits: limits)
                throw(18)
              end
            elsif !apply_rule(:evaluate_rule_quotation_single, answer.thunks, answer.values, 4, offset, offset_loc)
              throw(18)
            end
            answer.thunks.push(
              ThunkLeaf.new(
                :action_primary_9,
                Capture.new(
                  answer.pos, @position_offset,
                  answer.pos_loc, @position_offset_loc,
                ),
                answer.values.slice(4),
                {},
              ),
            )
            throw(1)
          end
          @position_offset = pos2
          @position_offset_loc = p_loc2
          answer.thunks[n2..-1] = []
          catch(19) do
            if limits && @position_offset == offset && !limits[:evaluate_rule_quotation_double]
              if !apply_rule(:evaluate_rule_quotation_double, answer.thunks, answer.values, 4, offset, offset_loc, limits: limits)
                throw(19)
              end
            elsif !apply_rule(:evaluate_rule_quotation_double, answer.thunks, answer.values, 4, offset, offset_loc)
              throw(19)
            end
            answer.thunks.push(
              ThunkLeaf.new(
                :action_primary_10,
                Capture.new(
                  answer.pos, @position_offset,
                  answer.pos_loc, @position_offset_loc,
                ),
                answer.values.slice(4),
                {},
              ),
            )
            throw(1)
          end
          @position_offset = pos2
          @position_offset_loc = p_loc2
          answer.thunks[n2..-1] = []
          throw(0)
        end
        @level -= 1
        debug { warn "#{"  " * @level}MATCH   primary #{answer.pos} #{@buffer[answer.pos...@position_offset].inspect}" }
        return answer
      end
      @level -= 1
      debug { warn "#{"  " * @level}NOMATCH primary #{answer.pos} #{@buffer[answer.pos...@position_offset].inspect}" }
      nil
    end

    def evaluate_rule_character_class(offset, offset_loc, limits: nil)
      answer = ThunkChunk.new
      answer.pos = @position_offset
      answer.pos_loc = @position_offset_loc
      debug { warn "#{"  " * @level}EVAL    character_class #{answer.pos} #{@buffer[answer.pos..-1].inspect}" }
      @level += 1
      answer.resize_captures(1)
      catch(0) do
        if refill_buffer(1) < 1 ||
           @buffer[@position_offset] != "["

          throw(0)
        end
        @position_offset_loc = @position_offset_loc.forward(@buffer, @position_offset, 1)
        @position_offset += 1
        pos3 = @position_offset
        p_loc3 = @position_offset_loc
        i4 = 0
        pos4 = nil
        p_loc4 = nil
        n4 = nil
        catch(1) do
          pos4 = @position_offset
          p_loc4 = @position_offset_loc
          n4 = answer.thunks.length
          catch(2) do
            pos5 = @position_offset
            p_loc5 = @position_offset_loc
            n5 = answer.thunks.length
            if refill_buffer(1) >= 1
              u6 = @buffer[@position_offset]
              unless ["\\", "[", "]"].include?(u6)

                @position_offset_loc = @position_offset_loc.forward(@buffer, @position_offset, 1)
                @position_offset += 1
                throw(2)
              end
            end
            @position_offset = pos5
            @position_offset_loc = p_loc5
            answer.thunks[n5..-1] = []
            catch(3) do
              if refill_buffer(2) < 2 ||
                 @buffer[@position_offset, 2] != "\\["

                throw(3)
              end
              @position_offset_loc = @position_offset_loc.forward(@buffer, @position_offset, 2)
              @position_offset += 2
              throw(2)
            end
            @position_offset = pos5
            @position_offset_loc = p_loc5
            answer.thunks[n5..-1] = []
            catch(4) do
              if refill_buffer(2) < 2 ||
                 @buffer[@position_offset, 2] != "\\]"

                throw(4)
              end
              @position_offset_loc = @position_offset_loc.forward(@buffer, @position_offset, 2)
              @position_offset += 2
              throw(2)
            end
            @position_offset = pos5
            @position_offset_loc = p_loc5
            answer.thunks[n5..-1] = []
            catch(5) do
              if refill_buffer(1) < 1 ||
                 @buffer[@position_offset] != "\\"

                throw(5)
              end
              @position_offset_loc = @position_offset_loc.forward(@buffer, @position_offset, 1)
              @position_offset += 1
              throw(2)
            end
            @position_offset = pos5
            @position_offset_loc = p_loc5
            answer.thunks[n5..-1] = []
            throw(1)
          end
          i4 += 1
          if @position_offset != pos4
            redo
          end
          pos4 = nil
        end
        if pos4
          @position_offset = pos4
          @position_offset_loc = p_loc4
          answer.thunks[n4..-1] = []
        end
        q3 = @position_offset
        capt3 = answer.capts[0]
        capt3.range_start = pos3
        capt3.range_end = q3
        q_loc3 = @position_offset_loc
        capt3.start_loc = p_loc3
        capt3.end_loc = q_loc3
        if refill_buffer(1) < 1 ||
           @buffer[@position_offset] != "]"

          throw(0)
        end
        @position_offset_loc = @position_offset_loc.forward(@buffer, @position_offset, 1)
        @position_offset += 1
        answer.thunks.push(
          ThunkLeaf.new(
            :action_character_class_0,
            Capture.new(
              answer.pos, @position_offset,
              answer.pos_loc, @position_offset_loc,
            ),
            {},
            answer.capts.slice(0),
          ),
        )
        @level -= 1
        debug { warn "#{"  " * @level}MATCH   character_class #{answer.pos} #{@buffer[answer.pos...@position_offset].inspect}" }
        return answer
      end
      @level -= 1
      debug { warn "#{"  " * @level}NOMATCH character_class #{answer.pos} #{@buffer[answer.pos...@position_offset].inspect}" }
      nil
    end

    def evaluate_rule_lang_code_block(offset, offset_loc, limits: nil)
      answer = ThunkChunk.new
      answer.pos = @position_offset
      answer.pos_loc = @position_offset_loc
      debug { warn "#{"  " * @level}EVAL    lang_code_block #{answer.pos} #{@buffer[answer.pos..-1].inspect}" }
      @level += 1
      answer.resize_captures(1)
      answer.values = {}
      catch(0) do
        catch(1) do
          pos2 = @position_offset
          p_loc2 = @position_offset_loc
          n2 = answer.thunks.length
          catch(2) do
            if limits && @position_offset == offset && !limits[:evaluate_rule_code_block]
              if !apply_rule(:evaluate_rule_code_block, answer.thunks, answer.values, 0, offset, offset_loc, limits: limits)
                throw(2)
              end
            elsif !apply_rule(:evaluate_rule_code_block, answer.thunks, answer.values, 0, offset, offset_loc)
              throw(2)
            end
            answer.thunks.push(
              ThunkLeaf.new(
                :action_lang_code_block_0,
                Capture.new(
                  answer.pos, @position_offset,
                  answer.pos_loc, @position_offset_loc,
                ),
                answer.values.slice(0),
                {},
              ),
            )
            throw(1)
          end
          @position_offset = pos2
          @position_offset_loc = p_loc2
          answer.thunks[n2..-1] = []
          catch(3) do
            pos4 = @position_offset
            p_loc4 = @position_offset_loc
            if limits && @position_offset == offset && !limits[:evaluate_rule_supported_language]
              if !apply_rule(:evaluate_rule_supported_language, answer.thunks, nil, 0, offset, offset_loc, limits: limits)
                throw(3)
              end
            elsif !apply_rule(:evaluate_rule_supported_language, answer.thunks, nil, 0, offset, offset_loc)
              throw(3)
            end
            q4 = @position_offset
            capt4 = answer.capts[0]
            capt4.range_start = pos4
            capt4.range_end = q4
            q_loc4 = @position_offset_loc
            capt4.start_loc = p_loc4
            capt4.end_loc = q_loc4
            if limits && @position_offset == offset && !limits[:evaluate_rule_opt_spaces_or_comments]
              if !apply_rule(:evaluate_rule_opt_spaces_or_comments, answer.thunks, nil, 0, offset, offset_loc, limits: limits)
                throw(3)
              end
            elsif !apply_rule(:evaluate_rule_opt_spaces_or_comments, answer.thunks, nil, 0, offset, offset_loc)
              throw(3)
            end
            if refill_buffer(2) < 2 ||
               @buffer[@position_offset, 2] != "->"

              throw(3)
            end
            @position_offset_loc = @position_offset_loc.forward(@buffer, @position_offset, 2)
            @position_offset += 2
            if limits && @position_offset == offset && !limits[:evaluate_rule_opt_spaces_or_comments]
              if !apply_rule(:evaluate_rule_opt_spaces_or_comments, answer.thunks, nil, 0, offset, offset_loc, limits: limits)
                throw(3)
              end
            elsif !apply_rule(:evaluate_rule_opt_spaces_or_comments, answer.thunks, nil, 0, offset, offset_loc)
              throw(3)
            end
            if limits && @position_offset == offset && !limits[:evaluate_rule_code_block]
              if !apply_rule(:evaluate_rule_code_block, answer.thunks, answer.values, 0, offset, offset_loc, limits: limits)
                throw(3)
              end
            elsif !apply_rule(:evaluate_rule_code_block, answer.thunks, answer.values, 0, offset, offset_loc)
              throw(3)
            end
            answer.thunks.push(
              ThunkLeaf.new(
                :action_lang_code_block_1,
                Capture.new(
                  answer.pos, @position_offset,
                  answer.pos_loc, @position_offset_loc,
                ),
                answer.values.slice(0),
                answer.capts.slice(0),
              ),
            )
            throw(1)
          end
          @position_offset = pos2
          @position_offset_loc = p_loc2
          answer.thunks[n2..-1] = []
          throw(0)
        end
        @level -= 1
        debug { warn "#{"  " * @level}MATCH   lang_code_block #{answer.pos} #{@buffer[answer.pos...@position_offset].inspect}" }
        return answer
      end
      @level -= 1
      debug { warn "#{"  " * @level}NOMATCH lang_code_block #{answer.pos} #{@buffer[answer.pos...@position_offset].inspect}" }
      nil
    end

    def evaluate_rule_code_block(offset, offset_loc, limits: nil)
      answer = ThunkChunk.new
      answer.pos = @position_offset
      answer.pos_loc = @position_offset_loc
      debug { warn "#{"  " * @level}EVAL    code_block #{answer.pos} #{@buffer[answer.pos..-1].inspect}" }
      @level += 1
      answer.resize_captures(0)
      answer.values = {}
      catch(0) do
        catch(1) do
          pos2 = @position_offset
          p_loc2 = @position_offset_loc
          n2 = answer.thunks.length
          catch(2) do
            if refill_buffer(1) < 1 ||
               @buffer[@position_offset] != "$"

              throw(2)
            end
            @position_offset_loc = @position_offset_loc.forward(@buffer, @position_offset, 1)
            @position_offset += 1
            if limits && @position_offset == offset && !limits[:evaluate_rule_plain_code_block]
              if !apply_rule(:evaluate_rule_plain_code_block, answer.thunks, answer.values, 0, offset, offset_loc, limits: limits)
                throw(2)
              end
            elsif !apply_rule(:evaluate_rule_plain_code_block, answer.thunks, answer.values, 0, offset, offset_loc)
              throw(2)
            end
            answer.thunks.push(
              ThunkLeaf.new(
                :action_code_block_0,
                Capture.new(
                  answer.pos, @position_offset,
                  answer.pos_loc, @position_offset_loc,
                ),
                answer.values.slice(0),
                {},
              ),
            )
            throw(1)
          end
          @position_offset = pos2
          @position_offset_loc = p_loc2
          answer.thunks[n2..-1] = []
          catch(3) do
            if limits && @position_offset == offset && !limits[:evaluate_rule_plain_code_block]
              if !apply_rule(:evaluate_rule_plain_code_block, answer.thunks, answer.values, 0, offset, offset_loc, limits: limits)
                throw(3)
              end
            elsif !apply_rule(:evaluate_rule_plain_code_block, answer.thunks, answer.values, 0, offset, offset_loc)
              throw(3)
            end
            answer.thunks.push(
              ThunkLeaf.new(
                :action_code_block_1,
                Capture.new(
                  answer.pos, @position_offset,
                  answer.pos_loc, @position_offset_loc,
                ),
                answer.values.slice(0),
                {},
              ),
            )
            throw(1)
          end
          @position_offset = pos2
          @position_offset_loc = p_loc2
          answer.thunks[n2..-1] = []
          throw(0)
        end
        @level -= 1
        debug { warn "#{"  " * @level}MATCH   code_block #{answer.pos} #{@buffer[answer.pos...@position_offset].inspect}" }
        return answer
      end
      @level -= 1
      debug { warn "#{"  " * @level}NOMATCH code_block #{answer.pos} #{@buffer[answer.pos...@position_offset].inspect}" }
      nil
    end

    def evaluate_rule_plain_code_block(offset, offset_loc, limits: nil)
      answer = ThunkChunk.new
      answer.pos = @position_offset
      answer.pos_loc = @position_offset_loc
      debug { warn "#{"  " * @level}EVAL    plain_code_block #{answer.pos} #{@buffer[answer.pos..-1].inspect}" }
      @level += 1
      answer.resize_captures(1)
      catch(0) do
        if refill_buffer(1) < 1 ||
           @buffer[@position_offset] != "{"

          throw(0)
        end
        @position_offset_loc = @position_offset_loc.forward(@buffer, @position_offset, 1)
        @position_offset += 1
        pos3 = @position_offset
        p_loc3 = @position_offset_loc
        i5 = 0
        pos5 = nil
        p_loc5 = nil
        n5 = nil
        catch(1) do
          pos5 = @position_offset
          p_loc5 = @position_offset_loc
          n5 = answer.thunks.length
          if refill_buffer(1) < 1
            throw(1)
          end
          u6 = @buffer[@position_offset]
          if !
            [" ", "\t", "\v", "\f", "\r", "\n"].include?(u6)

            throw(1)
          end
          @position_offset_loc = @position_offset_loc.forward(@buffer, @position_offset, 1)
          @position_offset += 1
          i5 += 1
          if @position_offset != pos5
            redo
          end
          pos5 = nil
        end
        if pos5
          @position_offset = pos5
          @position_offset_loc = p_loc5
          answer.thunks[n5..-1] = []
        end
        if limits && @position_offset == offset && !limits[:evaluate_rule_opt_codes]
          if !apply_rule(:evaluate_rule_opt_codes, answer.thunks, nil, 0, offset, offset_loc, limits: limits)
            throw(0)
          end
        elsif !apply_rule(:evaluate_rule_opt_codes, answer.thunks, nil, 0, offset, offset_loc)
          throw(0)
        end
        q3 = @position_offset
        capt3 = answer.capts[0]
        capt3.range_start = pos3
        capt3.range_end = q3
        q_loc3 = @position_offset_loc
        capt3.start_loc = p_loc3
        capt3.end_loc = q_loc3
        if refill_buffer(1) < 1 ||
           @buffer[@position_offset] != "}"

          throw(0)
        end
        @position_offset_loc = @position_offset_loc.forward(@buffer, @position_offset, 1)
        @position_offset += 1
        answer.thunks.push(
          ThunkLeaf.new(
            :action_plain_code_block_0,
            Capture.new(
              answer.pos, @position_offset,
              answer.pos_loc, @position_offset_loc,
            ),
            {},
            answer.capts.slice(0),
          ),
        )
        @level -= 1
        debug { warn "#{"  " * @level}MATCH   plain_code_block #{answer.pos} #{@buffer[answer.pos...@position_offset].inspect}" }
        return answer
      end
      @level -= 1
      debug { warn "#{"  " * @level}NOMATCH plain_code_block #{answer.pos} #{@buffer[answer.pos...@position_offset].inspect}" }
      nil
    end

    def evaluate_rule_opt_codes(offset, offset_loc, limits: nil)
      answer = ThunkChunk.new
      answer.pos = @position_offset
      answer.pos_loc = @position_offset_loc
      debug { warn "#{"  " * @level}EVAL    opt_codes #{answer.pos} #{@buffer[answer.pos..-1].inspect}" }
      @level += 1
      answer.resize_captures(0)
      i2 = 0
      pos2 = nil
      p_loc2 = nil
      n2 = nil
      catch(1) do
        pos2 = @position_offset
        p_loc2 = @position_offset_loc
        n2 = answer.thunks.length
        if limits && @position_offset == offset && !limits[:evaluate_rule_code]
          if !apply_rule(:evaluate_rule_code, answer.thunks, nil, 0, offset, offset_loc, limits: limits)
            throw(1)
          end
        elsif !apply_rule(:evaluate_rule_code, answer.thunks, nil, 0, offset, offset_loc)
          throw(1)
        end
        i4 = 0
        pos4 = nil
        p_loc4 = nil
        n4 = nil
        catch(2) do
          pos4 = @position_offset
          p_loc4 = @position_offset_loc
          n4 = answer.thunks.length
          if refill_buffer(1) < 1
            throw(2)
          end
          u5 = @buffer[@position_offset]
          if !
            [" ", "\t", "\v", "\f", "\r", "\n"].include?(u5)

            throw(2)
          end
          @position_offset_loc = @position_offset_loc.forward(@buffer, @position_offset, 1)
          @position_offset += 1
          i4 += 1
          if @position_offset != pos4
            redo
          end
          pos4 = nil
        end
        if pos4
          @position_offset = pos4
          @position_offset_loc = p_loc4
          answer.thunks[n4..-1] = []
        end
        i2 += 1
        if @position_offset != pos2
          redo
        end
        pos2 = nil
      end
      if pos2
        @position_offset = pos2
        @position_offset_loc = p_loc2
        answer.thunks[n2..-1] = []
      end
      @level -= 1
      debug { warn "#{"  " * @level}MATCH   opt_codes #{answer.pos} #{@buffer[answer.pos...@position_offset].inspect}" }
      answer
    end

    def evaluate_rule_code(offset, offset_loc, limits: nil)
      answer = ThunkChunk.new
      answer.pos = @position_offset
      answer.pos_loc = @position_offset_loc
      debug { warn "#{"  " * @level}EVAL    code #{answer.pos} #{@buffer[answer.pos..-1].inspect}" }
      @level += 1
      answer.resize_captures(0)
      catch(0) do
        catch(1) do
          pos2 = @position_offset
          p_loc2 = @position_offset_loc
          n2 = answer.thunks.length
          catch(2) do
            q3 = @position_offset
            q_loc3 = @position_offset_loc
            m3 = answer.thunks.length
            i3 = 0
            pos3 = nil
            p_loc3 = nil
            n3 = nil
            catch(3) do
              pos3 = @position_offset
              p_loc3 = @position_offset_loc
              n3 = answer.thunks.length
              if limits && @position_offset == offset && !limits[:evaluate_rule_codechar]
                if !apply_rule(:evaluate_rule_codechar, answer.thunks, nil, 0, offset, offset_loc, limits: limits)
                  throw(3)
                end
              elsif !apply_rule(:evaluate_rule_codechar, answer.thunks, nil, 0, offset, offset_loc)
                throw(3)
              end
              i3 += 1
              if @position_offset != pos3
                redo
              end
              pos3 = nil
            end
            if pos3
              @position_offset = pos3
              @position_offset_loc = p_loc3
              answer.thunks[n3..-1] = []
            end
            if i3 < 1
              @position_offset = q3
              @position_offset_loc = q_loc3
              answer.thunks[m3..-1] = []
              throw(2)
            end
            throw(1)
          end
          @position_offset = pos2
          @position_offset_loc = p_loc2
          answer.thunks[n2..-1] = []
          if limits && @position_offset == offset && !limits[:evaluate_rule_quotation_single]
            if apply_rule(:evaluate_rule_quotation_single, answer.thunks, nil, 0, offset, offset_loc, limits: limits)
              throw(1)
            end
          elsif apply_rule(:evaluate_rule_quotation_single, answer.thunks, nil, 0, offset, offset_loc)
            throw(1)
          end
          @position_offset = pos2
          @position_offset_loc = p_loc2
          answer.thunks[n2..-1] = []
          if limits && @position_offset == offset && !limits[:evaluate_rule_quotation_double]
            if apply_rule(:evaluate_rule_quotation_double, answer.thunks, nil, 0, offset, offset_loc, limits: limits)
              throw(1)
            end
          elsif apply_rule(:evaluate_rule_quotation_double, answer.thunks, nil, 0, offset, offset_loc)
            throw(1)
          end
          @position_offset = pos2
          @position_offset_loc = p_loc2
          answer.thunks[n2..-1] = []
          catch(4) do
            if refill_buffer(1) < 1 ||
               @buffer[@position_offset] != "{"

              throw(4)
            end
            @position_offset_loc = @position_offset_loc.forward(@buffer, @position_offset, 1)
            @position_offset += 1
            i4 = 0
            pos4 = nil
            p_loc4 = nil
            n4 = nil
            catch(5) do
              pos4 = @position_offset
              p_loc4 = @position_offset_loc
              n4 = answer.thunks.length
              if limits && @position_offset == offset && !limits[:evaluate_rule_code]
                if !apply_rule(:evaluate_rule_code, answer.thunks, nil, 0, offset, offset_loc, limits: limits)
                  throw(5)
                end
              elsif !apply_rule(:evaluate_rule_code, answer.thunks, nil, 0, offset, offset_loc)
                throw(5)
              end
              i4 += 1
              if @position_offset != pos4
                redo
              end
              pos4 = nil
            end
            if pos4
              @position_offset = pos4
              @position_offset_loc = p_loc4
              answer.thunks[n4..-1] = []
            end
            if refill_buffer(1) < 1 ||
               @buffer[@position_offset] != "}"

              throw(4)
            end
            @position_offset_loc = @position_offset_loc.forward(@buffer, @position_offset, 1)
            @position_offset += 1
            throw(1)
          end
          @position_offset = pos2
          @position_offset_loc = p_loc2
          answer.thunks[n2..-1] = []
          throw(0)
        end
        @level -= 1
        debug { warn "#{"  " * @level}MATCH   code #{answer.pos} #{@buffer[answer.pos...@position_offset].inspect}" }
        return answer
      end
      @level -= 1
      debug { warn "#{"  " * @level}NOMATCH code #{answer.pos} #{@buffer[answer.pos...@position_offset].inspect}" }
      nil
    end

    def evaluate_rule_codechar(offset, offset_loc, limits: nil)
      answer = ThunkChunk.new
      answer.pos = @position_offset
      answer.pos_loc = @position_offset_loc
      debug { warn "#{"  " * @level}EVAL    codechar #{answer.pos} #{@buffer[answer.pos..-1].inspect}" }
      @level += 1
      answer.resize_captures(0)
      catch(0) do
        catch(1) do
          pos2 = @position_offset
          p_loc2 = @position_offset_loc
          n2 = answer.thunks.length
          if refill_buffer(1) >= 1
            u3 = @buffer[@position_offset]
            unless ["{", "}", "\"", "'"].include?(u3)

              @position_offset_loc = @position_offset_loc.forward(@buffer, @position_offset, 1)
              @position_offset += 1
              throw(1)
            end
          end
          @position_offset = pos2
          @position_offset_loc = p_loc2
          answer.thunks[n2..-1] = []
          catch(2) do
            if refill_buffer(2) < 2 ||
               @buffer[@position_offset, 2] != "\\\""

              throw(2)
            end
            @position_offset_loc = @position_offset_loc.forward(@buffer, @position_offset, 2)
            @position_offset += 2
            throw(1)
          end
          @position_offset = pos2
          @position_offset_loc = p_loc2
          answer.thunks[n2..-1] = []
          catch(3) do
            if refill_buffer(2) < 2 ||
               @buffer[@position_offset, 2] != "\\'"

              throw(3)
            end
            @position_offset_loc = @position_offset_loc.forward(@buffer, @position_offset, 2)
            @position_offset += 2
            throw(1)
          end
          @position_offset = pos2
          @position_offset_loc = p_loc2
          answer.thunks[n2..-1] = []
          catch(4) do
            if refill_buffer(2) < 2 ||
               @buffer[@position_offset, 2] != "\\{"

              throw(4)
            end
            @position_offset_loc = @position_offset_loc.forward(@buffer, @position_offset, 2)
            @position_offset += 2
            throw(1)
          end
          @position_offset = pos2
          @position_offset_loc = p_loc2
          answer.thunks[n2..-1] = []
          catch(5) do
            if refill_buffer(2) < 2 ||
               @buffer[@position_offset, 2] != "\\}"

              throw(5)
            end
            @position_offset_loc = @position_offset_loc.forward(@buffer, @position_offset, 2)
            @position_offset += 2
            throw(1)
          end
          @position_offset = pos2
          @position_offset_loc = p_loc2
          answer.thunks[n2..-1] = []
          throw(0)
        end
        @level -= 1
        debug { warn "#{"  " * @level}MATCH   codechar #{answer.pos} #{@buffer[answer.pos...@position_offset].inspect}" }
        return answer
      end
      @level -= 1
      debug { warn "#{"  " * @level}NOMATCH codechar #{answer.pos} #{@buffer[answer.pos...@position_offset].inspect}" }
      nil
    end

    def evaluate_rule_quotation_single(offset, offset_loc, limits: nil)
      answer = ThunkChunk.new
      answer.pos = @position_offset
      answer.pos_loc = @position_offset_loc
      debug { warn "#{"  " * @level}EVAL    quotation_single #{answer.pos} #{@buffer[answer.pos..-1].inspect}" }
      @level += 1
      answer.resize_captures(1)
      catch(0) do
        if refill_buffer(1) < 1 ||
           @buffer[@position_offset] != "'"

          throw(0)
        end
        @position_offset_loc = @position_offset_loc.forward(@buffer, @position_offset, 1)
        @position_offset += 1
        pos3 = @position_offset
        p_loc3 = @position_offset_loc
        i4 = 0
        pos4 = nil
        p_loc4 = nil
        n4 = nil
        catch(1) do
          pos4 = @position_offset
          p_loc4 = @position_offset_loc
          n4 = answer.thunks.length
          catch(2) do
            pos5 = @position_offset
            p_loc5 = @position_offset_loc
            n5 = answer.thunks.length
            if refill_buffer(1) >= 1
              u6 = @buffer[@position_offset]
              unless ["\\", "'", "\n"].include?(u6)

                @position_offset_loc = @position_offset_loc.forward(@buffer, @position_offset, 1)
                @position_offset += 1
                throw(2)
              end
            end
            @position_offset = pos5
            @position_offset_loc = p_loc5
            answer.thunks[n5..-1] = []
            catch(3) do
              if refill_buffer(2) < 2 ||
                 @buffer[@position_offset, 2] != "\\'"

                throw(3)
              end
              @position_offset_loc = @position_offset_loc.forward(@buffer, @position_offset, 2)
              @position_offset += 2
              throw(2)
            end
            @position_offset = pos5
            @position_offset_loc = p_loc5
            answer.thunks[n5..-1] = []
            catch(4) do
              if refill_buffer(2) < 2 ||
                 @buffer[@position_offset, 2] != "\\\n"

                throw(4)
              end
              @position_offset_loc = @position_offset_loc.forward(@buffer, @position_offset, 2)
              @position_offset += 2
              throw(2)
            end
            @position_offset = pos5
            @position_offset_loc = p_loc5
            answer.thunks[n5..-1] = []
            catch(5) do
              if refill_buffer(1) < 1 ||
                 @buffer[@position_offset] != "\\"

                throw(5)
              end
              @position_offset_loc = @position_offset_loc.forward(@buffer, @position_offset, 1)
              @position_offset += 1
              if refill_buffer(1) < 1
                throw(5)
              end
              u7 = @buffer[@position_offset]
              if ["'", "\n"].include?(u7)

                throw(5)
              end
              @position_offset_loc = @position_offset_loc.forward(@buffer, @position_offset, 1)
              @position_offset += 1
              throw(2)
            end
            @position_offset = pos5
            @position_offset_loc = p_loc5
            answer.thunks[n5..-1] = []
            throw(1)
          end
          i4 += 1
          if @position_offset != pos4
            redo
          end
          pos4 = nil
        end
        if pos4
          @position_offset = pos4
          @position_offset_loc = p_loc4
          answer.thunks[n4..-1] = []
        end
        q3 = @position_offset
        capt3 = answer.capts[0]
        capt3.range_start = pos3
        capt3.range_end = q3
        q_loc3 = @position_offset_loc
        capt3.start_loc = p_loc3
        capt3.end_loc = q_loc3
        if refill_buffer(1) < 1 ||
           @buffer[@position_offset] != "'"

          throw(0)
        end
        @position_offset_loc = @position_offset_loc.forward(@buffer, @position_offset, 1)
        @position_offset += 1
        answer.thunks.push(
          ThunkLeaf.new(
            :action_quotation_single_0,
            Capture.new(
              answer.pos, @position_offset,
              answer.pos_loc, @position_offset_loc,
            ),
            {},
            answer.capts.slice(0),
          ),
        )
        @level -= 1
        debug { warn "#{"  " * @level}MATCH   quotation_single #{answer.pos} #{@buffer[answer.pos...@position_offset].inspect}" }
        return answer
      end
      @level -= 1
      debug { warn "#{"  " * @level}NOMATCH quotation_single #{answer.pos} #{@buffer[answer.pos...@position_offset].inspect}" }
      nil
    end

    def evaluate_rule_quotation_double(offset, offset_loc, limits: nil)
      answer = ThunkChunk.new
      answer.pos = @position_offset
      answer.pos_loc = @position_offset_loc
      debug { warn "#{"  " * @level}EVAL    quotation_double #{answer.pos} #{@buffer[answer.pos..-1].inspect}" }
      @level += 1
      answer.resize_captures(1)
      catch(0) do
        if refill_buffer(1) < 1 ||
           @buffer[@position_offset] != "\""

          throw(0)
        end
        @position_offset_loc = @position_offset_loc.forward(@buffer, @position_offset, 1)
        @position_offset += 1
        pos3 = @position_offset
        p_loc3 = @position_offset_loc
        i4 = 0
        pos4 = nil
        p_loc4 = nil
        n4 = nil
        catch(1) do
          pos4 = @position_offset
          p_loc4 = @position_offset_loc
          n4 = answer.thunks.length
          catch(2) do
            pos5 = @position_offset
            p_loc5 = @position_offset_loc
            n5 = answer.thunks.length
            if refill_buffer(1) >= 1
              u6 = @buffer[@position_offset]
              unless ["\\", "\"", "\n"].include?(u6)

                @position_offset_loc = @position_offset_loc.forward(@buffer, @position_offset, 1)
                @position_offset += 1
                throw(2)
              end
            end
            @position_offset = pos5
            @position_offset_loc = p_loc5
            answer.thunks[n5..-1] = []
            catch(3) do
              if refill_buffer(2) < 2 ||
                 @buffer[@position_offset, 2] != "\\\""

                throw(3)
              end
              @position_offset_loc = @position_offset_loc.forward(@buffer, @position_offset, 2)
              @position_offset += 2
              throw(2)
            end
            @position_offset = pos5
            @position_offset_loc = p_loc5
            answer.thunks[n5..-1] = []
            catch(4) do
              if refill_buffer(2) < 2 ||
                 @buffer[@position_offset, 2] != "\\\n"

                throw(4)
              end
              @position_offset_loc = @position_offset_loc.forward(@buffer, @position_offset, 2)
              @position_offset += 2
              throw(2)
            end
            @position_offset = pos5
            @position_offset_loc = p_loc5
            answer.thunks[n5..-1] = []
            catch(5) do
              if refill_buffer(1) < 1 ||
                 @buffer[@position_offset] != "\\"

                throw(5)
              end
              @position_offset_loc = @position_offset_loc.forward(@buffer, @position_offset, 1)
              @position_offset += 1
              if refill_buffer(1) < 1
                throw(5)
              end
              u7 = @buffer[@position_offset]
              if ["\"", "\n"].include?(u7)

                throw(5)
              end
              @position_offset_loc = @position_offset_loc.forward(@buffer, @position_offset, 1)
              @position_offset += 1
              throw(2)
            end
            @position_offset = pos5
            @position_offset_loc = p_loc5
            answer.thunks[n5..-1] = []
            throw(1)
          end
          i4 += 1
          if @position_offset != pos4
            redo
          end
          pos4 = nil
        end
        if pos4
          @position_offset = pos4
          @position_offset_loc = p_loc4
          answer.thunks[n4..-1] = []
        end
        q3 = @position_offset
        capt3 = answer.capts[0]
        capt3.range_start = pos3
        capt3.range_end = q3
        q_loc3 = @position_offset_loc
        capt3.start_loc = p_loc3
        capt3.end_loc = q_loc3
        if refill_buffer(1) < 1 ||
           @buffer[@position_offset] != "\""

          throw(0)
        end
        @position_offset_loc = @position_offset_loc.forward(@buffer, @position_offset, 1)
        @position_offset += 1
        answer.thunks.push(
          ThunkLeaf.new(
            :action_quotation_double_0,
            Capture.new(
              answer.pos, @position_offset,
              answer.pos_loc, @position_offset_loc,
            ),
            {},
            answer.capts.slice(0),
          ),
        )
        @level -= 1
        debug { warn "#{"  " * @level}MATCH   quotation_double #{answer.pos} #{@buffer[answer.pos...@position_offset].inspect}" }
        return answer
      end
      @level -= 1
      debug { warn "#{"  " * @level}NOMATCH quotation_double #{answer.pos} #{@buffer[answer.pos...@position_offset].inspect}" }
      nil
    end

    def evaluate_rule_identifier(offset, offset_loc, limits: nil)
      answer = ThunkChunk.new
      answer.pos = @position_offset
      answer.pos_loc = @position_offset_loc
      debug { warn "#{"  " * @level}EVAL    identifier #{answer.pos} #{@buffer[answer.pos..-1].inspect}" }
      @level += 1
      answer.resize_captures(0)
      catch(0) do
        if refill_buffer(1) < 1
          throw(0)
        end
        u3 = @buffer[@position_offset]
        if !(
          (u3 >= "a" && u3 <= "z") ||
          (u3 >= "A" && u3 <= "Z") ||
          u3 == "_"
        )
          throw(0)
        end
        @position_offset_loc = @position_offset_loc.forward(@buffer, @position_offset, 1)
        @position_offset += 1
        i3 = 0
        pos3 = nil
        p_loc3 = nil
        n3 = nil
        catch(1) do
          pos3 = @position_offset
          p_loc3 = @position_offset_loc
          n3 = answer.thunks.length
          if refill_buffer(1) < 1
            throw(1)
          end
          u4 = @buffer[@position_offset]
          if !(
            (u4 >= "a" && u4 <= "z") ||
            (u4 >= "A" && u4 <= "Z") ||
            u4 == "_" ||
            (u4 >= "0" && u4 <= "9")
          )
            throw(1)
          end
          @position_offset_loc = @position_offset_loc.forward(@buffer, @position_offset, 1)
          @position_offset += 1
          i3 += 1
          if @position_offset != pos3
            redo
          end
          pos3 = nil
        end
        if pos3
          @position_offset = pos3
          @position_offset_loc = p_loc3
          answer.thunks[n3..-1] = []
        end
        answer.thunks.push(
          ThunkLeaf.new(
            :action_identifier_0,
            Capture.new(
              answer.pos, @position_offset,
              answer.pos_loc, @position_offset_loc,
            ),
            {},
            {},
          ),
        )
        @level -= 1
        debug { warn "#{"  " * @level}MATCH   identifier #{answer.pos} #{@buffer[answer.pos...@position_offset].inspect}" }
        return answer
      end
      @level -= 1
      debug { warn "#{"  " * @level}NOMATCH identifier #{answer.pos} #{@buffer[answer.pos...@position_offset].inspect}" }
      nil
    end

    def evaluate_rule_spaces(offset, offset_loc, limits: nil)
      answer = ThunkChunk.new
      answer.pos = @position_offset
      answer.pos_loc = @position_offset_loc
      debug { warn "#{"  " * @level}EVAL    spaces #{answer.pos} #{@buffer[answer.pos..-1].inspect}" }
      @level += 1
      answer.resize_captures(0)
      catch(0) do
        q2 = @position_offset
        q_loc2 = @position_offset_loc
        m2 = answer.thunks.length
        i2 = 0
        pos2 = nil
        p_loc2 = nil
        n2 = nil
        catch(1) do
          pos2 = @position_offset
          p_loc2 = @position_offset_loc
          n2 = answer.thunks.length
          if refill_buffer(1) < 1
            throw(1)
          end
          u3 = @buffer[@position_offset]
          if !
            [" ", "\t", "\v", "\f", "\r", "\n"].include?(u3)

            throw(1)
          end
          @position_offset_loc = @position_offset_loc.forward(@buffer, @position_offset, 1)
          @position_offset += 1
          i2 += 1
          if @position_offset != pos2
            redo
          end
          pos2 = nil
        end
        if pos2
          @position_offset = pos2
          @position_offset_loc = p_loc2
          answer.thunks[n2..-1] = []
        end
        if i2 < 1
          @position_offset = q2
          @position_offset_loc = q_loc2
          answer.thunks[m2..-1] = []
          throw(0)
        end
        @level -= 1
        debug { warn "#{"  " * @level}MATCH   spaces #{answer.pos} #{@buffer[answer.pos...@position_offset].inspect}" }
        return answer
      end
      @level -= 1
      debug { warn "#{"  " * @level}NOMATCH spaces #{answer.pos} #{@buffer[answer.pos...@position_offset].inspect}" }
      nil
    end

    def evaluate_rule_opt_spaces_or_comments(offset, offset_loc, limits: nil)
      answer = ThunkChunk.new
      answer.pos = @position_offset
      answer.pos_loc = @position_offset_loc
      debug { warn "#{"  " * @level}EVAL    opt_spaces_or_comments #{answer.pos} #{@buffer[answer.pos..-1].inspect}" }
      @level += 1
      answer.resize_captures(0)
      i2 = 0
      pos2 = nil
      p_loc2 = nil
      n2 = nil
      catch(1) do
        pos2 = @position_offset
        p_loc2 = @position_offset_loc
        n2 = answer.thunks.length
        catch(2) do
          pos3 = @position_offset
          p_loc3 = @position_offset_loc
          n3 = answer.thunks.length
          if limits && @position_offset == offset && !limits[:evaluate_rule_comment]
            if apply_rule(:evaluate_rule_comment, answer.thunks, nil, 0, offset, offset_loc, limits: limits)
              throw(2)
            end
          elsif apply_rule(:evaluate_rule_comment, answer.thunks, nil, 0, offset, offset_loc)
            throw(2)
          end
          @position_offset = pos3
          @position_offset_loc = p_loc3
          answer.thunks[n3..-1] = []
          if limits && @position_offset == offset && !limits[:evaluate_rule_spaces]
            if apply_rule(:evaluate_rule_spaces, answer.thunks, nil, 0, offset, offset_loc, limits: limits)
              throw(2)
            end
          elsif apply_rule(:evaluate_rule_spaces, answer.thunks, nil, 0, offset, offset_loc)
            throw(2)
          end
          @position_offset = pos3
          @position_offset_loc = p_loc3
          answer.thunks[n3..-1] = []
          throw(1)
        end
        i2 += 1
        if @position_offset != pos2
          redo
        end
        pos2 = nil
      end
      if pos2
        @position_offset = pos2
        @position_offset_loc = p_loc2
        answer.thunks[n2..-1] = []
      end
      @level -= 1
      debug { warn "#{"  " * @level}MATCH   opt_spaces_or_comments #{answer.pos} #{@buffer[answer.pos...@position_offset].inspect}" }
      answer
    end

    def evaluate_rule_lf(offset, offset_loc, limits: nil)
      answer = ThunkChunk.new
      answer.pos = @position_offset
      answer.pos_loc = @position_offset_loc
      debug { warn "#{"  " * @level}EVAL    lf #{answer.pos} #{@buffer[answer.pos..-1].inspect}" }
      @level += 1
      answer.resize_captures(0)
      catch(0) do
        pos3 = @position_offset
        p_loc3 = @position_offset_loc
        n3 = answer.thunks.length
        catch(2) do
          catch(1) do
            if refill_buffer(1) < 1 ||
               @buffer[@position_offset] != "\r"

              throw(1)
            end
            @position_offset_loc = @position_offset_loc.forward(@buffer, @position_offset, 1)
            @position_offset += 1
            throw(2)
          end
          @position_offset_loc = p_loc3
          @position_offset = pos3
          answer.thunks[n3..-1] = []
        end
        if refill_buffer(1) < 1 ||
           @buffer[@position_offset] != "\n"

          throw(0)
        end
        @position_offset_loc = @position_offset_loc.forward(@buffer, @position_offset, 1)
        @position_offset += 1
        @level -= 1
        debug { warn "#{"  " * @level}MATCH   lf #{answer.pos} #{@buffer[answer.pos...@position_offset].inspect}" }
        return answer
      end
      @level -= 1
      debug { warn "#{"  " * @level}NOMATCH lf #{answer.pos} #{@buffer[answer.pos...@position_offset].inspect}" }
      nil
    end

    def evaluate_rule_footer(offset, offset_loc, limits: nil)
      answer = ThunkChunk.new
      answer.pos = @position_offset
      answer.pos_loc = @position_offset_loc
      debug { warn "#{"  " * @level}EVAL    footer #{answer.pos} #{@buffer[answer.pos..-1].inspect}" }
      @level += 1
      answer.resize_captures(1)
      catch(0) do
        if refill_buffer(2) < 2 ||
           @buffer[@position_offset, 2] != "%%"

          throw(0)
        end
        @position_offset_loc = @position_offset_loc.forward(@buffer, @position_offset, 2)
        @position_offset += 2
        catch(1) do
          pos3 = @position_offset
          p_loc3 = @position_offset_loc
          n3 = answer.thunks.length
          if limits && @position_offset == offset && !limits[:evaluate_rule_lf]
            if apply_rule(:evaluate_rule_lf, answer.thunks, nil, 0, offset, offset_loc, limits: limits)
              throw(1)
            end
          elsif apply_rule(:evaluate_rule_lf, answer.thunks, nil, 0, offset, offset_loc)
            throw(1)
          end
          @position_offset = pos3
          @position_offset_loc = p_loc3
          answer.thunks[n3..-1] = []
          if limits && @position_offset == offset && !limits[:evaluate_rule_EOF]
            if apply_rule(:evaluate_rule_EOF, answer.thunks, nil, 0, offset, offset_loc, limits: limits)
              throw(1)
            end
          elsif apply_rule(:evaluate_rule_EOF, answer.thunks, nil, 0, offset, offset_loc)
            throw(1)
          end
          @position_offset = pos3
          @position_offset_loc = p_loc3
          answer.thunks[n3..-1] = []
          throw(0)
        end
        pos3 = @position_offset
        p_loc3 = @position_offset_loc
        i4 = 0
        pos4 = nil
        p_loc4 = nil
        n4 = nil
        catch(2) do
          pos4 = @position_offset
          p_loc4 = @position_offset_loc
          n4 = answer.thunks.length
          if refill_buffer(1) < 1
            throw(2)
          end
          u5 = @buffer[@position_offset]
          @position_offset_loc = @position_offset_loc.forward(@buffer, @position_offset, 1)
          @position_offset += 1
          i4 += 1
          if @position_offset != pos4
            redo
          end
          pos4 = nil
        end
        if pos4
          @position_offset = pos4
          @position_offset_loc = p_loc4
          answer.thunks[n4..-1] = []
        end
        q3 = @position_offset
        capt3 = answer.capts[0]
        capt3.range_start = pos3
        capt3.range_end = q3
        q_loc3 = @position_offset_loc
        capt3.start_loc = p_loc3
        capt3.end_loc = q_loc3
        answer.thunks.push(
          ThunkLeaf.new(
            :action_footer_0,
            Capture.new(
              answer.pos, @position_offset,
              answer.pos_loc, @position_offset_loc,
            ),
            {},
            answer.capts.slice(0),
          ),
        )
        @level -= 1
        debug { warn "#{"  " * @level}MATCH   footer #{answer.pos} #{@buffer[answer.pos...@position_offset].inspect}" }
        return answer
      end
      @level -= 1
      debug { warn "#{"  " * @level}NOMATCH footer #{answer.pos} #{@buffer[answer.pos...@position_offset].inspect}" }
      nil
    end

    def evaluate_rule_EOF(offset, offset_loc, limits: nil)
      answer = ThunkChunk.new
      answer.pos = @position_offset
      answer.pos_loc = @position_offset_loc
      debug { warn "#{"  " * @level}EVAL    EOF #{answer.pos} #{@buffer[answer.pos..-1].inspect}" }
      @level += 1
      answer.resize_captures(0)
      catch(0) do
        if refill_buffer(1) >= 1
          throw(0)
        end
        @level -= 1
        debug { warn "#{"  " * @level}MATCH   EOF #{answer.pos} #{@buffer[answer.pos...@position_offset].inspect}" }
        return answer
      end
      @level -= 1
      debug { warn "#{"  " * @level}NOMATCH EOF #{answer.pos} #{@buffer[answer.pos...@position_offset].inspect}" }
      nil
    end

    def grow_lr(rule, offset, offset_loc)
      while true
        old_offset = @position_offset
        @position_offset = offset
        @position_offset_loc = offset_loc
        answer = public_send(rule, offset, offset_loc, limits: { rule => true })
        if !answer || @position_offset <= old_offset
          break
        end

        memo = @memos[offset, rule]
        memo.answer = answer
        memo.offset = @position_offset
        memo.offset_loc = @position_offset_loc
      end
    end

    def rule_answer(rule)
      offset = @position_offset
      offset_loc = @position_offset_loc
      memo = @memos[offset, rule]

      if !memo
        memo = LrMemo.new(offset, offset_loc)
        @memos[offset, rule] = memo
        answer = public_send(rule, offset, offset_loc)
        memo.answer = answer
        memo.offset = @position_offset
        memo.offset_loc = @position_offset_loc
        if memo.grow
          grow_lr(rule, offset, offset_loc)
          memo.grow = false
          answer = memo.answer
          @position_offset = memo.offset
          @position_offset_loc = memo.offset_loc
        end
        answer
      elsif memo.fail
        memo.answer = nil
        memo.grow = true
        nil
      else
        @position_offset = memo.offset
        @position_offset_loc = memo.offset_loc
        memo.answer
      end
    end

    def apply_rule(rule, thunks, values, index, offset, offset_loc, limits: nil)
      if limits
        limits = limits.merge(rule => true)
        answer = public_send(rule, offset, offset_loc, limits: limits)
        memo = @memos[offset, rule]
        if !answer || @position_offset <= memo.offset
          if memo
            answer = memo.answer
            @position_offset = memo.offset
            @position_offset_loc = memo.offset_loc
          end
        else
          memo.answer = answer
          memo.offset = @position_offset
          memo.offset_loc = @position_offset_loc
        end
      else
        answer = rule_answer(rule)
      end

      if !answer
        return false
      end

      values ||= @global_values
      thunks << ThunkNode.new(answer.thunks, values, index)
      true
    end

    def do_action(thunks, values, index)
      thunks.each do |thunk|
        thunk.do_action(self, values, index)
      end
    end

    class LrMemoTable
      def initialize
        @memos = {}
      end

      def clear
        @memos.clear
      end

      def []=(index, rule_name, memo)
        entry = @memos[index] ||= {}
        entry[rule_name] = memo
      end

      def [](index, rule_name)
        @memos.dig(index, rule_name)
      end
    end

    class LrMemo
      attr_accessor :grow, :answer, :offset, :fail, :offset_loc

      def initialize(offset, offset_loc)
        @offset = offset
        @offset_loc = offset_loc
        @fail = true
        @grow = false
      end

      def answer=(answer)
        @fail = nil
        @answer = answer
      end
    end

    class ThunkChunk
      attr_accessor :thunks, :capts, :pos, :values, :pos_loc

      def initialize
        super
        @thunks = []
        @capts = {}
        @pos = 0
        @values = {}
      end

      def resize_captures(len)
        len.times do |i|
          @capts[i] = Capture.new
        end
      end
    end

    class ThunkLeaf
      attr_accessor :capt0, :capts, :value_refs, :action

      def initialize(action, capt0 = Capture.new, value_refs = {}, capts = {})
        @value_refs = value_refs
        @capts = capts
        @capt0 = capt0
        @action = action
      end

      def do_action(ctx, values, index)
        ctx.public_send(action, self, values, index)
      end
    end

    class ThunkNode
      attr_accessor :thunks, :values, :index

      def initialize(thunks, values, index)
        @thunks = thunks
        @values = values
        @index = index
        values[index] ||= Value.new if values
      end

      def do_action(ctx, _values, _index)
        @thunks.each do |thunk|
          thunk.do_action(ctx, @values, @index)
        end
      end

      def clear
        @thunks.clear
      end
    end

    class Capture
      attr_accessor :range_start, :range_end, :start_loc, :end_loc

      def initialize(range_start = 0, range_end = 0, start_loc = nil, end_loc = nil)
        @range_start = range_start
        @range_end = range_end
        @start_loc = start_loc || Location.new
        @end_loc = end_loc || Location.new
      end

      def capture_string(buffer)
        @capture_string ||= buffer[@range_start, @range_end - @range_start]
      end
    end

    class Value
      attr_accessor :value
    end
  end

  class Parser
    def getc
      @ifile.getc
    end
  end
end
