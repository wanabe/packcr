# A packrat parser generated by PackCR 0.0.5

class Packcr::Parser
  def initialize(ctx = nil, ifile = nil, debug: false)
    @buffer = +""

    @pos = 0
    @cur = 0
    @level = 0
    @lrstack = []
    @thunk = ThunkNode.new([], nil, 0)
    @heads = {}
    @memos = LrMemoTable.new
    @debug = debug
    @global_values = {}
    @pos_loc = Location.new
    @cur_loc = Location.new
    @ctx = ctx || self
    @ifile = ifile || stdin
    @utf8 = true
    @ascii = false
    @lang = :rb
  end

  def debug
    yield if @debug
  end

  def getc
    $stdin.getc
  end

  def refill_buffer(num, mode = nil)
    len = @buffer.length
    if len >= @cur + num
      return len - @cur
    end
    while len < @cur + num
      c = getc
      break if !c
      @buffer << c
      len = @buffer.length
    end
    return len - @cur
  end

  def commit_buffer
    @buffer = @buffer[@cur, @buffer.length - @cur]
    @pos += @cur
    @heads.clear
    @memos.clear
    @cur = 0
    @pos_loc = @pos_loc + @cur_loc
    @cur_loc = Location.new
  end

  def parse
    pos = @pos
    if apply_rule(:evaluate_rule_statement, @thunk.thunks, nil, 0)
      @thunk.do_action(self, nil, 0)
    else
      raise SyntaxError, "can't parse"
    end
    commit_buffer
    @thunk.clear
    refill_buffer(1) >= 1 && pos != @pos
  end

  def run
    nil while parse
  end

  def action_statement_0(__pcc_in, __pcc_vars, __pcc_index)
    ____ = (__pcc_vars[__pcc_index] ||= Value.new).value if __pcc_vars
    __0 = __pcc_in.capt0.capture_string(@buffer)
    __0s = @pos + __pcc_in.capt0.range_start
    __0e = @pos + __pcc_in.capt0.range_end
    __0sl = @pos_loc + __pcc_in.capt0.start_loc
    __0el = @pos_loc + __pcc_in.capt0.end_loc
    @ctx.error __0sl.linenum + 1, __0sl.charnum + 1, "Illegal syntax"

    __pcc_vars[__pcc_index].value = ____ if __pcc_vars
  end

  def action_supported_language_0(__pcc_in, __pcc_vars, __pcc_index)
    ____ = (__pcc_vars[__pcc_index] ||= Value.new).value if __pcc_vars
    __0 = __pcc_in.capt0.capture_string(@buffer)
    __0s = @pos + __pcc_in.capt0.range_start
    __0e = @pos + __pcc_in.capt0.range_end
    __0sl = @pos_loc + __pcc_in.capt0.start_loc
    __0el = @pos_loc + __pcc_in.capt0.end_loc
    @ctx.error __0sl.linenum + 1, __0sl.charnum + 1, "Not supported language: #{__0}"

    __pcc_vars[__pcc_index].value = ____ if __pcc_vars
  end

  def action_directive_include_0(__pcc_in, __pcc_vars, __pcc_index)
    ____ = (__pcc_vars[__pcc_index] ||= Value.new).value if __pcc_vars
    blocks = (__pcc_in.value_refs[0]  ||= Value.new).value
    __0 = __pcc_in.capt0.capture_string(@buffer)
    __0s = @pos + __pcc_in.capt0.range_start
    __0e = @pos + __pcc_in.capt0.range_end
    __0sl = @pos_loc + __pcc_in.capt0.start_loc
    __0el = @pos_loc + __pcc_in.capt0.end_loc
    blocks.each { |b| @ctx.code(:esource)  << Packcr::CodeBlock.new(b, __0sl.linenum, __0sl.charnum) }

    __pcc_vars[__pcc_index].value = ____ if __pcc_vars
  end

  def action_directive_include_1(__pcc_in, __pcc_vars, __pcc_index)
    ____ = (__pcc_vars[__pcc_index] ||= Value.new).value if __pcc_vars
    blocks = (__pcc_in.value_refs[0]  ||= Value.new).value
    __0 = __pcc_in.capt0.capture_string(@buffer)
    __0s = @pos + __pcc_in.capt0.range_start
    __0e = @pos + __pcc_in.capt0.range_end
    __0sl = @pos_loc + __pcc_in.capt0.start_loc
    __0el = @pos_loc + __pcc_in.capt0.end_loc
    blocks.each { |b| @ctx.code(:source)   << Packcr::CodeBlock.new(b, __0sl.linenum, __0sl.charnum) }

    __pcc_vars[__pcc_index].value = ____ if __pcc_vars
  end

  def action_directive_include_2(__pcc_in, __pcc_vars, __pcc_index)
    ____ = (__pcc_vars[__pcc_index] ||= Value.new).value if __pcc_vars
    blocks = (__pcc_in.value_refs[0]  ||= Value.new).value
    __0 = __pcc_in.capt0.capture_string(@buffer)
    __0s = @pos + __pcc_in.capt0.range_start
    __0e = @pos + __pcc_in.capt0.range_end
    __0sl = @pos_loc + __pcc_in.capt0.start_loc
    __0el = @pos_loc + __pcc_in.capt0.end_loc
    blocks.each { |b| @ctx.code(:lheader)  << Packcr::CodeBlock.new(b, __0sl.linenum, __0sl.charnum) }

    __pcc_vars[__pcc_index].value = ____ if __pcc_vars
  end

  def action_directive_include_3(__pcc_in, __pcc_vars, __pcc_index)
    ____ = (__pcc_vars[__pcc_index] ||= Value.new).value if __pcc_vars
    blocks = (__pcc_in.value_refs[0]  ||= Value.new).value
    __0 = __pcc_in.capt0.capture_string(@buffer)
    __0s = @pos + __pcc_in.capt0.range_start
    __0e = @pos + __pcc_in.capt0.range_end
    __0sl = @pos_loc + __pcc_in.capt0.start_loc
    __0el = @pos_loc + __pcc_in.capt0.end_loc
    blocks.each { |b| @ctx.code(:lsource)  << Packcr::CodeBlock.new(b, __0sl.linenum, __0sl.charnum) }

    __pcc_vars[__pcc_index].value = ____ if __pcc_vars
  end

  def action_directive_include_4(__pcc_in, __pcc_vars, __pcc_index)
    ____ = (__pcc_vars[__pcc_index] ||= Value.new).value if __pcc_vars
    blocks = (__pcc_in.value_refs[0]  ||= Value.new).value
    __0 = __pcc_in.capt0.capture_string(@buffer)
    __0s = @pos + __pcc_in.capt0.range_start
    __0e = @pos + __pcc_in.capt0.range_end
    __0sl = @pos_loc + __pcc_in.capt0.start_loc
    __0el = @pos_loc + __pcc_in.capt0.end_loc
    blocks.each { |b| @ctx.code(:header)   << Packcr::CodeBlock.new(b, __0sl.linenum, __0sl.charnum) }

    __pcc_vars[__pcc_index].value = ____ if __pcc_vars
  end

  def action_directive_include_5(__pcc_in, __pcc_vars, __pcc_index)
    ____ = (__pcc_vars[__pcc_index] ||= Value.new).value if __pcc_vars
    blocks = (__pcc_in.value_refs[0]  ||= Value.new).value
    __0 = __pcc_in.capt0.capture_string(@buffer)
    __0s = @pos + __pcc_in.capt0.range_start
    __0e = @pos + __pcc_in.capt0.range_end
    __0sl = @pos_loc + __pcc_in.capt0.start_loc
    __0el = @pos_loc + __pcc_in.capt0.end_loc
    blocks.each { |b| @ctx.code(:location) << Packcr::CodeBlock.new(b, __0sl.linenum, __0sl.charnum) }

    __pcc_vars[__pcc_index].value = ____ if __pcc_vars
  end

  def action_directive_include_6(__pcc_in, __pcc_vars, __pcc_index)
    ____ = (__pcc_vars[__pcc_index] ||= Value.new).value if __pcc_vars
    blocks = (__pcc_in.value_refs[0]  ||= Value.new).value
    __0 = __pcc_in.capt0.capture_string(@buffer)
    __0s = @pos + __pcc_in.capt0.range_start
    __0e = @pos + __pcc_in.capt0.range_end
    __0sl = @pos_loc + __pcc_in.capt0.start_loc
    __0el = @pos_loc + __pcc_in.capt0.end_loc
    blocks.each { |b| @ctx.code(:init)     << Packcr::CodeBlock.new(b, __0sl.linenum, __0sl.charnum) }

    __pcc_vars[__pcc_index].value = ____ if __pcc_vars
  end

  def action_directive_include_7(__pcc_in, __pcc_vars, __pcc_index)
    ____ = (__pcc_vars[__pcc_index] ||= Value.new).value if __pcc_vars
    blocks = (__pcc_in.value_refs[0]  ||= Value.new).value
    __0 = __pcc_in.capt0.capture_string(@buffer)
    __0s = @pos + __pcc_in.capt0.range_start
    __0e = @pos + __pcc_in.capt0.range_end
    __0sl = @pos_loc + __pcc_in.capt0.start_loc
    __0el = @pos_loc + __pcc_in.capt0.end_loc
    blocks.each { |b| Packcr::BroadCast.new(@ctx.code(:eheader), @ctx.code(:esource)) << Packcr::CodeBlock.new(b, __0sl.linenum, __0sl.charnum) }

    __pcc_vars[__pcc_index].value = ____ if __pcc_vars
  end

  def action_directive_include_8(__pcc_in, __pcc_vars, __pcc_index)
    ____ = (__pcc_vars[__pcc_index] ||= Value.new).value if __pcc_vars
    blocks = (__pcc_in.value_refs[0]  ||= Value.new).value
    __0 = __pcc_in.capt0.capture_string(@buffer)
    __0s = @pos + __pcc_in.capt0.range_start
    __0e = @pos + __pcc_in.capt0.range_end
    __0sl = @pos_loc + __pcc_in.capt0.start_loc
    __0el = @pos_loc + __pcc_in.capt0.end_loc
    blocks.each { |b| Packcr::BroadCast.new(@ctx.code(:header),  @ctx.code(:source))  << Packcr::CodeBlock.new(b, __0sl.linenum, __0sl.charnum) }

    __pcc_vars[__pcc_index].value = ____ if __pcc_vars
  end

  def action_directive_include_9(__pcc_in, __pcc_vars, __pcc_index)
    ____ = (__pcc_vars[__pcc_index] ||= Value.new).value if __pcc_vars
    blocks = (__pcc_in.value_refs[0]  ||= Value.new).value
    __0 = __pcc_in.capt0.capture_string(@buffer)
    __0s = @pos + __pcc_in.capt0.range_start
    __0e = @pos + __pcc_in.capt0.range_end
    __0sl = @pos_loc + __pcc_in.capt0.start_loc
    __0el = @pos_loc + __pcc_in.capt0.end_loc
    __1 = __pcc_in.capts[0].capture_string(@buffer)
    __1s = @pos + __pcc_in.capts[0].range_start
    __1e = @pos + __pcc_in.capts[0].range_end
    __1sl = @pos_loc + __pcc_in.capts[0].start_loc
    __1el = @pos_loc + __pcc_in.capts[0].end_loc
    blocks.each { @ctx.error __0sl.linenum + 1, __0sl.charnum + 1, "Invalid directive: #{__1}" }

    __pcc_vars[__pcc_index].value = ____ if __pcc_vars
  end

  def action_code_blocks_0(__pcc_in, __pcc_vars, __pcc_index)
    ____ = (__pcc_vars[__pcc_index] ||= Value.new).value if __pcc_vars
    blocks = (__pcc_in.value_refs[0]  ||= Value.new).value
    block = (__pcc_in.value_refs[1]  ||= Value.new).value
    __0 = __pcc_in.capt0.capture_string(@buffer)
    __0s = @pos + __pcc_in.capt0.range_start
    __0e = @pos + __pcc_in.capt0.range_end
    __0sl = @pos_loc + __pcc_in.capt0.start_loc
    __0el = @pos_loc + __pcc_in.capt0.end_loc
    blocks.push(block) if block; ____ = blocks

    __pcc_vars[__pcc_index].value = ____ if __pcc_vars
  end

  def action_code_blocks_1(__pcc_in, __pcc_vars, __pcc_index)
    ____ = (__pcc_vars[__pcc_index] ||= Value.new).value if __pcc_vars
    block = (__pcc_in.value_refs[1]  ||= Value.new).value
    __0 = __pcc_in.capt0.capture_string(@buffer)
    __0s = @pos + __pcc_in.capt0.range_start
    __0e = @pos + __pcc_in.capt0.range_end
    __0sl = @pos_loc + __pcc_in.capt0.start_loc
    __0el = @pos_loc + __pcc_in.capt0.end_loc
    ____ = block ? [block] : []

    __pcc_vars[__pcc_index].value = ____ if __pcc_vars
  end

  def action_directive_string_0(__pcc_in, __pcc_vars, __pcc_index)
    ____ = (__pcc_vars[__pcc_index] ||= Value.new).value if __pcc_vars
    strings = (__pcc_in.value_refs[0]  ||= Value.new).value
    __0 = __pcc_in.capt0.capture_string(@buffer)
    __0s = @pos + __pcc_in.capt0.range_start
    __0e = @pos + __pcc_in.capt0.range_end
    __0sl = @pos_loc + __pcc_in.capt0.start_loc
    __0el = @pos_loc + __pcc_in.capt0.end_loc
    strings.each { |str| @ctx.value_type = str }

    __pcc_vars[__pcc_index].value = ____ if __pcc_vars
  end

  def action_directive_string_1(__pcc_in, __pcc_vars, __pcc_index)
    ____ = (__pcc_vars[__pcc_index] ||= Value.new).value if __pcc_vars
    strings = (__pcc_in.value_refs[0]  ||= Value.new).value
    __0 = __pcc_in.capt0.capture_string(@buffer)
    __0s = @pos + __pcc_in.capt0.range_start
    __0e = @pos + __pcc_in.capt0.range_end
    __0sl = @pos_loc + __pcc_in.capt0.start_loc
    __0el = @pos_loc + __pcc_in.capt0.end_loc
    strings.each { |str| @ctx.auxil_type = str }

    __pcc_vars[__pcc_index].value = ____ if __pcc_vars
  end

  def action_directive_string_2(__pcc_in, __pcc_vars, __pcc_index)
    ____ = (__pcc_vars[__pcc_index] ||= Value.new).value if __pcc_vars
    strings = (__pcc_in.value_refs[0]  ||= Value.new).value
    __0 = __pcc_in.capt0.capture_string(@buffer)
    __0s = @pos + __pcc_in.capt0.range_start
    __0e = @pos + __pcc_in.capt0.range_end
    __0sl = @pos_loc + __pcc_in.capt0.start_loc
    __0el = @pos_loc + __pcc_in.capt0.end_loc
    strings.each { |str| @ctx.prefix = str }

    __pcc_vars[__pcc_index].value = ____ if __pcc_vars
  end

  def action_directive_string_3(__pcc_in, __pcc_vars, __pcc_index)
    ____ = (__pcc_vars[__pcc_index] ||= Value.new).value if __pcc_vars
    str = (__pcc_in.value_refs[1]  ||= Value.new).value
    __0 = __pcc_in.capt0.capture_string(@buffer)
    __0s = @pos + __pcc_in.capt0.range_start
    __0e = @pos + __pcc_in.capt0.range_end
    __0sl = @pos_loc + __pcc_in.capt0.start_loc
    __0el = @pos_loc + __pcc_in.capt0.end_loc
    __1 = __pcc_in.capts[0].capture_string(@buffer)
    __1s = @pos + __pcc_in.capts[0].range_start
    __1e = @pos + __pcc_in.capts[0].range_end
    __1sl = @pos_loc + __pcc_in.capts[0].start_loc
    __1el = @pos_loc + __pcc_in.capts[0].end_loc
    @ctx.error __0sl.linenum + 1, __0sl.charnum + 1, "Invalid directive: #{__1}"

    __pcc_vars[__pcc_index].value = ____ if __pcc_vars
  end

  def action_directive_value_0(__pcc_in, __pcc_vars, __pcc_index)
    ____ = (__pcc_vars[__pcc_index] ||= Value.new).value if __pcc_vars
    __0 = __pcc_in.capt0.capture_string(@buffer)
    __0s = @pos + __pcc_in.capt0.range_start
    __0e = @pos + __pcc_in.capt0.range_end
    __0sl = @pos_loc + __pcc_in.capt0.start_loc
    __0el = @pos_loc + __pcc_in.capt0.end_loc
    @ctx.capture_in_code = true

    __pcc_vars[__pcc_index].value = ____ if __pcc_vars
  end

  def action_lang_strings_0(__pcc_in, __pcc_vars, __pcc_index)
    ____ = (__pcc_vars[__pcc_index] ||= Value.new).value if __pcc_vars
    strings = (__pcc_in.value_refs[0]  ||= Value.new).value
    string = (__pcc_in.value_refs[1]  ||= Value.new).value
    __0 = __pcc_in.capt0.capture_string(@buffer)
    __0s = @pos + __pcc_in.capt0.range_start
    __0e = @pos + __pcc_in.capt0.range_end
    __0sl = @pos_loc + __pcc_in.capt0.start_loc
    __0el = @pos_loc + __pcc_in.capt0.end_loc
    strings.push(string) if string; ____ = strings

    __pcc_vars[__pcc_index].value = ____ if __pcc_vars
  end

  def action_lang_strings_1(__pcc_in, __pcc_vars, __pcc_index)
    ____ = (__pcc_vars[__pcc_index] ||= Value.new).value if __pcc_vars
    string = (__pcc_in.value_refs[1]  ||= Value.new).value
    __0 = __pcc_in.capt0.capture_string(@buffer)
    __0s = @pos + __pcc_in.capt0.range_start
    __0e = @pos + __pcc_in.capt0.range_end
    __0sl = @pos_loc + __pcc_in.capt0.start_loc
    __0el = @pos_loc + __pcc_in.capt0.end_loc
    ____ = string ? [string] : []

    __pcc_vars[__pcc_index].value = ____ if __pcc_vars
  end

  def action_lang_string_0(__pcc_in, __pcc_vars, __pcc_index)
    ____ = (__pcc_vars[__pcc_index] ||= Value.new).value if __pcc_vars
    string = (__pcc_in.value_refs[0]  ||= Value.new).value
    __0 = __pcc_in.capt0.capture_string(@buffer)
    __0s = @pos + __pcc_in.capt0.range_start
    __0e = @pos + __pcc_in.capt0.range_end
    __0sl = @pos_loc + __pcc_in.capt0.start_loc
    __0el = @pos_loc + __pcc_in.capt0.end_loc
    ____ = string

    __pcc_vars[__pcc_index].value = ____ if __pcc_vars
  end

  def action_lang_string_1(__pcc_in, __pcc_vars, __pcc_index)
    ____ = (__pcc_vars[__pcc_index] ||= Value.new).value if __pcc_vars
    string = (__pcc_in.value_refs[0]  ||= Value.new).value
    __0 = __pcc_in.capt0.capture_string(@buffer)
    __0s = @pos + __pcc_in.capt0.range_start
    __0e = @pos + __pcc_in.capt0.range_end
    __0sl = @pos_loc + __pcc_in.capt0.start_loc
    __0el = @pos_loc + __pcc_in.capt0.end_loc
    __1 = __pcc_in.capts[0].capture_string(@buffer)
    __1s = @pos + __pcc_in.capts[0].range_start
    __1e = @pos + __pcc_in.capts[0].range_end
    __1sl = @pos_loc + __pcc_in.capts[0].start_loc
    __1el = @pos_loc + __pcc_in.capts[0].end_loc
    ____ = @ctx.lang == __1.to_sym ? string : nil

    __pcc_vars[__pcc_index].value = ____ if __pcc_vars
  end

  def action_rule_0(__pcc_in, __pcc_vars, __pcc_index)
    ____ = (__pcc_vars[__pcc_index] ||= Value.new).value if __pcc_vars
    name = (__pcc_in.value_refs[0]  ||= Value.new).value
    expr = (__pcc_in.value_refs[1]  ||= Value.new).value
    __0 = __pcc_in.capt0.capture_string(@buffer)
    __0s = @pos + __pcc_in.capt0.range_start
    __0e = @pos + __pcc_in.capt0.range_end
    __0sl = @pos_loc + __pcc_in.capt0.start_loc
    __0el = @pos_loc + __pcc_in.capt0.end_loc
    return unless expr
    rule =  Packcr::Node::RuleNode.new(expr, name, __0sl.linenum, __0sl.charnum)
    @ctx.root.rules << rule

    __pcc_vars[__pcc_index].value = ____ if __pcc_vars
  end

  def action_expression_0(__pcc_in, __pcc_vars, __pcc_index)
    ____ = (__pcc_vars[__pcc_index] ||= Value.new).value if __pcc_vars
    expr = (__pcc_in.value_refs[0]  ||= Value.new).value
    seq = (__pcc_in.value_refs[1]  ||= Value.new).value
    __0 = __pcc_in.capt0.capture_string(@buffer)
    __0s = @pos + __pcc_in.capt0.range_start
    __0e = @pos + __pcc_in.capt0.range_end
    __0sl = @pos_loc + __pcc_in.capt0.start_loc
    __0el = @pos_loc + __pcc_in.capt0.end_loc
    ____ = expr.alt(seq)

    __pcc_vars[__pcc_index].value = ____ if __pcc_vars
  end

  def action_expression_1(__pcc_in, __pcc_vars, __pcc_index)
    ____ = (__pcc_vars[__pcc_index] ||= Value.new).value if __pcc_vars
    seq = (__pcc_in.value_refs[1]  ||= Value.new).value
    __0 = __pcc_in.capt0.capture_string(@buffer)
    __0s = @pos + __pcc_in.capt0.range_start
    __0e = @pos + __pcc_in.capt0.range_end
    __0sl = @pos_loc + __pcc_in.capt0.start_loc
    __0el = @pos_loc + __pcc_in.capt0.end_loc
    ____ = seq

    __pcc_vars[__pcc_index].value = ____ if __pcc_vars
  end

  def action_sequence_0(__pcc_in, __pcc_vars, __pcc_index)
    ____ = (__pcc_vars[__pcc_index] ||= Value.new).value if __pcc_vars
    seq = (__pcc_in.value_refs[0]  ||= Value.new).value
    expr = (__pcc_in.value_refs[1]  ||= Value.new).value
    __0 = __pcc_in.capt0.capture_string(@buffer)
    __0s = @pos + __pcc_in.capt0.range_start
    __0e = @pos + __pcc_in.capt0.range_end
    __0sl = @pos_loc + __pcc_in.capt0.start_loc
    __0el = @pos_loc + __pcc_in.capt0.end_loc
    ____ = seq.seq(expr, cut: true)

    __pcc_vars[__pcc_index].value = ____ if __pcc_vars
  end

  def action_sequence_1(__pcc_in, __pcc_vars, __pcc_index)
    ____ = (__pcc_vars[__pcc_index] ||= Value.new).value if __pcc_vars
    seq = (__pcc_in.value_refs[0]  ||= Value.new).value
    code = (__pcc_in.value_refs[2]  ||= Value.new).value
    __0 = __pcc_in.capt0.capture_string(@buffer)
    __0s = @pos + __pcc_in.capt0.range_start
    __0e = @pos + __pcc_in.capt0.range_end
    __0sl = @pos_loc + __pcc_in.capt0.start_loc
    __0el = @pos_loc + __pcc_in.capt0.end_loc
    ____ = code ? Packcr::Node::ErrorNode.new(seq, Packcr::CodeBlock.new(code, __0sl.linenum, __0sl.charnum)) : seq

    __pcc_vars[__pcc_index].value = ____ if __pcc_vars
  end

  def action_sequence_2(__pcc_in, __pcc_vars, __pcc_index)
    ____ = (__pcc_vars[__pcc_index] ||= Value.new).value if __pcc_vars
    seq = (__pcc_in.value_refs[0]  ||= Value.new).value
    expr = (__pcc_in.value_refs[1]  ||= Value.new).value
    __0 = __pcc_in.capt0.capture_string(@buffer)
    __0s = @pos + __pcc_in.capt0.range_start
    __0e = @pos + __pcc_in.capt0.range_end
    __0sl = @pos_loc + __pcc_in.capt0.start_loc
    __0el = @pos_loc + __pcc_in.capt0.end_loc
    ____ = seq.seq(expr)

    __pcc_vars[__pcc_index].value = ____ if __pcc_vars
  end

  def action_sequence_3(__pcc_in, __pcc_vars, __pcc_index)
    ____ = (__pcc_vars[__pcc_index] ||= Value.new).value if __pcc_vars
    expr = (__pcc_in.value_refs[1]  ||= Value.new).value
    __0 = __pcc_in.capt0.capture_string(@buffer)
    __0s = @pos + __pcc_in.capt0.range_start
    __0e = @pos + __pcc_in.capt0.range_end
    __0sl = @pos_loc + __pcc_in.capt0.start_loc
    __0el = @pos_loc + __pcc_in.capt0.end_loc
    ____ = expr

    __pcc_vars[__pcc_index].value = ____ if __pcc_vars
  end

  def action_term_0(__pcc_in, __pcc_vars, __pcc_index)
    ____ = (__pcc_vars[__pcc_index] ||= Value.new).value if __pcc_vars
    node = (__pcc_in.value_refs[0]  ||= Value.new).value
    __0 = __pcc_in.capt0.capture_string(@buffer)
    __0s = @pos + __pcc_in.capt0.range_start
    __0e = @pos + __pcc_in.capt0.range_end
    __0sl = @pos_loc + __pcc_in.capt0.start_loc
    __0el = @pos_loc + __pcc_in.capt0.end_loc
    ____ = Packcr::Node::PredicateNode.new(node)

    __pcc_vars[__pcc_index].value = ____ if __pcc_vars
  end

  def action_term_1(__pcc_in, __pcc_vars, __pcc_index)
    ____ = (__pcc_vars[__pcc_index] ||= Value.new).value if __pcc_vars
    node = (__pcc_in.value_refs[0]  ||= Value.new).value
    __0 = __pcc_in.capt0.capture_string(@buffer)
    __0s = @pos + __pcc_in.capt0.range_start
    __0e = @pos + __pcc_in.capt0.range_end
    __0sl = @pos_loc + __pcc_in.capt0.start_loc
    __0el = @pos_loc + __pcc_in.capt0.end_loc
    ____ = Packcr::Node::PredicateNode.new(node, true)

    __pcc_vars[__pcc_index].value = ____ if __pcc_vars
  end

  def action_term_2(__pcc_in, __pcc_vars, __pcc_index)
    ____ = (__pcc_vars[__pcc_index] ||= Value.new).value if __pcc_vars
    node = (__pcc_in.value_refs[0]  ||= Value.new).value
    __0 = __pcc_in.capt0.capture_string(@buffer)
    __0s = @pos + __pcc_in.capt0.range_start
    __0e = @pos + __pcc_in.capt0.range_end
    __0sl = @pos_loc + __pcc_in.capt0.start_loc
    __0el = @pos_loc + __pcc_in.capt0.end_loc
    ____ = node

    __pcc_vars[__pcc_index].value = ____ if __pcc_vars
  end

  def action_quantity_0(__pcc_in, __pcc_vars, __pcc_index)
    ____ = (__pcc_vars[__pcc_index] ||= Value.new).value if __pcc_vars
    node = (__pcc_in.value_refs[0]  ||= Value.new).value
    __0 = __pcc_in.capt0.capture_string(@buffer)
    __0s = @pos + __pcc_in.capt0.range_start
    __0e = @pos + __pcc_in.capt0.range_end
    __0sl = @pos_loc + __pcc_in.capt0.start_loc
    __0el = @pos_loc + __pcc_in.capt0.end_loc
    ____ = Packcr::Node::QuantityNode.new(node, 0, -1)

    __pcc_vars[__pcc_index].value = ____ if __pcc_vars
  end

  def action_quantity_1(__pcc_in, __pcc_vars, __pcc_index)
    ____ = (__pcc_vars[__pcc_index] ||= Value.new).value if __pcc_vars
    node = (__pcc_in.value_refs[0]  ||= Value.new).value
    __0 = __pcc_in.capt0.capture_string(@buffer)
    __0s = @pos + __pcc_in.capt0.range_start
    __0e = @pos + __pcc_in.capt0.range_end
    __0sl = @pos_loc + __pcc_in.capt0.start_loc
    __0el = @pos_loc + __pcc_in.capt0.end_loc
    ____ = Packcr::Node::QuantityNode.new(node, 1, -1)

    __pcc_vars[__pcc_index].value = ____ if __pcc_vars
  end

  def action_quantity_2(__pcc_in, __pcc_vars, __pcc_index)
    ____ = (__pcc_vars[__pcc_index] ||= Value.new).value if __pcc_vars
    node = (__pcc_in.value_refs[0]  ||= Value.new).value
    __0 = __pcc_in.capt0.capture_string(@buffer)
    __0s = @pos + __pcc_in.capt0.range_start
    __0e = @pos + __pcc_in.capt0.range_end
    __0sl = @pos_loc + __pcc_in.capt0.start_loc
    __0el = @pos_loc + __pcc_in.capt0.end_loc
    ____ = Packcr::Node::QuantityNode.new(node, 0, 1)

    __pcc_vars[__pcc_index].value = ____ if __pcc_vars
  end

  def action_quantity_3(__pcc_in, __pcc_vars, __pcc_index)
    ____ = (__pcc_vars[__pcc_index] ||= Value.new).value if __pcc_vars
    node = (__pcc_in.value_refs[0]  ||= Value.new).value
    __0 = __pcc_in.capt0.capture_string(@buffer)
    __0s = @pos + __pcc_in.capt0.range_start
    __0e = @pos + __pcc_in.capt0.range_end
    __0sl = @pos_loc + __pcc_in.capt0.start_loc
    __0el = @pos_loc + __pcc_in.capt0.end_loc
    ____ = node

    __pcc_vars[__pcc_index].value = ____ if __pcc_vars
  end

  def action_primary_0(__pcc_in, __pcc_vars, __pcc_index)
    ____ = (__pcc_vars[__pcc_index] ||= Value.new).value if __pcc_vars
    code = (__pcc_in.value_refs[0]  ||= Value.new).value
    __0 = __pcc_in.capt0.capture_string(@buffer)
    __0s = @pos + __pcc_in.capt0.range_start
    __0e = @pos + __pcc_in.capt0.range_end
    __0sl = @pos_loc + __pcc_in.capt0.start_loc
    __0el = @pos_loc + __pcc_in.capt0.end_loc
    ____ = code && Packcr::Node::ActionNode.new(Packcr::CodeBlock.new(code, __0sl.linenum, __0sl.charnum))

    __pcc_vars[__pcc_index].value = ____ if __pcc_vars
  end

  def action_primary_1(__pcc_in, __pcc_vars, __pcc_index)
    ____ = (__pcc_vars[__pcc_index] ||= Value.new).value if __pcc_vars
    var_name = (__pcc_in.value_refs[1]  ||= Value.new).value
    name = (__pcc_in.value_refs[2]  ||= Value.new).value
    __0 = __pcc_in.capt0.capture_string(@buffer)
    __0s = @pos + __pcc_in.capt0.range_start
    __0e = @pos + __pcc_in.capt0.range_end
    __0sl = @pos_loc + __pcc_in.capt0.start_loc
    __0el = @pos_loc + __pcc_in.capt0.end_loc
    ____ = Packcr::Node::ReferenceNode.new(name, var_name, __0sl.linenum, __0sl.charnum)

    __pcc_vars[__pcc_index].value = ____ if __pcc_vars
  end

  def action_primary_2(__pcc_in, __pcc_vars, __pcc_index)
    ____ = (__pcc_vars[__pcc_index] ||= Value.new).value if __pcc_vars
    name = (__pcc_in.value_refs[2]  ||= Value.new).value
    __0 = __pcc_in.capt0.capture_string(@buffer)
    __0s = @pos + __pcc_in.capt0.range_start
    __0e = @pos + __pcc_in.capt0.range_end
    __0sl = @pos_loc + __pcc_in.capt0.start_loc
    __0el = @pos_loc + __pcc_in.capt0.end_loc
    ref = Packcr::Node::ReferenceNode.new(name, "_out", __0sl.linenum, __0sl.charnum)
    code = @ctx.pass_value_code("_out")
    act = Packcr::Node::ActionNode.new(Packcr::CodeBlock.new(code, __0sl.linenum, __0sl.charnum))
    ____ = ref.seq(act)

    __pcc_vars[__pcc_index].value = ____ if __pcc_vars
  end

  def action_primary_3(__pcc_in, __pcc_vars, __pcc_index)
    ____ = (__pcc_vars[__pcc_index] ||= Value.new).value if __pcc_vars
    name = (__pcc_in.value_refs[2]  ||= Value.new).value
    __0 = __pcc_in.capt0.capture_string(@buffer)
    __0s = @pos + __pcc_in.capt0.range_start
    __0e = @pos + __pcc_in.capt0.range_end
    __0sl = @pos_loc + __pcc_in.capt0.start_loc
    __0el = @pos_loc + __pcc_in.capt0.end_loc
    ____ = Packcr::Node::ReferenceNode.new(name, nil, __0sl.linenum, __0sl.charnum)

    __pcc_vars[__pcc_index].value = ____ if __pcc_vars
  end

  def action_primary_4(__pcc_in, __pcc_vars, __pcc_index)
    ____ = (__pcc_vars[__pcc_index] ||= Value.new).value if __pcc_vars
    expr = (__pcc_in.value_refs[3]  ||= Value.new).value
    __0 = __pcc_in.capt0.capture_string(@buffer)
    __0s = @pos + __pcc_in.capt0.range_start
    __0e = @pos + __pcc_in.capt0.range_end
    __0sl = @pos_loc + __pcc_in.capt0.start_loc
    __0el = @pos_loc + __pcc_in.capt0.end_loc
    ____ = expr

    __pcc_vars[__pcc_index].value = ____ if __pcc_vars
  end

  def action_primary_5(__pcc_in, __pcc_vars, __pcc_index)
    ____ = (__pcc_vars[__pcc_index] ||= Value.new).value if __pcc_vars
    expr = (__pcc_in.value_refs[3]  ||= Value.new).value
    __0 = __pcc_in.capt0.capture_string(@buffer)
    __0s = @pos + __pcc_in.capt0.range_start
    __0e = @pos + __pcc_in.capt0.range_end
    __0sl = @pos_loc + __pcc_in.capt0.start_loc
    __0el = @pos_loc + __pcc_in.capt0.end_loc
    ____ = Packcr::Node::CaptureNode.new(expr)

    __pcc_vars[__pcc_index].value = ____ if __pcc_vars
  end

  def action_primary_6(__pcc_in, __pcc_vars, __pcc_index)
    ____ = (__pcc_vars[__pcc_index] ||= Value.new).value if __pcc_vars
    __0 = __pcc_in.capt0.capture_string(@buffer)
    __0s = @pos + __pcc_in.capt0.range_start
    __0e = @pos + __pcc_in.capt0.range_end
    __0sl = @pos_loc + __pcc_in.capt0.start_loc
    __0el = @pos_loc + __pcc_in.capt0.end_loc
    __1 = __pcc_in.capts[0].capture_string(@buffer)
    __1s = @pos + __pcc_in.capts[0].range_start
    __1e = @pos + __pcc_in.capts[0].range_end
    __1sl = @pos_loc + __pcc_in.capts[0].start_loc
    __1el = @pos_loc + __pcc_in.capts[0].end_loc
    ____ = Packcr::Node::ExpandNode.new(__1.to_i - 1, __0sl.linenum, __0sl.charnum)

    __pcc_vars[__pcc_index].value = ____ if __pcc_vars
  end

  def action_primary_7(__pcc_in, __pcc_vars, __pcc_index)
    ____ = (__pcc_vars[__pcc_index] ||= Value.new).value if __pcc_vars
    __0 = __pcc_in.capt0.capture_string(@buffer)
    __0s = @pos + __pcc_in.capt0.range_start
    __0e = @pos + __pcc_in.capt0.range_end
    __0sl = @pos_loc + __pcc_in.capt0.start_loc
    __0el = @pos_loc + __pcc_in.capt0.end_loc
    ____ = Packcr::Node::CharclassNode.new

    __pcc_vars[__pcc_index].value = ____ if __pcc_vars
  end

  def action_primary_8(__pcc_in, __pcc_vars, __pcc_index)
    ____ = (__pcc_vars[__pcc_index] ||= Value.new).value if __pcc_vars
    str = (__pcc_in.value_refs[4]  ||= Value.new).value
    __0 = __pcc_in.capt0.capture_string(@buffer)
    __0s = @pos + __pcc_in.capt0.range_start
    __0e = @pos + __pcc_in.capt0.range_end
    __0sl = @pos_loc + __pcc_in.capt0.start_loc
    __0el = @pos_loc + __pcc_in.capt0.end_loc
    ____ = Packcr::Node::CharclassNode.new(Packcr.unescape_string(str, true))

    __pcc_vars[__pcc_index].value = ____ if __pcc_vars
  end

  def action_primary_9(__pcc_in, __pcc_vars, __pcc_index)
    ____ = (__pcc_vars[__pcc_index] ||= Value.new).value if __pcc_vars
    str = (__pcc_in.value_refs[4]  ||= Value.new).value
    __0 = __pcc_in.capt0.capture_string(@buffer)
    __0s = @pos + __pcc_in.capt0.range_start
    __0e = @pos + __pcc_in.capt0.range_end
    __0sl = @pos_loc + __pcc_in.capt0.start_loc
    __0el = @pos_loc + __pcc_in.capt0.end_loc
    ____ = Packcr::Node::StringNode.new(Packcr.unescape_string(str, false))

    __pcc_vars[__pcc_index].value = ____ if __pcc_vars
  end

  def action_primary_10(__pcc_in, __pcc_vars, __pcc_index)
    ____ = (__pcc_vars[__pcc_index] ||= Value.new).value if __pcc_vars
    str = (__pcc_in.value_refs[4]  ||= Value.new).value
    __0 = __pcc_in.capt0.capture_string(@buffer)
    __0s = @pos + __pcc_in.capt0.range_start
    __0e = @pos + __pcc_in.capt0.range_end
    __0sl = @pos_loc + __pcc_in.capt0.start_loc
    __0el = @pos_loc + __pcc_in.capt0.end_loc
    ____ = Packcr::Node::StringNode.new(Packcr.unescape_string(str, false))

    __pcc_vars[__pcc_index].value = ____ if __pcc_vars
  end

  def action_character_class_0(__pcc_in, __pcc_vars, __pcc_index)
    ____ = (__pcc_vars[__pcc_index] ||= Value.new).value if __pcc_vars
    __0 = __pcc_in.capt0.capture_string(@buffer)
    __0s = @pos + __pcc_in.capt0.range_start
    __0e = @pos + __pcc_in.capt0.range_end
    __0sl = @pos_loc + __pcc_in.capt0.start_loc
    __0el = @pos_loc + __pcc_in.capt0.end_loc
    __1 = __pcc_in.capts[0].capture_string(@buffer)
    __1s = @pos + __pcc_in.capts[0].range_start
    __1e = @pos + __pcc_in.capts[0].range_end
    __1sl = @pos_loc + __pcc_in.capts[0].start_loc
    __1el = @pos_loc + __pcc_in.capts[0].end_loc
    ____ = __1

    __pcc_vars[__pcc_index].value = ____ if __pcc_vars
  end

  def action_lang_code_block_0(__pcc_in, __pcc_vars, __pcc_index)
    ____ = (__pcc_vars[__pcc_index] ||= Value.new).value if __pcc_vars
    code = (__pcc_in.value_refs[0]  ||= Value.new).value
    __0 = __pcc_in.capt0.capture_string(@buffer)
    __0s = @pos + __pcc_in.capt0.range_start
    __0e = @pos + __pcc_in.capt0.range_end
    __0sl = @pos_loc + __pcc_in.capt0.start_loc
    __0el = @pos_loc + __pcc_in.capt0.end_loc
    ____ = code

    __pcc_vars[__pcc_index].value = ____ if __pcc_vars
  end

  def action_lang_code_block_1(__pcc_in, __pcc_vars, __pcc_index)
    ____ = (__pcc_vars[__pcc_index] ||= Value.new).value if __pcc_vars
    code = (__pcc_in.value_refs[0]  ||= Value.new).value
    __0 = __pcc_in.capt0.capture_string(@buffer)
    __0s = @pos + __pcc_in.capt0.range_start
    __0e = @pos + __pcc_in.capt0.range_end
    __0sl = @pos_loc + __pcc_in.capt0.start_loc
    __0el = @pos_loc + __pcc_in.capt0.end_loc
    __1 = __pcc_in.capts[0].capture_string(@buffer)
    __1s = @pos + __pcc_in.capts[0].range_start
    __1e = @pos + __pcc_in.capts[0].range_end
    __1sl = @pos_loc + __pcc_in.capts[0].start_loc
    __1el = @pos_loc + __pcc_in.capts[0].end_loc
    ____ = @ctx.lang == __1.to_sym ? code : nil

    __pcc_vars[__pcc_index].value = ____ if __pcc_vars
  end

  def action_code_block_0(__pcc_in, __pcc_vars, __pcc_index)
    ____ = (__pcc_vars[__pcc_index] ||= Value.new).value if __pcc_vars
    code = (__pcc_in.value_refs[0]  ||= Value.new).value
    __0 = __pcc_in.capt0.capture_string(@buffer)
    __0s = @pos + __pcc_in.capt0.range_start
    __0e = @pos + __pcc_in.capt0.range_end
    __0sl = @pos_loc + __pcc_in.capt0.start_loc
    __0el = @pos_loc + __pcc_in.capt0.end_loc
    ____ = code

    __pcc_vars[__pcc_index].value = ____ if __pcc_vars
  end

  def action_code_block_1(__pcc_in, __pcc_vars, __pcc_index)
    ____ = (__pcc_vars[__pcc_index] ||= Value.new).value if __pcc_vars
    code = (__pcc_in.value_refs[0]  ||= Value.new).value
    __0 = __pcc_in.capt0.capture_string(@buffer)
    __0s = @pos + __pcc_in.capt0.range_start
    __0e = @pos + __pcc_in.capt0.range_end
    __0sl = @pos_loc + __pcc_in.capt0.start_loc
    __0el = @pos_loc + __pcc_in.capt0.end_loc
    ____ = code.gsub("$", @ctx.lang == :rb ? "__" : "_")

    __pcc_vars[__pcc_index].value = ____ if __pcc_vars
  end

  def action_plain_code_block_0(__pcc_in, __pcc_vars, __pcc_index)
    ____ = (__pcc_vars[__pcc_index] ||= Value.new).value if __pcc_vars
    __0 = __pcc_in.capt0.capture_string(@buffer)
    __0s = @pos + __pcc_in.capt0.range_start
    __0e = @pos + __pcc_in.capt0.range_end
    __0sl = @pos_loc + __pcc_in.capt0.start_loc
    __0el = @pos_loc + __pcc_in.capt0.end_loc
    __1 = __pcc_in.capts[0].capture_string(@buffer)
    __1s = @pos + __pcc_in.capts[0].range_start
    __1e = @pos + __pcc_in.capts[0].range_end
    __1sl = @pos_loc + __pcc_in.capts[0].start_loc
    __1el = @pos_loc + __pcc_in.capts[0].end_loc
    ____ = __1

    __pcc_vars[__pcc_index].value = ____ if __pcc_vars
  end

  def action_quotation_single_0(__pcc_in, __pcc_vars, __pcc_index)
    ____ = (__pcc_vars[__pcc_index] ||= Value.new).value if __pcc_vars
    __0 = __pcc_in.capt0.capture_string(@buffer)
    __0s = @pos + __pcc_in.capt0.range_start
    __0e = @pos + __pcc_in.capt0.range_end
    __0sl = @pos_loc + __pcc_in.capt0.start_loc
    __0el = @pos_loc + __pcc_in.capt0.end_loc
    __1 = __pcc_in.capts[0].capture_string(@buffer)
    __1s = @pos + __pcc_in.capts[0].range_start
    __1e = @pos + __pcc_in.capts[0].range_end
    __1sl = @pos_loc + __pcc_in.capts[0].start_loc
    __1el = @pos_loc + __pcc_in.capts[0].end_loc
    ____ = __1

    __pcc_vars[__pcc_index].value = ____ if __pcc_vars
  end

  def action_quotation_double_0(__pcc_in, __pcc_vars, __pcc_index)
    ____ = (__pcc_vars[__pcc_index] ||= Value.new).value if __pcc_vars
    __0 = __pcc_in.capt0.capture_string(@buffer)
    __0s = @pos + __pcc_in.capt0.range_start
    __0e = @pos + __pcc_in.capt0.range_end
    __0sl = @pos_loc + __pcc_in.capt0.start_loc
    __0el = @pos_loc + __pcc_in.capt0.end_loc
    __1 = __pcc_in.capts[0].capture_string(@buffer)
    __1s = @pos + __pcc_in.capts[0].range_start
    __1e = @pos + __pcc_in.capts[0].range_end
    __1sl = @pos_loc + __pcc_in.capts[0].start_loc
    __1el = @pos_loc + __pcc_in.capts[0].end_loc
    ____ = __1

    __pcc_vars[__pcc_index].value = ____ if __pcc_vars
  end

  def action_identifier_0(__pcc_in, __pcc_vars, __pcc_index)
    ____ = (__pcc_vars[__pcc_index] ||= Value.new).value if __pcc_vars
    __0 = __pcc_in.capt0.capture_string(@buffer)
    __0s = @pos + __pcc_in.capt0.range_start
    __0e = @pos + __pcc_in.capt0.range_end
    __0sl = @pos_loc + __pcc_in.capt0.start_loc
    __0el = @pos_loc + __pcc_in.capt0.end_loc
    ____ = __0

    __pcc_vars[__pcc_index].value = ____ if __pcc_vars
  end

  def action_footer_0(__pcc_in, __pcc_vars, __pcc_index)
    ____ = (__pcc_vars[__pcc_index] ||= Value.new).value if __pcc_vars
    __0 = __pcc_in.capt0.capture_string(@buffer)
    __0s = @pos + __pcc_in.capt0.range_start
    __0e = @pos + __pcc_in.capt0.range_end
    __0sl = @pos_loc + __pcc_in.capt0.start_loc
    __0el = @pos_loc + __pcc_in.capt0.end_loc
    __1 = __pcc_in.capts[0].capture_string(@buffer)
    __1s = @pos + __pcc_in.capts[0].range_start
    __1e = @pos + __pcc_in.capts[0].range_end
    __1sl = @pos_loc + __pcc_in.capts[0].start_loc
    __1el = @pos_loc + __pcc_in.capts[0].end_loc
    @ctx.code(:lsource) << Packcr::CodeBlock.new(__1, __1sl.linenum, __1sl.charnum)

    __pcc_vars[__pcc_index].value = ____ if __pcc_vars
  end

  def evaluate_rule_statement
    answer = ThunkChunk.new
    answer.pos = @cur
    answer.pos_loc = @cur_loc
    debug { warn "#{ "  " * @level}EVAL    statement #{answer.pos} #{@buffer[answer.pos..-1].inspect}" }
    @level += 1
    answer.resize_captures(0)
    catch(0) do
      catch(1) do
        pos2 = @cur
        p_loc2 = @cur_loc
        n2 = answer.thunks.length
        if apply_rule(:evaluate_rule_comment, answer.thunks, nil, 0)
          throw(1)
        end
        @cur = pos2
        @cur_loc = p_loc2
        answer.thunks[n2..-1] = []
        if apply_rule(:evaluate_rule_spaces, answer.thunks, nil, 0)
          throw(1)
        end
        @cur = pos2
        @cur_loc = p_loc2
        answer.thunks[n2..-1] = []
        if apply_rule(:evaluate_rule_directive_include, answer.thunks, nil, 0)
          throw(1)
        end
        @cur = pos2
        @cur_loc = p_loc2
        answer.thunks[n2..-1] = []
        if apply_rule(:evaluate_rule_directive_string, answer.thunks, nil, 0)
          throw(1)
        end
        @cur = pos2
        @cur_loc = p_loc2
        answer.thunks[n2..-1] = []
        if apply_rule(:evaluate_rule_directive_value, answer.thunks, nil, 0)
          throw(1)
        end
        @cur = pos2
        @cur_loc = p_loc2
        answer.thunks[n2..-1] = []
        if apply_rule(:evaluate_rule_rule, answer.thunks, nil, 0)
          throw(1)
        end
        @cur = pos2
        @cur_loc = p_loc2
        answer.thunks[n2..-1] = []
        if apply_rule(:evaluate_rule_footer, answer.thunks, nil, 0)
          throw(1)
        end
        @cur = pos2
        @cur_loc = p_loc2
        answer.thunks[n2..-1] = []
        catch(2) do
          catch(4) do
            catch(3) do
              if !apply_rule(:evaluate_rule_EOF, answer.thunks, nil, 0)
                throw(3)
              end
              throw(4)
            end

            action_statement_0(
              ThunkLeaf.new(
                :action_statement_0,
                Capture.new(
                  answer.pos, @cur,
                  answer.pos_loc,@cur_loc,
                ),
                {},
                {},
              ),
              nil,
              0
            )

            throw(2)
          end
          throw(1)
        end
        @cur = pos2
        @cur_loc = p_loc2
        answer.thunks[n2..-1] = []
        throw(0)
      end
      @level -= 1
      debug { warn "#{ "  " * @level}MATCH   statement #{answer.pos} #{@buffer[answer.pos...@cur].inspect}" }
      return answer
    end
    @level -= 1
    debug { warn "#{ "  " * @level}NOMATCH statement #{answer.pos} #{@buffer[answer.pos...@cur].inspect}" }
    return nil
  end

  def evaluate_rule_supported_language
    answer = ThunkChunk.new
    answer.pos = @cur
    answer.pos_loc = @cur_loc
    debug { warn "#{ "  " * @level}EVAL    supported_language #{answer.pos} #{@buffer[answer.pos..-1].inspect}" }
    @level += 1
    answer.resize_captures(0)
    catch(0) do
      catch(1) do
        pos2 = @cur
        p_loc2 = @cur_loc
        n2 = answer.thunks.length
        catch(2) do
          if (
            refill_buffer(1) < 1 ||
            @buffer[@cur] != "c"
          )
            throw(2)
          end
          @cur_loc = @cur_loc.forward(@buffer, @cur, 1)
          @cur += 1
          throw(1)
        end
        @cur = pos2
        @cur_loc = p_loc2
        answer.thunks[n2..-1] = []
        catch(3) do
          if (
            refill_buffer(2) < 2 ||
            @buffer[@cur, 2] != "rb"
          )
            throw(3)
          end
          @cur_loc = @cur_loc.forward(@buffer, @cur, 2)
          @cur += 2
          throw(1)
        end
        @cur = pos2
        @cur_loc = p_loc2
        answer.thunks[n2..-1] = []
        catch(4) do
          if !apply_rule(:evaluate_rule_identifier, answer.thunks, nil, 0)
            throw(4)
          end
          answer.thunks.push(
            ThunkLeaf.new(
              :action_supported_language_0,
              Capture.new(
                answer.pos, @cur,
                answer.pos_loc, @cur_loc,
              ),
              {},
              {},
            )
          )
          throw(1)
        end
        @cur = pos2
        @cur_loc = p_loc2
        answer.thunks[n2..-1] = []
        throw(0)
      end
      @level -= 1
      debug { warn "#{ "  " * @level}MATCH   supported_language #{answer.pos} #{@buffer[answer.pos...@cur].inspect}" }
      return answer
    end
    @level -= 1
    debug { warn "#{ "  " * @level}NOMATCH supported_language #{answer.pos} #{@buffer[answer.pos...@cur].inspect}" }
    return nil
  end

  def evaluate_rule_comment
    answer = ThunkChunk.new
    answer.pos = @cur
    answer.pos_loc = @cur_loc
    debug { warn "#{ "  " * @level}EVAL    comment #{answer.pos} #{@buffer[answer.pos..-1].inspect}" }
    @level += 1
    answer.resize_captures(0)
    catch(0) do
      if (
        refill_buffer(1) < 1 ||
        @buffer[@cur] != "#"
      )
        throw(0)
      end
      @cur_loc = @cur_loc.forward(@buffer, @cur, 1)
      @cur += 1
      i3 = 0
      pos3 = nil
      p_loc3 = nil
      n3 = nil
      catch(1) do
        pos3 = @cur
        p_loc3 = @cur_loc
        n3 = answer.thunks.length
        if refill_buffer(1) < 1
          throw(1)
        end
        u4 = @buffer[@cur]
        if (
          u4 == "\n"
        )
          throw(1)
        end
        @cur_loc = @cur_loc.forward(@buffer, @cur, 1)
        @cur += 1
        i3 += 1
        if @cur != pos3
          redo
        end
        pos3 = nil
      end
      if pos3
        @cur = pos3
        @cur_loc = p_loc3
        answer.thunks[n3..-1] = []
      end
      catch(2) do
        pos3 = @cur
        p_loc3 = @cur_loc
        n3 = answer.thunks.length
        if apply_rule(:evaluate_rule_lf, answer.thunks, nil, 0)
          throw(2)
        end
        @cur = pos3
        @cur_loc = p_loc3
        answer.thunks[n3..-1] = []
        if apply_rule(:evaluate_rule_EOF, answer.thunks, nil, 0)
          throw(2)
        end
        @cur = pos3
        @cur_loc = p_loc3
        answer.thunks[n3..-1] = []
        throw(0)
      end
      @level -= 1
      debug { warn "#{ "  " * @level}MATCH   comment #{answer.pos} #{@buffer[answer.pos...@cur].inspect}" }
      return answer
    end
    @level -= 1
    debug { warn "#{ "  " * @level}NOMATCH comment #{answer.pos} #{@buffer[answer.pos...@cur].inspect}" }
    return nil
  end

  def evaluate_rule_directive_include
    answer = ThunkChunk.new
    answer.pos = @cur
    answer.pos_loc = @cur_loc
    debug { warn "#{ "  " * @level}EVAL    directive_include #{answer.pos} #{@buffer[answer.pos..-1].inspect}" }
    @level += 1
    answer.resize_captures(1)
    answer.values = {}
    catch(0) do
      catch(1) do
        pos2 = @cur
        p_loc2 = @cur_loc
        n2 = answer.thunks.length
        catch(2) do
          if (
            refill_buffer(12) < 12 ||
            @buffer[@cur, 12] != "%earlysource"
          )
            throw(2)
          end
          @cur_loc = @cur_loc.forward(@buffer, @cur, 12)
          @cur += 12
          if !apply_rule(:evaluate_rule_opt_spaces_or_comments, answer.thunks, nil, 0)
            throw(2)
          end
          if !apply_rule(:evaluate_rule_code_blocks, answer.thunks, answer.values, 0)
            throw(2)
          end
          answer.thunks.push(
            ThunkLeaf.new(
              :action_directive_include_0,
              Capture.new(
                answer.pos, @cur,
                answer.pos_loc, @cur_loc,
              ),
              answer.values.slice(0),
              {},
            )
          )
          throw(1)
        end
        @cur = pos2
        @cur_loc = p_loc2
        answer.thunks[n2..-1] = []
        catch(3) do
          if (
            refill_buffer(7) < 7 ||
            @buffer[@cur, 7] != "%source"
          )
            throw(3)
          end
          @cur_loc = @cur_loc.forward(@buffer, @cur, 7)
          @cur += 7
          if !apply_rule(:evaluate_rule_opt_spaces_or_comments, answer.thunks, nil, 0)
            throw(3)
          end
          if !apply_rule(:evaluate_rule_code_blocks, answer.thunks, answer.values, 0)
            throw(3)
          end
          answer.thunks.push(
            ThunkLeaf.new(
              :action_directive_include_1,
              Capture.new(
                answer.pos, @cur,
                answer.pos_loc, @cur_loc,
              ),
              answer.values.slice(0),
              {},
            )
          )
          throw(1)
        end
        @cur = pos2
        @cur_loc = p_loc2
        answer.thunks[n2..-1] = []
        catch(4) do
          if (
            refill_buffer(11) < 11 ||
            @buffer[@cur, 11] != "%lateheader"
          )
            throw(4)
          end
          @cur_loc = @cur_loc.forward(@buffer, @cur, 11)
          @cur += 11
          if !apply_rule(:evaluate_rule_opt_spaces_or_comments, answer.thunks, nil, 0)
            throw(4)
          end
          if !apply_rule(:evaluate_rule_code_blocks, answer.thunks, answer.values, 0)
            throw(4)
          end
          answer.thunks.push(
            ThunkLeaf.new(
              :action_directive_include_2,
              Capture.new(
                answer.pos, @cur,
                answer.pos_loc, @cur_loc,
              ),
              answer.values.slice(0),
              {},
            )
          )
          throw(1)
        end
        @cur = pos2
        @cur_loc = p_loc2
        answer.thunks[n2..-1] = []
        catch(5) do
          if (
            refill_buffer(11) < 11 ||
            @buffer[@cur, 11] != "%latesource"
          )
            throw(5)
          end
          @cur_loc = @cur_loc.forward(@buffer, @cur, 11)
          @cur += 11
          if !apply_rule(:evaluate_rule_opt_spaces_or_comments, answer.thunks, nil, 0)
            throw(5)
          end
          if !apply_rule(:evaluate_rule_code_blocks, answer.thunks, answer.values, 0)
            throw(5)
          end
          answer.thunks.push(
            ThunkLeaf.new(
              :action_directive_include_3,
              Capture.new(
                answer.pos, @cur,
                answer.pos_loc, @cur_loc,
              ),
              answer.values.slice(0),
              {},
            )
          )
          throw(1)
        end
        @cur = pos2
        @cur_loc = p_loc2
        answer.thunks[n2..-1] = []
        catch(6) do
          if (
            refill_buffer(7) < 7 ||
            @buffer[@cur, 7] != "%header"
          )
            throw(6)
          end
          @cur_loc = @cur_loc.forward(@buffer, @cur, 7)
          @cur += 7
          if !apply_rule(:evaluate_rule_opt_spaces_or_comments, answer.thunks, nil, 0)
            throw(6)
          end
          if !apply_rule(:evaluate_rule_code_blocks, answer.thunks, answer.values, 0)
            throw(6)
          end
          answer.thunks.push(
            ThunkLeaf.new(
              :action_directive_include_4,
              Capture.new(
                answer.pos, @cur,
                answer.pos_loc, @cur_loc,
              ),
              answer.values.slice(0),
              {},
            )
          )
          throw(1)
        end
        @cur = pos2
        @cur_loc = p_loc2
        answer.thunks[n2..-1] = []
        catch(7) do
          if (
            refill_buffer(9) < 9 ||
            @buffer[@cur, 9] != "%location"
          )
            throw(7)
          end
          @cur_loc = @cur_loc.forward(@buffer, @cur, 9)
          @cur += 9
          if !apply_rule(:evaluate_rule_opt_spaces_or_comments, answer.thunks, nil, 0)
            throw(7)
          end
          if !apply_rule(:evaluate_rule_code_blocks, answer.thunks, answer.values, 0)
            throw(7)
          end
          answer.thunks.push(
            ThunkLeaf.new(
              :action_directive_include_5,
              Capture.new(
                answer.pos, @cur,
                answer.pos_loc, @cur_loc,
              ),
              answer.values.slice(0),
              {},
            )
          )
          throw(1)
        end
        @cur = pos2
        @cur_loc = p_loc2
        answer.thunks[n2..-1] = []
        catch(8) do
          if (
            refill_buffer(11) < 11 ||
            @buffer[@cur, 11] != "%initialize"
          )
            throw(8)
          end
          @cur_loc = @cur_loc.forward(@buffer, @cur, 11)
          @cur += 11
          if !apply_rule(:evaluate_rule_opt_spaces_or_comments, answer.thunks, nil, 0)
            throw(8)
          end
          if !apply_rule(:evaluate_rule_code_blocks, answer.thunks, answer.values, 0)
            throw(8)
          end
          answer.thunks.push(
            ThunkLeaf.new(
              :action_directive_include_6,
              Capture.new(
                answer.pos, @cur,
                answer.pos_loc, @cur_loc,
              ),
              answer.values.slice(0),
              {},
            )
          )
          throw(1)
        end
        @cur = pos2
        @cur_loc = p_loc2
        answer.thunks[n2..-1] = []
        catch(9) do
          if (
            refill_buffer(12) < 12 ||
            @buffer[@cur, 12] != "%earlycommon"
          )
            throw(9)
          end
          @cur_loc = @cur_loc.forward(@buffer, @cur, 12)
          @cur += 12
          if !apply_rule(:evaluate_rule_opt_spaces_or_comments, answer.thunks, nil, 0)
            throw(9)
          end
          if !apply_rule(:evaluate_rule_code_blocks, answer.thunks, answer.values, 0)
            throw(9)
          end
          answer.thunks.push(
            ThunkLeaf.new(
              :action_directive_include_7,
              Capture.new(
                answer.pos, @cur,
                answer.pos_loc, @cur_loc,
              ),
              answer.values.slice(0),
              {},
            )
          )
          throw(1)
        end
        @cur = pos2
        @cur_loc = p_loc2
        answer.thunks[n2..-1] = []
        catch(10) do
          if (
            refill_buffer(7) < 7 ||
            @buffer[@cur, 7] != "%common"
          )
            throw(10)
          end
          @cur_loc = @cur_loc.forward(@buffer, @cur, 7)
          @cur += 7
          if !apply_rule(:evaluate_rule_opt_spaces_or_comments, answer.thunks, nil, 0)
            throw(10)
          end
          if !apply_rule(:evaluate_rule_code_blocks, answer.thunks, answer.values, 0)
            throw(10)
          end
          answer.thunks.push(
            ThunkLeaf.new(
              :action_directive_include_8,
              Capture.new(
                answer.pos, @cur,
                answer.pos_loc, @cur_loc,
              ),
              answer.values.slice(0),
              {},
            )
          )
          throw(1)
        end
        @cur = pos2
        @cur_loc = p_loc2
        answer.thunks[n2..-1] = []
        catch(11) do
          if (
            refill_buffer(1) < 1 ||
            @buffer[@cur] != "%"
          )
            throw(11)
          end
          @cur_loc = @cur_loc.forward(@buffer, @cur, 1)
          @cur += 1
          pos4 = @cur
          p_loc4 = @cur_loc
          if !apply_rule(:evaluate_rule_identifier, answer.thunks, nil, 0)
            throw(11)
          end
          q4 = @cur
          capt4 = answer.capts[0]
          capt4.range_start = pos4
          capt4.range_end = q4
          q_loc4 = @cur_loc
          capt4.start_loc = p_loc4
          capt4.end_loc = q_loc4
          if !apply_rule(:evaluate_rule_opt_spaces_or_comments, answer.thunks, nil, 0)
            throw(11)
          end
          if !apply_rule(:evaluate_rule_code_blocks, answer.thunks, answer.values, 0)
            throw(11)
          end
          answer.thunks.push(
            ThunkLeaf.new(
              :action_directive_include_9,
              Capture.new(
                answer.pos, @cur,
                answer.pos_loc, @cur_loc,
              ),
              answer.values.slice(0),
              answer.capts.slice(0),
            )
          )
          throw(1)
        end
        @cur = pos2
        @cur_loc = p_loc2
        answer.thunks[n2..-1] = []
        throw(0)
      end
      @level -= 1
      debug { warn "#{ "  " * @level}MATCH   directive_include #{answer.pos} #{@buffer[answer.pos...@cur].inspect}" }
      return answer
    end
    @level -= 1
    debug { warn "#{ "  " * @level}NOMATCH directive_include #{answer.pos} #{@buffer[answer.pos...@cur].inspect}" }
    return nil
  end

  def evaluate_rule_code_blocks
    answer = ThunkChunk.new
    answer.pos = @cur
    answer.pos_loc = @cur_loc
    debug { warn "#{ "  " * @level}EVAL    code_blocks #{answer.pos} #{@buffer[answer.pos..-1].inspect}" }
    @level += 1
    answer.resize_captures(0)
    answer.values = {}
    catch(0) do
      catch(1) do
        pos2 = @cur
        p_loc2 = @cur_loc
        n2 = answer.thunks.length
        catch(2) do
          if !apply_rule(:evaluate_rule_code_blocks, answer.thunks, answer.values, 0)
            throw(2)
          end
          if !apply_rule(:evaluate_rule_opt_spaces_or_comments, answer.thunks, nil, 0)
            throw(2)
          end
          if !apply_rule(:evaluate_rule_lang_code_block, answer.thunks, answer.values, 1)
            throw(2)
          end
          answer.thunks.push(
            ThunkLeaf.new(
              :action_code_blocks_0,
              Capture.new(
                answer.pos, @cur,
                answer.pos_loc, @cur_loc,
              ),
              answer.values.slice(0, 1),
              {},
            )
          )
          throw(1)
        end
        @cur = pos2
        @cur_loc = p_loc2
        answer.thunks[n2..-1] = []
        catch(3) do
          if !apply_rule(:evaluate_rule_lang_code_block, answer.thunks, answer.values, 1)
            throw(3)
          end
          answer.thunks.push(
            ThunkLeaf.new(
              :action_code_blocks_1,
              Capture.new(
                answer.pos, @cur,
                answer.pos_loc, @cur_loc,
              ),
              answer.values.slice(1),
              {},
            )
          )
          throw(1)
        end
        @cur = pos2
        @cur_loc = p_loc2
        answer.thunks[n2..-1] = []
        throw(0)
      end
      @level -= 1
      debug { warn "#{ "  " * @level}MATCH   code_blocks #{answer.pos} #{@buffer[answer.pos...@cur].inspect}" }
      return answer
    end
    @level -= 1
    debug { warn "#{ "  " * @level}NOMATCH code_blocks #{answer.pos} #{@buffer[answer.pos...@cur].inspect}" }
    return nil
  end

  def evaluate_rule_directive_string
    answer = ThunkChunk.new
    answer.pos = @cur
    answer.pos_loc = @cur_loc
    debug { warn "#{ "  " * @level}EVAL    directive_string #{answer.pos} #{@buffer[answer.pos..-1].inspect}" }
    @level += 1
    answer.resize_captures(1)
    answer.values = {}
    catch(0) do
      catch(1) do
        pos2 = @cur
        p_loc2 = @cur_loc
        n2 = answer.thunks.length
        catch(2) do
          if (
            refill_buffer(6) < 6 ||
            @buffer[@cur, 6] != "%value"
          )
            throw(2)
          end
          @cur_loc = @cur_loc.forward(@buffer, @cur, 6)
          @cur += 6
          if !apply_rule(:evaluate_rule_opt_spaces_or_comments, answer.thunks, nil, 0)
            throw(2)
          end
          if !apply_rule(:evaluate_rule_lang_strings, answer.thunks, answer.values, 0)
            throw(2)
          end
          answer.thunks.push(
            ThunkLeaf.new(
              :action_directive_string_0,
              Capture.new(
                answer.pos, @cur,
                answer.pos_loc, @cur_loc,
              ),
              answer.values.slice(0),
              {},
            )
          )
          throw(1)
        end
        @cur = pos2
        @cur_loc = p_loc2
        answer.thunks[n2..-1] = []
        catch(3) do
          if (
            refill_buffer(6) < 6 ||
            @buffer[@cur, 6] != "%auxil"
          )
            throw(3)
          end
          @cur_loc = @cur_loc.forward(@buffer, @cur, 6)
          @cur += 6
          if !apply_rule(:evaluate_rule_opt_spaces_or_comments, answer.thunks, nil, 0)
            throw(3)
          end
          if !apply_rule(:evaluate_rule_lang_strings, answer.thunks, answer.values, 0)
            throw(3)
          end
          answer.thunks.push(
            ThunkLeaf.new(
              :action_directive_string_1,
              Capture.new(
                answer.pos, @cur,
                answer.pos_loc, @cur_loc,
              ),
              answer.values.slice(0),
              {},
            )
          )
          throw(1)
        end
        @cur = pos2
        @cur_loc = p_loc2
        answer.thunks[n2..-1] = []
        catch(4) do
          if (
            refill_buffer(7) < 7 ||
            @buffer[@cur, 7] != "%prefix"
          )
            throw(4)
          end
          @cur_loc = @cur_loc.forward(@buffer, @cur, 7)
          @cur += 7
          if !apply_rule(:evaluate_rule_opt_spaces_or_comments, answer.thunks, nil, 0)
            throw(4)
          end
          if !apply_rule(:evaluate_rule_lang_strings, answer.thunks, answer.values, 0)
            throw(4)
          end
          answer.thunks.push(
            ThunkLeaf.new(
              :action_directive_string_2,
              Capture.new(
                answer.pos, @cur,
                answer.pos_loc, @cur_loc,
              ),
              answer.values.slice(0),
              {},
            )
          )
          throw(1)
        end
        @cur = pos2
        @cur_loc = p_loc2
        answer.thunks[n2..-1] = []
        catch(5) do
          if (
            refill_buffer(1) < 1 ||
            @buffer[@cur] != "%"
          )
            throw(5)
          end
          @cur_loc = @cur_loc.forward(@buffer, @cur, 1)
          @cur += 1
          pos4 = @cur
          p_loc4 = @cur_loc
          if !apply_rule(:evaluate_rule_identifier, answer.thunks, nil, 0)
            throw(5)
          end
          q4 = @cur
          capt4 = answer.capts[0]
          capt4.range_start = pos4
          capt4.range_end = q4
          q_loc4 = @cur_loc
          capt4.start_loc = p_loc4
          capt4.end_loc = q_loc4
          if !apply_rule(:evaluate_rule_opt_spaces_or_comments, answer.thunks, nil, 0)
            throw(5)
          end
          if !apply_rule(:evaluate_rule_quotation_double, answer.thunks, answer.values, 1)
            throw(5)
          end
          answer.thunks.push(
            ThunkLeaf.new(
              :action_directive_string_3,
              Capture.new(
                answer.pos, @cur,
                answer.pos_loc, @cur_loc,
              ),
              answer.values.slice(1),
              answer.capts.slice(0),
            )
          )
          throw(1)
        end
        @cur = pos2
        @cur_loc = p_loc2
        answer.thunks[n2..-1] = []
        throw(0)
      end
      @level -= 1
      debug { warn "#{ "  " * @level}MATCH   directive_string #{answer.pos} #{@buffer[answer.pos...@cur].inspect}" }
      return answer
    end
    @level -= 1
    debug { warn "#{ "  " * @level}NOMATCH directive_string #{answer.pos} #{@buffer[answer.pos...@cur].inspect}" }
    return nil
  end

  def evaluate_rule_directive_value
    answer = ThunkChunk.new
    answer.pos = @cur
    answer.pos_loc = @cur_loc
    debug { warn "#{ "  " * @level}EVAL    directive_value #{answer.pos} #{@buffer[answer.pos..-1].inspect}" }
    @level += 1
    answer.resize_captures(0)
    catch(0) do
      if (
        refill_buffer(8) < 8 ||
        @buffer[@cur, 8] != "%capture"
      )
        throw(0)
      end
      @cur_loc = @cur_loc.forward(@buffer, @cur, 8)
      @cur += 8
      if !apply_rule(:evaluate_rule_spaces, answer.thunks, nil, 0)
        throw(0)
      end
      catch(1) do
        pos3 = @cur
        p_loc3 = @cur_loc
        n3 = answer.thunks.length
        catch(2) do
          if (
            refill_buffer(2) < 2 ||
            @buffer[@cur, 2] != "on"
          )
            throw(2)
          end
          @cur_loc = @cur_loc.forward(@buffer, @cur, 2)
          @cur += 2
          throw(1)
        end
        @cur = pos3
        @cur_loc = p_loc3
        answer.thunks[n3..-1] = []
        catch(3) do
          if (
            refill_buffer(4) < 4 ||
            @buffer[@cur, 4] != "true"
          )
            throw(3)
          end
          @cur_loc = @cur_loc.forward(@buffer, @cur, 4)
          @cur += 4
          throw(1)
        end
        @cur = pos3
        @cur_loc = p_loc3
        answer.thunks[n3..-1] = []
        throw(0)
      end
      answer.thunks.push(
        ThunkLeaf.new(
          :action_directive_value_0,
          Capture.new(
            answer.pos, @cur,
            answer.pos_loc, @cur_loc,
          ),
          {},
          {},
        )
      )
      @level -= 1
      debug { warn "#{ "  " * @level}MATCH   directive_value #{answer.pos} #{@buffer[answer.pos...@cur].inspect}" }
      return answer
    end
    @level -= 1
    debug { warn "#{ "  " * @level}NOMATCH directive_value #{answer.pos} #{@buffer[answer.pos...@cur].inspect}" }
    return nil
  end

  def evaluate_rule_lang_strings
    answer = ThunkChunk.new
    answer.pos = @cur
    answer.pos_loc = @cur_loc
    debug { warn "#{ "  " * @level}EVAL    lang_strings #{answer.pos} #{@buffer[answer.pos..-1].inspect}" }
    @level += 1
    answer.resize_captures(0)
    answer.values = {}
    catch(0) do
      catch(1) do
        pos2 = @cur
        p_loc2 = @cur_loc
        n2 = answer.thunks.length
        catch(2) do
          if !apply_rule(:evaluate_rule_lang_strings, answer.thunks, answer.values, 0)
            throw(2)
          end
          if !apply_rule(:evaluate_rule_opt_spaces_or_comments, answer.thunks, nil, 0)
            throw(2)
          end
          if !apply_rule(:evaluate_rule_lang_string, answer.thunks, answer.values, 1)
            throw(2)
          end
          answer.thunks.push(
            ThunkLeaf.new(
              :action_lang_strings_0,
              Capture.new(
                answer.pos, @cur,
                answer.pos_loc, @cur_loc,
              ),
              answer.values.slice(0, 1),
              {},
            )
          )
          throw(1)
        end
        @cur = pos2
        @cur_loc = p_loc2
        answer.thunks[n2..-1] = []
        catch(3) do
          if !apply_rule(:evaluate_rule_lang_string, answer.thunks, answer.values, 1)
            throw(3)
          end
          answer.thunks.push(
            ThunkLeaf.new(
              :action_lang_strings_1,
              Capture.new(
                answer.pos, @cur,
                answer.pos_loc, @cur_loc,
              ),
              answer.values.slice(1),
              {},
            )
          )
          throw(1)
        end
        @cur = pos2
        @cur_loc = p_loc2
        answer.thunks[n2..-1] = []
        throw(0)
      end
      @level -= 1
      debug { warn "#{ "  " * @level}MATCH   lang_strings #{answer.pos} #{@buffer[answer.pos...@cur].inspect}" }
      return answer
    end
    @level -= 1
    debug { warn "#{ "  " * @level}NOMATCH lang_strings #{answer.pos} #{@buffer[answer.pos...@cur].inspect}" }
    return nil
  end

  def evaluate_rule_lang_string
    answer = ThunkChunk.new
    answer.pos = @cur
    answer.pos_loc = @cur_loc
    debug { warn "#{ "  " * @level}EVAL    lang_string #{answer.pos} #{@buffer[answer.pos..-1].inspect}" }
    @level += 1
    answer.resize_captures(1)
    answer.values = {}
    catch(0) do
      catch(1) do
        pos2 = @cur
        p_loc2 = @cur_loc
        n2 = answer.thunks.length
        catch(2) do
          if !apply_rule(:evaluate_rule_quotation_double, answer.thunks, answer.values, 0)
            throw(2)
          end
          answer.thunks.push(
            ThunkLeaf.new(
              :action_lang_string_0,
              Capture.new(
                answer.pos, @cur,
                answer.pos_loc, @cur_loc,
              ),
              answer.values.slice(0),
              {},
            )
          )
          throw(1)
        end
        @cur = pos2
        @cur_loc = p_loc2
        answer.thunks[n2..-1] = []
        catch(3) do
          pos4 = @cur
          p_loc4 = @cur_loc
          if !apply_rule(:evaluate_rule_supported_language, answer.thunks, nil, 0)
            throw(3)
          end
          q4 = @cur
          capt4 = answer.capts[0]
          capt4.range_start = pos4
          capt4.range_end = q4
          q_loc4 = @cur_loc
          capt4.start_loc = p_loc4
          capt4.end_loc = q_loc4
          if !apply_rule(:evaluate_rule_opt_spaces_or_comments, answer.thunks, nil, 0)
            throw(3)
          end
          if (
            refill_buffer(2) < 2 ||
            @buffer[@cur, 2] != "->"
          )
            throw(3)
          end
          @cur_loc = @cur_loc.forward(@buffer, @cur, 2)
          @cur += 2
          if !apply_rule(:evaluate_rule_opt_spaces_or_comments, answer.thunks, nil, 0)
            throw(3)
          end
          if !apply_rule(:evaluate_rule_quotation_double, answer.thunks, answer.values, 0)
            throw(3)
          end
          answer.thunks.push(
            ThunkLeaf.new(
              :action_lang_string_1,
              Capture.new(
                answer.pos, @cur,
                answer.pos_loc, @cur_loc,
              ),
              answer.values.slice(0),
              answer.capts.slice(0),
            )
          )
          throw(1)
        end
        @cur = pos2
        @cur_loc = p_loc2
        answer.thunks[n2..-1] = []
        throw(0)
      end
      @level -= 1
      debug { warn "#{ "  " * @level}MATCH   lang_string #{answer.pos} #{@buffer[answer.pos...@cur].inspect}" }
      return answer
    end
    @level -= 1
    debug { warn "#{ "  " * @level}NOMATCH lang_string #{answer.pos} #{@buffer[answer.pos...@cur].inspect}" }
    return nil
  end

  def evaluate_rule_rule
    answer = ThunkChunk.new
    answer.pos = @cur
    answer.pos_loc = @cur_loc
    debug { warn "#{ "  " * @level}EVAL    rule #{answer.pos} #{@buffer[answer.pos..-1].inspect}" }
    @level += 1
    answer.resize_captures(0)
    answer.values = {}
    catch(0) do
      if !apply_rule(:evaluate_rule_identifier, answer.thunks, answer.values, 0)
        throw(0)
      end
      if !apply_rule(:evaluate_rule_opt_spaces_or_comments, answer.thunks, nil, 0)
        throw(0)
      end
      if (
        refill_buffer(2) < 2 ||
        @buffer[@cur, 2] != "<-"
      )
        throw(0)
      end
      @cur_loc = @cur_loc.forward(@buffer, @cur, 2)
      @cur += 2
      if !apply_rule(:evaluate_rule_opt_spaces_or_comments, answer.thunks, nil, 0)
        throw(0)
      end
      if !apply_rule(:evaluate_rule_expression, answer.thunks, answer.values, 1)
        throw(0)
      end
      answer.thunks.push(
        ThunkLeaf.new(
          :action_rule_0,
          Capture.new(
            answer.pos, @cur,
            answer.pos_loc, @cur_loc,
          ),
          answer.values.slice(0, 1),
          {},
        )
      )
      @level -= 1
      debug { warn "#{ "  " * @level}MATCH   rule #{answer.pos} #{@buffer[answer.pos...@cur].inspect}" }
      return answer
    end
    @level -= 1
    debug { warn "#{ "  " * @level}NOMATCH rule #{answer.pos} #{@buffer[answer.pos...@cur].inspect}" }
    return nil
  end

  def evaluate_rule_expression
    answer = ThunkChunk.new
    answer.pos = @cur
    answer.pos_loc = @cur_loc
    debug { warn "#{ "  " * @level}EVAL    expression #{answer.pos} #{@buffer[answer.pos..-1].inspect}" }
    @level += 1
    answer.resize_captures(0)
    answer.values = {}
    catch(0) do
      catch(1) do
        pos2 = @cur
        p_loc2 = @cur_loc
        n2 = answer.thunks.length
        catch(2) do
          if !apply_rule(:evaluate_rule_expression, answer.thunks, answer.values, 0)
            throw(2)
          end
          if !apply_rule(:evaluate_rule_opt_spaces_or_comments, answer.thunks, nil, 0)
            throw(2)
          end
          if (
            refill_buffer(1) < 1 ||
            @buffer[@cur] != "/"
          )
            throw(2)
          end
          @cur_loc = @cur_loc.forward(@buffer, @cur, 1)
          @cur += 1
          if !apply_rule(:evaluate_rule_opt_spaces_or_comments, answer.thunks, nil, 0)
            throw(0)
          end
          if !apply_rule(:evaluate_rule_sequence, answer.thunks, answer.values, 1)
            throw(0)
          end
          answer.thunks.push(
            ThunkLeaf.new(
              :action_expression_0,
              Capture.new(
                answer.pos, @cur,
                answer.pos_loc, @cur_loc,
              ),
              answer.values.slice(0, 1),
              {},
            )
          )
          throw(1)
        end
        @cur = pos2
        @cur_loc = p_loc2
        answer.thunks[n2..-1] = []
        catch(3) do
          if !apply_rule(:evaluate_rule_sequence, answer.thunks, answer.values, 1)
            throw(3)
          end
          answer.thunks.push(
            ThunkLeaf.new(
              :action_expression_1,
              Capture.new(
                answer.pos, @cur,
                answer.pos_loc, @cur_loc,
              ),
              answer.values.slice(1),
              {},
            )
          )
          throw(1)
        end
        @cur = pos2
        @cur_loc = p_loc2
        answer.thunks[n2..-1] = []
        throw(0)
      end
      @level -= 1
      debug { warn "#{ "  " * @level}MATCH   expression #{answer.pos} #{@buffer[answer.pos...@cur].inspect}" }
      return answer
    end
    @level -= 1
    debug { warn "#{ "  " * @level}NOMATCH expression #{answer.pos} #{@buffer[answer.pos...@cur].inspect}" }
    return nil
  end

  def evaluate_rule_sequence
    answer = ThunkChunk.new
    answer.pos = @cur
    answer.pos_loc = @cur_loc
    debug { warn "#{ "  " * @level}EVAL    sequence #{answer.pos} #{@buffer[answer.pos..-1].inspect}" }
    @level += 1
    answer.resize_captures(0)
    answer.values = {}
    catch(0) do
      catch(1) do
        pos2 = @cur
        p_loc2 = @cur_loc
        n2 = answer.thunks.length
        catch(2) do
          if !apply_rule(:evaluate_rule_sequence, answer.thunks, answer.values, 0)
            throw(2)
          end
          if !apply_rule(:evaluate_rule_opt_spaces_or_comments, answer.thunks, nil, 0)
            throw(2)
          end
          if (
            refill_buffer(2) < 2 ||
            @buffer[@cur, 2] != "8<"
          )
            throw(2)
          end
          @cur_loc = @cur_loc.forward(@buffer, @cur, 2)
          @cur += 2
          if !apply_rule(:evaluate_rule_opt_spaces_or_comments, answer.thunks, nil, 0)
            throw(0)
          end
          if !apply_rule(:evaluate_rule_term, answer.thunks, answer.values, 1)
            throw(0)
          end
          answer.thunks.push(
            ThunkLeaf.new(
              :action_sequence_0,
              Capture.new(
                answer.pos, @cur,
                answer.pos_loc, @cur_loc,
              ),
              answer.values.slice(0, 1),
              {},
            )
          )
          throw(1)
        end
        @cur = pos2
        @cur_loc = p_loc2
        answer.thunks[n2..-1] = []
        catch(3) do
          if !apply_rule(:evaluate_rule_sequence, answer.thunks, answer.values, 0)
            throw(3)
          end
          if !apply_rule(:evaluate_rule_opt_spaces_or_comments, answer.thunks, nil, 0)
            throw(3)
          end
          if (
            refill_buffer(1) < 1 ||
            @buffer[@cur] != "~"
          )
            throw(3)
          end
          @cur_loc = @cur_loc.forward(@buffer, @cur, 1)
          @cur += 1
          if !apply_rule(:evaluate_rule_opt_spaces_or_comments, answer.thunks, nil, 0)
            throw(0)
          end
          if !apply_rule(:evaluate_rule_lang_code_block, answer.thunks, answer.values, 2)
            throw(0)
          end
          answer.thunks.push(
            ThunkLeaf.new(
              :action_sequence_1,
              Capture.new(
                answer.pos, @cur,
                answer.pos_loc, @cur_loc,
              ),
              answer.values.slice(0, 2),
              {},
            )
          )
          throw(1)
        end
        @cur = pos2
        @cur_loc = p_loc2
        answer.thunks[n2..-1] = []
        catch(4) do
          if !apply_rule(:evaluate_rule_sequence, answer.thunks, answer.values, 0)
            throw(4)
          end
          if !apply_rule(:evaluate_rule_opt_spaces_or_comments, answer.thunks, nil, 0)
            throw(4)
          end
          if !apply_rule(:evaluate_rule_term, answer.thunks, answer.values, 1)
            throw(4)
          end
          answer.thunks.push(
            ThunkLeaf.new(
              :action_sequence_2,
              Capture.new(
                answer.pos, @cur,
                answer.pos_loc, @cur_loc,
              ),
              answer.values.slice(0, 1),
              {},
            )
          )
          throw(1)
        end
        @cur = pos2
        @cur_loc = p_loc2
        answer.thunks[n2..-1] = []
        catch(5) do
          if !apply_rule(:evaluate_rule_term, answer.thunks, answer.values, 1)
            throw(5)
          end
          answer.thunks.push(
            ThunkLeaf.new(
              :action_sequence_3,
              Capture.new(
                answer.pos, @cur,
                answer.pos_loc, @cur_loc,
              ),
              answer.values.slice(1),
              {},
            )
          )
          throw(1)
        end
        @cur = pos2
        @cur_loc = p_loc2
        answer.thunks[n2..-1] = []
        throw(0)
      end
      @level -= 1
      debug { warn "#{ "  " * @level}MATCH   sequence #{answer.pos} #{@buffer[answer.pos...@cur].inspect}" }
      return answer
    end
    @level -= 1
    debug { warn "#{ "  " * @level}NOMATCH sequence #{answer.pos} #{@buffer[answer.pos...@cur].inspect}" }
    return nil
  end

  def evaluate_rule_term
    answer = ThunkChunk.new
    answer.pos = @cur
    answer.pos_loc = @cur_loc
    debug { warn "#{ "  " * @level}EVAL    term #{answer.pos} #{@buffer[answer.pos..-1].inspect}" }
    @level += 1
    answer.resize_captures(0)
    answer.values = {}
    catch(0) do
      catch(1) do
        pos2 = @cur
        p_loc2 = @cur_loc
        n2 = answer.thunks.length
        catch(2) do
          if (
            refill_buffer(1) < 1 ||
            @buffer[@cur] != "&"
          )
            throw(2)
          end
          @cur_loc = @cur_loc.forward(@buffer, @cur, 1)
          @cur += 1
          if !apply_rule(:evaluate_rule_opt_spaces_or_comments, answer.thunks, nil, 0)
            throw(0)
          end
          if !apply_rule(:evaluate_rule_quantity, answer.thunks, answer.values, 0)
            throw(0)
          end
          answer.thunks.push(
            ThunkLeaf.new(
              :action_term_0,
              Capture.new(
                answer.pos, @cur,
                answer.pos_loc, @cur_loc,
              ),
              answer.values.slice(0),
              {},
            )
          )
          throw(1)
        end
        @cur = pos2
        @cur_loc = p_loc2
        answer.thunks[n2..-1] = []
        catch(3) do
          if (
            refill_buffer(1) < 1 ||
            @buffer[@cur] != "!"
          )
            throw(3)
          end
          @cur_loc = @cur_loc.forward(@buffer, @cur, 1)
          @cur += 1
          if !apply_rule(:evaluate_rule_opt_spaces_or_comments, answer.thunks, nil, 0)
            throw(0)
          end
          if !apply_rule(:evaluate_rule_quantity, answer.thunks, answer.values, 0)
            throw(0)
          end
          answer.thunks.push(
            ThunkLeaf.new(
              :action_term_1,
              Capture.new(
                answer.pos, @cur,
                answer.pos_loc, @cur_loc,
              ),
              answer.values.slice(0),
              {},
            )
          )
          throw(1)
        end
        @cur = pos2
        @cur_loc = p_loc2
        answer.thunks[n2..-1] = []
        catch(4) do
          if !apply_rule(:evaluate_rule_quantity, answer.thunks, answer.values, 0)
            throw(4)
          end
          answer.thunks.push(
            ThunkLeaf.new(
              :action_term_2,
              Capture.new(
                answer.pos, @cur,
                answer.pos_loc, @cur_loc,
              ),
              answer.values.slice(0),
              {},
            )
          )
          throw(1)
        end
        @cur = pos2
        @cur_loc = p_loc2
        answer.thunks[n2..-1] = []
        throw(0)
      end
      @level -= 1
      debug { warn "#{ "  " * @level}MATCH   term #{answer.pos} #{@buffer[answer.pos...@cur].inspect}" }
      return answer
    end
    @level -= 1
    debug { warn "#{ "  " * @level}NOMATCH term #{answer.pos} #{@buffer[answer.pos...@cur].inspect}" }
    return nil
  end

  def evaluate_rule_quantity
    answer = ThunkChunk.new
    answer.pos = @cur
    answer.pos_loc = @cur_loc
    debug { warn "#{ "  " * @level}EVAL    quantity #{answer.pos} #{@buffer[answer.pos..-1].inspect}" }
    @level += 1
    answer.resize_captures(0)
    answer.values = {}
    catch(0) do
      catch(1) do
        pos2 = @cur
        p_loc2 = @cur_loc
        n2 = answer.thunks.length
        catch(2) do
          if !apply_rule(:evaluate_rule_primary, answer.thunks, answer.values, 0)
            throw(2)
          end
          if !apply_rule(:evaluate_rule_opt_spaces_or_comments, answer.thunks, nil, 0)
            throw(2)
          end
          if (
            refill_buffer(1) < 1 ||
            @buffer[@cur] != "*"
          )
            throw(2)
          end
          @cur_loc = @cur_loc.forward(@buffer, @cur, 1)
          @cur += 1
          answer.thunks.push(
            ThunkLeaf.new(
              :action_quantity_0,
              Capture.new(
                answer.pos, @cur,
                answer.pos_loc, @cur_loc,
              ),
              answer.values.slice(0),
              {},
            )
          )
          throw(1)
        end
        @cur = pos2
        @cur_loc = p_loc2
        answer.thunks[n2..-1] = []
        catch(3) do
          if !apply_rule(:evaluate_rule_primary, answer.thunks, answer.values, 0)
            throw(3)
          end
          if !apply_rule(:evaluate_rule_opt_spaces_or_comments, answer.thunks, nil, 0)
            throw(3)
          end
          if (
            refill_buffer(1) < 1 ||
            @buffer[@cur] != "+"
          )
            throw(3)
          end
          @cur_loc = @cur_loc.forward(@buffer, @cur, 1)
          @cur += 1
          answer.thunks.push(
            ThunkLeaf.new(
              :action_quantity_1,
              Capture.new(
                answer.pos, @cur,
                answer.pos_loc, @cur_loc,
              ),
              answer.values.slice(0),
              {},
            )
          )
          throw(1)
        end
        @cur = pos2
        @cur_loc = p_loc2
        answer.thunks[n2..-1] = []
        catch(4) do
          if !apply_rule(:evaluate_rule_primary, answer.thunks, answer.values, 0)
            throw(4)
          end
          if !apply_rule(:evaluate_rule_opt_spaces_or_comments, answer.thunks, nil, 0)
            throw(4)
          end
          if (
            refill_buffer(1) < 1 ||
            @buffer[@cur] != "?"
          )
            throw(4)
          end
          @cur_loc = @cur_loc.forward(@buffer, @cur, 1)
          @cur += 1
          answer.thunks.push(
            ThunkLeaf.new(
              :action_quantity_2,
              Capture.new(
                answer.pos, @cur,
                answer.pos_loc, @cur_loc,
              ),
              answer.values.slice(0),
              {},
            )
          )
          throw(1)
        end
        @cur = pos2
        @cur_loc = p_loc2
        answer.thunks[n2..-1] = []
        catch(5) do
          if !apply_rule(:evaluate_rule_primary, answer.thunks, answer.values, 0)
            throw(5)
          end
          answer.thunks.push(
            ThunkLeaf.new(
              :action_quantity_3,
              Capture.new(
                answer.pos, @cur,
                answer.pos_loc, @cur_loc,
              ),
              answer.values.slice(0),
              {},
            )
          )
          throw(1)
        end
        @cur = pos2
        @cur_loc = p_loc2
        answer.thunks[n2..-1] = []
        throw(0)
      end
      @level -= 1
      debug { warn "#{ "  " * @level}MATCH   quantity #{answer.pos} #{@buffer[answer.pos...@cur].inspect}" }
      return answer
    end
    @level -= 1
    debug { warn "#{ "  " * @level}NOMATCH quantity #{answer.pos} #{@buffer[answer.pos...@cur].inspect}" }
    return nil
  end

  def evaluate_rule_primary
    answer = ThunkChunk.new
    answer.pos = @cur
    answer.pos_loc = @cur_loc
    debug { warn "#{ "  " * @level}EVAL    primary #{answer.pos} #{@buffer[answer.pos..-1].inspect}" }
    @level += 1
    answer.resize_captures(1)
    answer.values = {}
    catch(0) do
      catch(1) do
        pos2 = @cur
        p_loc2 = @cur_loc
        n2 = answer.thunks.length
        catch(2) do
          if !apply_rule(:evaluate_rule_lang_code_block, answer.thunks, answer.values, 0)
            throw(2)
          end
          answer.thunks.push(
            ThunkLeaf.new(
              :action_primary_0,
              Capture.new(
                answer.pos, @cur,
                answer.pos_loc, @cur_loc,
              ),
              answer.values.slice(0),
              {},
            )
          )
          throw(1)
        end
        @cur = pos2
        @cur_loc = p_loc2
        answer.thunks[n2..-1] = []
        catch(3) do
          if !apply_rule(:evaluate_rule_identifier, answer.thunks, answer.values, 1)
            throw(3)
          end
          if !apply_rule(:evaluate_rule_opt_spaces_or_comments, answer.thunks, nil, 0)
            throw(3)
          end
          if (
            refill_buffer(1) < 1 ||
            @buffer[@cur] != ":"
          )
            throw(3)
          end
          @cur_loc = @cur_loc.forward(@buffer, @cur, 1)
          @cur += 1
          if !apply_rule(:evaluate_rule_opt_spaces_or_comments, answer.thunks, nil, 0)
            throw(0)
          end
          if !apply_rule(:evaluate_rule_identifier, answer.thunks, answer.values, 2)
            throw(0)
          end
          pos5 = @cur
          p_loc5 = @cur_loc
          catch(4) do
            i7 = 0
            pos7 = nil
            p_loc7 = nil
            n7 = nil
            catch(5) do
              pos7 = @cur
              p_loc7 = @cur_loc
              n7 = answer.thunks.length
              if refill_buffer(1) < 1
                throw(5)
              end
              u8 = @buffer[@cur]
              if (!(
                u8 == " " ||
                u8 == "\t" ||
                u8 == "\v" ||
                u8 == "\f" ||
                u8 == "\r" ||
                u8 == "\n"
              ))
                throw(5)
              end
              @cur_loc = @cur_loc.forward(@buffer, @cur, 1)
              @cur += 1
              i7 += 1
              if @cur != pos7
                redo
              end
              pos7 = nil
            end
            if pos7
              @cur = pos7
              @cur_loc = p_loc7
              answer.thunks[n7..-1] = []
            end
            if (
              refill_buffer(2) < 2 ||
              @buffer[@cur, 2] != "<-"
            )
              throw(4)
            end
            @cur_loc = @cur_loc.forward(@buffer, @cur, 2)
            @cur += 2
            @cur = pos5
            @cur_loc = p_loc5
            throw(0)
          end
          @cur = pos5
          @cur_loc = p_loc5
          answer.thunks.push(
            ThunkLeaf.new(
              :action_primary_1,
              Capture.new(
                answer.pos, @cur,
                answer.pos_loc, @cur_loc,
              ),
              answer.values.slice(1, 2),
              {},
            )
          )
          throw(1)
        end
        @cur = pos2
        @cur_loc = p_loc2
        answer.thunks[n2..-1] = []
        catch(6) do
          if (
            refill_buffer(2) < 2 ||
            @buffer[@cur, 2] != "$$"
          )
            throw(6)
          end
          @cur_loc = @cur_loc.forward(@buffer, @cur, 2)
          @cur += 2
          if !apply_rule(:evaluate_rule_opt_spaces_or_comments, answer.thunks, nil, 0)
            throw(6)
          end
          if (
            refill_buffer(1) < 1 ||
            @buffer[@cur] != ":"
          )
            throw(6)
          end
          @cur_loc = @cur_loc.forward(@buffer, @cur, 1)
          @cur += 1
          if !apply_rule(:evaluate_rule_opt_spaces_or_comments, answer.thunks, nil, 0)
            throw(0)
          end
          if !apply_rule(:evaluate_rule_identifier, answer.thunks, answer.values, 2)
            throw(0)
          end
          pos5 = @cur
          p_loc5 = @cur_loc
          catch(7) do
            i7 = 0
            pos7 = nil
            p_loc7 = nil
            n7 = nil
            catch(8) do
              pos7 = @cur
              p_loc7 = @cur_loc
              n7 = answer.thunks.length
              if refill_buffer(1) < 1
                throw(8)
              end
              u8 = @buffer[@cur]
              if (!(
                u8 == " " ||
                u8 == "\t" ||
                u8 == "\v" ||
                u8 == "\f" ||
                u8 == "\r" ||
                u8 == "\n"
              ))
                throw(8)
              end
              @cur_loc = @cur_loc.forward(@buffer, @cur, 1)
              @cur += 1
              i7 += 1
              if @cur != pos7
                redo
              end
              pos7 = nil
            end
            if pos7
              @cur = pos7
              @cur_loc = p_loc7
              answer.thunks[n7..-1] = []
            end
            if (
              refill_buffer(2) < 2 ||
              @buffer[@cur, 2] != "<-"
            )
              throw(7)
            end
            @cur_loc = @cur_loc.forward(@buffer, @cur, 2)
            @cur += 2
            @cur = pos5
            @cur_loc = p_loc5
            throw(0)
          end
          @cur = pos5
          @cur_loc = p_loc5
          answer.thunks.push(
            ThunkLeaf.new(
              :action_primary_2,
              Capture.new(
                answer.pos, @cur,
                answer.pos_loc, @cur_loc,
              ),
              answer.values.slice(2),
              {},
            )
          )
          throw(1)
        end
        @cur = pos2
        @cur_loc = p_loc2
        answer.thunks[n2..-1] = []
        catch(9) do
          if !apply_rule(:evaluate_rule_identifier, answer.thunks, answer.values, 2)
            throw(9)
          end
          pos5 = @cur
          p_loc5 = @cur_loc
          catch(10) do
            i7 = 0
            pos7 = nil
            p_loc7 = nil
            n7 = nil
            catch(11) do
              pos7 = @cur
              p_loc7 = @cur_loc
              n7 = answer.thunks.length
              if refill_buffer(1) < 1
                throw(11)
              end
              u8 = @buffer[@cur]
              if (!(
                u8 == " " ||
                u8 == "\t" ||
                u8 == "\v" ||
                u8 == "\f" ||
                u8 == "\r" ||
                u8 == "\n"
              ))
                throw(11)
              end
              @cur_loc = @cur_loc.forward(@buffer, @cur, 1)
              @cur += 1
              i7 += 1
              if @cur != pos7
                redo
              end
              pos7 = nil
            end
            if pos7
              @cur = pos7
              @cur_loc = p_loc7
              answer.thunks[n7..-1] = []
            end
            if (
              refill_buffer(2) < 2 ||
              @buffer[@cur, 2] != "<-"
            )
              throw(10)
            end
            @cur_loc = @cur_loc.forward(@buffer, @cur, 2)
            @cur += 2
            @cur = pos5
            @cur_loc = p_loc5
            throw(0)
          end
          @cur = pos5
          @cur_loc = p_loc5
          answer.thunks.push(
            ThunkLeaf.new(
              :action_primary_3,
              Capture.new(
                answer.pos, @cur,
                answer.pos_loc, @cur_loc,
              ),
              answer.values.slice(2),
              {},
            )
          )
          throw(1)
        end
        @cur = pos2
        @cur_loc = p_loc2
        answer.thunks[n2..-1] = []
        catch(12) do
          if (
            refill_buffer(1) < 1 ||
            @buffer[@cur] != "("
          )
            throw(12)
          end
          @cur_loc = @cur_loc.forward(@buffer, @cur, 1)
          @cur += 1
          if !apply_rule(:evaluate_rule_opt_spaces_or_comments, answer.thunks, nil, 0)
            throw(0)
          end
          if !apply_rule(:evaluate_rule_expression, answer.thunks, answer.values, 3)
            throw(0)
          end
          if !apply_rule(:evaluate_rule_opt_spaces_or_comments, answer.thunks, nil, 0)
            throw(0)
          end
          if (
            refill_buffer(1) < 1 ||
            @buffer[@cur] != ")"
          )
            throw(0)
          end
          @cur_loc = @cur_loc.forward(@buffer, @cur, 1)
          @cur += 1
          answer.thunks.push(
            ThunkLeaf.new(
              :action_primary_4,
              Capture.new(
                answer.pos, @cur,
                answer.pos_loc, @cur_loc,
              ),
              answer.values.slice(3),
              {},
            )
          )
          throw(1)
        end
        @cur = pos2
        @cur_loc = p_loc2
        answer.thunks[n2..-1] = []
        catch(13) do
          if (
            refill_buffer(1) < 1 ||
            @buffer[@cur] != "<"
          )
            throw(13)
          end
          @cur_loc = @cur_loc.forward(@buffer, @cur, 1)
          @cur += 1
          if !apply_rule(:evaluate_rule_opt_spaces_or_comments, answer.thunks, nil, 0)
            throw(0)
          end
          if !apply_rule(:evaluate_rule_expression, answer.thunks, answer.values, 3)
            throw(0)
          end
          if !apply_rule(:evaluate_rule_opt_spaces_or_comments, answer.thunks, nil, 0)
            throw(0)
          end
          if (
            refill_buffer(1) < 1 ||
            @buffer[@cur] != ">"
          )
            throw(0)
          end
          @cur_loc = @cur_loc.forward(@buffer, @cur, 1)
          @cur += 1
          answer.thunks.push(
            ThunkLeaf.new(
              :action_primary_5,
              Capture.new(
                answer.pos, @cur,
                answer.pos_loc, @cur_loc,
              ),
              answer.values.slice(3),
              {},
            )
          )
          throw(1)
        end
        @cur = pos2
        @cur_loc = p_loc2
        answer.thunks[n2..-1] = []
        catch(14) do
          if (
            refill_buffer(1) < 1 ||
            @buffer[@cur] != "$"
          )
            throw(14)
          end
          @cur_loc = @cur_loc.forward(@buffer, @cur, 1)
          @cur += 1
          pos4 = @cur
          p_loc4 = @cur_loc
          if refill_buffer(1) < 1
            throw(14)
          end
          u6 = @buffer[@cur]
          if (!(
            (u6 >= "1" && u6 <= "9")
          ))
            throw(14)
          end
          @cur_loc = @cur_loc.forward(@buffer, @cur, 1)
          @cur += 1
          i6 = 0
          pos6 = nil
          p_loc6 = nil
          n6 = nil
          catch(15) do
            pos6 = @cur
            p_loc6 = @cur_loc
            n6 = answer.thunks.length
            if refill_buffer(1) < 1
              throw(15)
            end
            u7 = @buffer[@cur]
            if (!(
              (u7 >= "0" && u7 <= "9")
            ))
              throw(15)
            end
            @cur_loc = @cur_loc.forward(@buffer, @cur, 1)
            @cur += 1
            i6 += 1
            if @cur != pos6
              redo
            end
            pos6 = nil
          end
          if pos6
            @cur = pos6
            @cur_loc = p_loc6
            answer.thunks[n6..-1] = []
          end
          q4 = @cur
          capt4 = answer.capts[0]
          capt4.range_start = pos4
          capt4.range_end = q4
          q_loc4 = @cur_loc
          capt4.start_loc = p_loc4
          capt4.end_loc = q_loc4
          answer.thunks.push(
            ThunkLeaf.new(
              :action_primary_6,
              Capture.new(
                answer.pos, @cur,
                answer.pos_loc, @cur_loc,
              ),
              {},
              answer.capts.slice(0),
            )
          )
          throw(1)
        end
        @cur = pos2
        @cur_loc = p_loc2
        answer.thunks[n2..-1] = []
        catch(16) do
          if (
            refill_buffer(1) < 1 ||
            @buffer[@cur] != "."
          )
            throw(16)
          end
          @cur_loc = @cur_loc.forward(@buffer, @cur, 1)
          @cur += 1
          answer.thunks.push(
            ThunkLeaf.new(
              :action_primary_7,
              Capture.new(
                answer.pos, @cur,
                answer.pos_loc, @cur_loc,
              ),
              {},
              {},
            )
          )
          throw(1)
        end
        @cur = pos2
        @cur_loc = p_loc2
        answer.thunks[n2..-1] = []
        catch(17) do
          if !apply_rule(:evaluate_rule_character_class, answer.thunks, answer.values, 4)
            throw(17)
          end
          answer.thunks.push(
            ThunkLeaf.new(
              :action_primary_8,
              Capture.new(
                answer.pos, @cur,
                answer.pos_loc, @cur_loc,
              ),
              answer.values.slice(4),
              {},
            )
          )
          throw(1)
        end
        @cur = pos2
        @cur_loc = p_loc2
        answer.thunks[n2..-1] = []
        catch(18) do
          if !apply_rule(:evaluate_rule_quotation_single, answer.thunks, answer.values, 4)
            throw(18)
          end
          answer.thunks.push(
            ThunkLeaf.new(
              :action_primary_9,
              Capture.new(
                answer.pos, @cur,
                answer.pos_loc, @cur_loc,
              ),
              answer.values.slice(4),
              {},
            )
          )
          throw(1)
        end
        @cur = pos2
        @cur_loc = p_loc2
        answer.thunks[n2..-1] = []
        catch(19) do
          if !apply_rule(:evaluate_rule_quotation_double, answer.thunks, answer.values, 4)
            throw(19)
          end
          answer.thunks.push(
            ThunkLeaf.new(
              :action_primary_10,
              Capture.new(
                answer.pos, @cur,
                answer.pos_loc, @cur_loc,
              ),
              answer.values.slice(4),
              {},
            )
          )
          throw(1)
        end
        @cur = pos2
        @cur_loc = p_loc2
        answer.thunks[n2..-1] = []
        throw(0)
      end
      @level -= 1
      debug { warn "#{ "  " * @level}MATCH   primary #{answer.pos} #{@buffer[answer.pos...@cur].inspect}" }
      return answer
    end
    @level -= 1
    debug { warn "#{ "  " * @level}NOMATCH primary #{answer.pos} #{@buffer[answer.pos...@cur].inspect}" }
    return nil
  end

  def evaluate_rule_character_class
    answer = ThunkChunk.new
    answer.pos = @cur
    answer.pos_loc = @cur_loc
    debug { warn "#{ "  " * @level}EVAL    character_class #{answer.pos} #{@buffer[answer.pos..-1].inspect}" }
    @level += 1
    answer.resize_captures(1)
    catch(0) do
      if (
        refill_buffer(1) < 1 ||
        @buffer[@cur] != "["
      )
        throw(0)
      end
      @cur_loc = @cur_loc.forward(@buffer, @cur, 1)
      @cur += 1
      pos3 = @cur
      p_loc3 = @cur_loc
      i4 = 0
      pos4 = nil
      p_loc4 = nil
      n4 = nil
      catch(1) do
        pos4 = @cur
        p_loc4 = @cur_loc
        n4 = answer.thunks.length
        catch(2) do
          pos5 = @cur
          p_loc5 = @cur_loc
          n5 = answer.thunks.length
          if refill_buffer(1) >= 1
            u6 = @buffer[@cur]
            unless (
              u6 == "\\" ||
              u6 == "[" ||
              u6 == "]"
            )
              @cur_loc = @cur_loc.forward(@buffer, @cur, 1)
              @cur += 1
              throw(2)
            end
          end
          @cur = pos5
          @cur_loc = p_loc5
          answer.thunks[n5..-1] = []
          catch(3) do
            if (
              refill_buffer(2) < 2 ||
              @buffer[@cur, 2] != "\\["
            )
              throw(3)
            end
            @cur_loc = @cur_loc.forward(@buffer, @cur, 2)
            @cur += 2
            throw(2)
          end
          @cur = pos5
          @cur_loc = p_loc5
          answer.thunks[n5..-1] = []
          catch(4) do
            if (
              refill_buffer(2) < 2 ||
              @buffer[@cur, 2] != "\\]"
            )
              throw(4)
            end
            @cur_loc = @cur_loc.forward(@buffer, @cur, 2)
            @cur += 2
            throw(2)
          end
          @cur = pos5
          @cur_loc = p_loc5
          answer.thunks[n5..-1] = []
          catch(5) do
            if (
              refill_buffer(1) < 1 ||
              @buffer[@cur] != "\\"
            )
              throw(5)
            end
            @cur_loc = @cur_loc.forward(@buffer, @cur, 1)
            @cur += 1
            throw(2)
          end
          @cur = pos5
          @cur_loc = p_loc5
          answer.thunks[n5..-1] = []
          throw(1)
        end
        i4 += 1
        if @cur != pos4
          redo
        end
        pos4 = nil
      end
      if pos4
        @cur = pos4
        @cur_loc = p_loc4
        answer.thunks[n4..-1] = []
      end
      q3 = @cur
      capt3 = answer.capts[0]
      capt3.range_start = pos3
      capt3.range_end = q3
      q_loc3 = @cur_loc
      capt3.start_loc = p_loc3
      capt3.end_loc = q_loc3
      if (
        refill_buffer(1) < 1 ||
        @buffer[@cur] != "]"
      )
        throw(0)
      end
      @cur_loc = @cur_loc.forward(@buffer, @cur, 1)
      @cur += 1
      answer.thunks.push(
        ThunkLeaf.new(
          :action_character_class_0,
          Capture.new(
            answer.pos, @cur,
            answer.pos_loc, @cur_loc,
          ),
          {},
          answer.capts.slice(0),
        )
      )
      @level -= 1
      debug { warn "#{ "  " * @level}MATCH   character_class #{answer.pos} #{@buffer[answer.pos...@cur].inspect}" }
      return answer
    end
    @level -= 1
    debug { warn "#{ "  " * @level}NOMATCH character_class #{answer.pos} #{@buffer[answer.pos...@cur].inspect}" }
    return nil
  end

  def evaluate_rule_lang_code_block
    answer = ThunkChunk.new
    answer.pos = @cur
    answer.pos_loc = @cur_loc
    debug { warn "#{ "  " * @level}EVAL    lang_code_block #{answer.pos} #{@buffer[answer.pos..-1].inspect}" }
    @level += 1
    answer.resize_captures(1)
    answer.values = {}
    catch(0) do
      catch(1) do
        pos2 = @cur
        p_loc2 = @cur_loc
        n2 = answer.thunks.length
        catch(2) do
          if !apply_rule(:evaluate_rule_code_block, answer.thunks, answer.values, 0)
            throw(2)
          end
          answer.thunks.push(
            ThunkLeaf.new(
              :action_lang_code_block_0,
              Capture.new(
                answer.pos, @cur,
                answer.pos_loc, @cur_loc,
              ),
              answer.values.slice(0),
              {},
            )
          )
          throw(1)
        end
        @cur = pos2
        @cur_loc = p_loc2
        answer.thunks[n2..-1] = []
        catch(3) do
          pos4 = @cur
          p_loc4 = @cur_loc
          if !apply_rule(:evaluate_rule_supported_language, answer.thunks, nil, 0)
            throw(3)
          end
          q4 = @cur
          capt4 = answer.capts[0]
          capt4.range_start = pos4
          capt4.range_end = q4
          q_loc4 = @cur_loc
          capt4.start_loc = p_loc4
          capt4.end_loc = q_loc4
          if !apply_rule(:evaluate_rule_opt_spaces_or_comments, answer.thunks, nil, 0)
            throw(3)
          end
          if (
            refill_buffer(2) < 2 ||
            @buffer[@cur, 2] != "->"
          )
            throw(3)
          end
          @cur_loc = @cur_loc.forward(@buffer, @cur, 2)
          @cur += 2
          if !apply_rule(:evaluate_rule_opt_spaces_or_comments, answer.thunks, nil, 0)
            throw(3)
          end
          if !apply_rule(:evaluate_rule_code_block, answer.thunks, answer.values, 0)
            throw(3)
          end
          answer.thunks.push(
            ThunkLeaf.new(
              :action_lang_code_block_1,
              Capture.new(
                answer.pos, @cur,
                answer.pos_loc, @cur_loc,
              ),
              answer.values.slice(0),
              answer.capts.slice(0),
            )
          )
          throw(1)
        end
        @cur = pos2
        @cur_loc = p_loc2
        answer.thunks[n2..-1] = []
        throw(0)
      end
      @level -= 1
      debug { warn "#{ "  " * @level}MATCH   lang_code_block #{answer.pos} #{@buffer[answer.pos...@cur].inspect}" }
      return answer
    end
    @level -= 1
    debug { warn "#{ "  " * @level}NOMATCH lang_code_block #{answer.pos} #{@buffer[answer.pos...@cur].inspect}" }
    return nil
  end

  def evaluate_rule_code_block
    answer = ThunkChunk.new
    answer.pos = @cur
    answer.pos_loc = @cur_loc
    debug { warn "#{ "  " * @level}EVAL    code_block #{answer.pos} #{@buffer[answer.pos..-1].inspect}" }
    @level += 1
    answer.resize_captures(0)
    answer.values = {}
    catch(0) do
      catch(1) do
        pos2 = @cur
        p_loc2 = @cur_loc
        n2 = answer.thunks.length
        catch(2) do
          if (
            refill_buffer(1) < 1 ||
            @buffer[@cur] != "$"
          )
            throw(2)
          end
          @cur_loc = @cur_loc.forward(@buffer, @cur, 1)
          @cur += 1
          if !apply_rule(:evaluate_rule_plain_code_block, answer.thunks, answer.values, 0)
            throw(2)
          end
          answer.thunks.push(
            ThunkLeaf.new(
              :action_code_block_0,
              Capture.new(
                answer.pos, @cur,
                answer.pos_loc, @cur_loc,
              ),
              answer.values.slice(0),
              {},
            )
          )
          throw(1)
        end
        @cur = pos2
        @cur_loc = p_loc2
        answer.thunks[n2..-1] = []
        catch(3) do
          if !apply_rule(:evaluate_rule_plain_code_block, answer.thunks, answer.values, 0)
            throw(3)
          end
          answer.thunks.push(
            ThunkLeaf.new(
              :action_code_block_1,
              Capture.new(
                answer.pos, @cur,
                answer.pos_loc, @cur_loc,
              ),
              answer.values.slice(0),
              {},
            )
          )
          throw(1)
        end
        @cur = pos2
        @cur_loc = p_loc2
        answer.thunks[n2..-1] = []
        throw(0)
      end
      @level -= 1
      debug { warn "#{ "  " * @level}MATCH   code_block #{answer.pos} #{@buffer[answer.pos...@cur].inspect}" }
      return answer
    end
    @level -= 1
    debug { warn "#{ "  " * @level}NOMATCH code_block #{answer.pos} #{@buffer[answer.pos...@cur].inspect}" }
    return nil
  end

  def evaluate_rule_plain_code_block
    answer = ThunkChunk.new
    answer.pos = @cur
    answer.pos_loc = @cur_loc
    debug { warn "#{ "  " * @level}EVAL    plain_code_block #{answer.pos} #{@buffer[answer.pos..-1].inspect}" }
    @level += 1
    answer.resize_captures(1)
    catch(0) do
      if (
        refill_buffer(1) < 1 ||
        @buffer[@cur] != "{"
      )
        throw(0)
      end
      @cur_loc = @cur_loc.forward(@buffer, @cur, 1)
      @cur += 1
      pos3 = @cur
      p_loc3 = @cur_loc
      i5 = 0
      pos5 = nil
      p_loc5 = nil
      n5 = nil
      catch(1) do
        pos5 = @cur
        p_loc5 = @cur_loc
        n5 = answer.thunks.length
        if refill_buffer(1) < 1
          throw(1)
        end
        u6 = @buffer[@cur]
        if (!(
          u6 == " " ||
          u6 == "\t" ||
          u6 == "\v" ||
          u6 == "\f" ||
          u6 == "\r" ||
          u6 == "\n"
        ))
          throw(1)
        end
        @cur_loc = @cur_loc.forward(@buffer, @cur, 1)
        @cur += 1
        i5 += 1
        if @cur != pos5
          redo
        end
        pos5 = nil
      end
      if pos5
        @cur = pos5
        @cur_loc = p_loc5
        answer.thunks[n5..-1] = []
      end
      if !apply_rule(:evaluate_rule_opt_codes, answer.thunks, nil, 0)
        throw(0)
      end
      q3 = @cur
      capt3 = answer.capts[0]
      capt3.range_start = pos3
      capt3.range_end = q3
      q_loc3 = @cur_loc
      capt3.start_loc = p_loc3
      capt3.end_loc = q_loc3
      if (
        refill_buffer(1) < 1 ||
        @buffer[@cur] != "}"
      )
        throw(0)
      end
      @cur_loc = @cur_loc.forward(@buffer, @cur, 1)
      @cur += 1
      answer.thunks.push(
        ThunkLeaf.new(
          :action_plain_code_block_0,
          Capture.new(
            answer.pos, @cur,
            answer.pos_loc, @cur_loc,
          ),
          {},
          answer.capts.slice(0),
        )
      )
      @level -= 1
      debug { warn "#{ "  " * @level}MATCH   plain_code_block #{answer.pos} #{@buffer[answer.pos...@cur].inspect}" }
      return answer
    end
    @level -= 1
    debug { warn "#{ "  " * @level}NOMATCH plain_code_block #{answer.pos} #{@buffer[answer.pos...@cur].inspect}" }
    return nil
  end

  def evaluate_rule_opt_codes
    answer = ThunkChunk.new
    answer.pos = @cur
    answer.pos_loc = @cur_loc
    debug { warn "#{ "  " * @level}EVAL    opt_codes #{answer.pos} #{@buffer[answer.pos..-1].inspect}" }
    @level += 1
    answer.resize_captures(0)
    i2 = 0
    pos2 = nil
    p_loc2 = nil
    n2 = nil
    catch(1) do
      pos2 = @cur
      p_loc2 = @cur_loc
      n2 = answer.thunks.length
      if !apply_rule(:evaluate_rule_code, answer.thunks, nil, 0)
        throw(1)
      end
      i4 = 0
      pos4 = nil
      p_loc4 = nil
      n4 = nil
      catch(2) do
        pos4 = @cur
        p_loc4 = @cur_loc
        n4 = answer.thunks.length
        if refill_buffer(1) < 1
          throw(2)
        end
        u5 = @buffer[@cur]
        if (!(
          u5 == " " ||
          u5 == "\t" ||
          u5 == "\v" ||
          u5 == "\f" ||
          u5 == "\r" ||
          u5 == "\n"
        ))
          throw(2)
        end
        @cur_loc = @cur_loc.forward(@buffer, @cur, 1)
        @cur += 1
        i4 += 1
        if @cur != pos4
          redo
        end
        pos4 = nil
      end
      if pos4
        @cur = pos4
        @cur_loc = p_loc4
        answer.thunks[n4..-1] = []
      end
      i2 += 1
      if @cur != pos2
        redo
      end
      pos2 = nil
    end
    if pos2
      @cur = pos2
      @cur_loc = p_loc2
      answer.thunks[n2..-1] = []
    end
    @level -= 1
    debug { warn "#{ "  " * @level}MATCH   opt_codes #{answer.pos} #{@buffer[answer.pos...@cur].inspect}" }
    return answer
  end

  def evaluate_rule_code
    answer = ThunkChunk.new
    answer.pos = @cur
    answer.pos_loc = @cur_loc
    debug { warn "#{ "  " * @level}EVAL    code #{answer.pos} #{@buffer[answer.pos..-1].inspect}" }
    @level += 1
    answer.resize_captures(0)
    catch(0) do
      catch(1) do
        pos2 = @cur
        p_loc2 = @cur_loc
        n2 = answer.thunks.length
        catch(2) do
          q3 = @cur
          q_loc3 = @cur_loc
          m3 = answer.thunks.length
          i3 = 0
          pos3 = nil
          p_loc3 = nil
          n3 = nil
          catch(3) do
            pos3 = @cur
            p_loc3 = @cur_loc
            n3 = answer.thunks.length
            if !apply_rule(:evaluate_rule_codechar, answer.thunks, nil, 0)
              throw(3)
            end
            i3 += 1
            if @cur != pos3
              redo
            end
            pos3 = nil
          end
          if pos3
            @cur = pos3
            @cur_loc = p_loc3
            answer.thunks[n3..-1] = []
          end
          if i3 < 1
            @cur = q3
            @cur_loc = q_loc3
            answer.thunks[m3..-1] = []
            throw(2)
          end
          throw(1)
        end
        @cur = pos2
        @cur_loc = p_loc2
        answer.thunks[n2..-1] = []
        if apply_rule(:evaluate_rule_quotation_single, answer.thunks, nil, 0)
          throw(1)
        end
        @cur = pos2
        @cur_loc = p_loc2
        answer.thunks[n2..-1] = []
        if apply_rule(:evaluate_rule_quotation_double, answer.thunks, nil, 0)
          throw(1)
        end
        @cur = pos2
        @cur_loc = p_loc2
        answer.thunks[n2..-1] = []
        catch(4) do
          if (
            refill_buffer(1) < 1 ||
            @buffer[@cur] != "{"
          )
            throw(4)
          end
          @cur_loc = @cur_loc.forward(@buffer, @cur, 1)
          @cur += 1
          i4 = 0
          pos4 = nil
          p_loc4 = nil
          n4 = nil
          catch(5) do
            pos4 = @cur
            p_loc4 = @cur_loc
            n4 = answer.thunks.length
            if !apply_rule(:evaluate_rule_code, answer.thunks, nil, 0)
              throw(5)
            end
            i4 += 1
            if @cur != pos4
              redo
            end
            pos4 = nil
          end
          if pos4
            @cur = pos4
            @cur_loc = p_loc4
            answer.thunks[n4..-1] = []
          end
          if (
            refill_buffer(1) < 1 ||
            @buffer[@cur] != "}"
          )
            throw(4)
          end
          @cur_loc = @cur_loc.forward(@buffer, @cur, 1)
          @cur += 1
          throw(1)
        end
        @cur = pos2
        @cur_loc = p_loc2
        answer.thunks[n2..-1] = []
        throw(0)
      end
      @level -= 1
      debug { warn "#{ "  " * @level}MATCH   code #{answer.pos} #{@buffer[answer.pos...@cur].inspect}" }
      return answer
    end
    @level -= 1
    debug { warn "#{ "  " * @level}NOMATCH code #{answer.pos} #{@buffer[answer.pos...@cur].inspect}" }
    return nil
  end

  def evaluate_rule_codechar
    answer = ThunkChunk.new
    answer.pos = @cur
    answer.pos_loc = @cur_loc
    debug { warn "#{ "  " * @level}EVAL    codechar #{answer.pos} #{@buffer[answer.pos..-1].inspect}" }
    @level += 1
    answer.resize_captures(0)
    catch(0) do
      catch(1) do
        pos2 = @cur
        p_loc2 = @cur_loc
        n2 = answer.thunks.length
        if refill_buffer(1) >= 1
          u3 = @buffer[@cur]
          unless (
            u3 == "{" ||
            u3 == "}" ||
            u3 == "\"" ||
            u3 == "'"
          )
            @cur_loc = @cur_loc.forward(@buffer, @cur, 1)
            @cur += 1
            throw(1)
          end
        end
        @cur = pos2
        @cur_loc = p_loc2
        answer.thunks[n2..-1] = []
        catch(2) do
          if (
            refill_buffer(2) < 2 ||
            @buffer[@cur, 2] != "\\\""
          )
            throw(2)
          end
          @cur_loc = @cur_loc.forward(@buffer, @cur, 2)
          @cur += 2
          throw(1)
        end
        @cur = pos2
        @cur_loc = p_loc2
        answer.thunks[n2..-1] = []
        catch(3) do
          if (
            refill_buffer(2) < 2 ||
            @buffer[@cur, 2] != "\\'"
          )
            throw(3)
          end
          @cur_loc = @cur_loc.forward(@buffer, @cur, 2)
          @cur += 2
          throw(1)
        end
        @cur = pos2
        @cur_loc = p_loc2
        answer.thunks[n2..-1] = []
        catch(4) do
          if (
            refill_buffer(2) < 2 ||
            @buffer[@cur, 2] != "\\{"
          )
            throw(4)
          end
          @cur_loc = @cur_loc.forward(@buffer, @cur, 2)
          @cur += 2
          throw(1)
        end
        @cur = pos2
        @cur_loc = p_loc2
        answer.thunks[n2..-1] = []
        catch(5) do
          if (
            refill_buffer(2) < 2 ||
            @buffer[@cur, 2] != "\\}"
          )
            throw(5)
          end
          @cur_loc = @cur_loc.forward(@buffer, @cur, 2)
          @cur += 2
          throw(1)
        end
        @cur = pos2
        @cur_loc = p_loc2
        answer.thunks[n2..-1] = []
        throw(0)
      end
      @level -= 1
      debug { warn "#{ "  " * @level}MATCH   codechar #{answer.pos} #{@buffer[answer.pos...@cur].inspect}" }
      return answer
    end
    @level -= 1
    debug { warn "#{ "  " * @level}NOMATCH codechar #{answer.pos} #{@buffer[answer.pos...@cur].inspect}" }
    return nil
  end

  def evaluate_rule_quotation_single
    answer = ThunkChunk.new
    answer.pos = @cur
    answer.pos_loc = @cur_loc
    debug { warn "#{ "  " * @level}EVAL    quotation_single #{answer.pos} #{@buffer[answer.pos..-1].inspect}" }
    @level += 1
    answer.resize_captures(1)
    catch(0) do
      if (
        refill_buffer(1) < 1 ||
        @buffer[@cur] != "\'"
      )
        throw(0)
      end
      @cur_loc = @cur_loc.forward(@buffer, @cur, 1)
      @cur += 1
      pos3 = @cur
      p_loc3 = @cur_loc
      i4 = 0
      pos4 = nil
      p_loc4 = nil
      n4 = nil
      catch(1) do
        pos4 = @cur
        p_loc4 = @cur_loc
        n4 = answer.thunks.length
        catch(2) do
          pos5 = @cur
          p_loc5 = @cur_loc
          n5 = answer.thunks.length
          if refill_buffer(1) >= 1
            u6 = @buffer[@cur]
            unless (
              u6 == "\\" ||
              u6 == "'" ||
              u6 == "\n"
            )
              @cur_loc = @cur_loc.forward(@buffer, @cur, 1)
              @cur += 1
              throw(2)
            end
          end
          @cur = pos5
          @cur_loc = p_loc5
          answer.thunks[n5..-1] = []
          catch(3) do
            if (
              refill_buffer(2) < 2 ||
              @buffer[@cur, 2] != "\\'"
            )
              throw(3)
            end
            @cur_loc = @cur_loc.forward(@buffer, @cur, 2)
            @cur += 2
            throw(2)
          end
          @cur = pos5
          @cur_loc = p_loc5
          answer.thunks[n5..-1] = []
          catch(4) do
            if (
              refill_buffer(2) < 2 ||
              @buffer[@cur, 2] != "\\\n"
            )
              throw(4)
            end
            @cur_loc = @cur_loc.forward(@buffer, @cur, 2)
            @cur += 2
            throw(2)
          end
          @cur = pos5
          @cur_loc = p_loc5
          answer.thunks[n5..-1] = []
          catch(5) do
            if (
              refill_buffer(1) < 1 ||
              @buffer[@cur] != "\\"
            )
              throw(5)
            end
            @cur_loc = @cur_loc.forward(@buffer, @cur, 1)
            @cur += 1
            if refill_buffer(1) < 1
              throw(5)
            end
            u7 = @buffer[@cur]
            if (
              u7 == "'" ||
              u7 == "\n"
            )
              throw(5)
            end
            @cur_loc = @cur_loc.forward(@buffer, @cur, 1)
            @cur += 1
            throw(2)
          end
          @cur = pos5
          @cur_loc = p_loc5
          answer.thunks[n5..-1] = []
          throw(1)
        end
        i4 += 1
        if @cur != pos4
          redo
        end
        pos4 = nil
      end
      if pos4
        @cur = pos4
        @cur_loc = p_loc4
        answer.thunks[n4..-1] = []
      end
      q3 = @cur
      capt3 = answer.capts[0]
      capt3.range_start = pos3
      capt3.range_end = q3
      q_loc3 = @cur_loc
      capt3.start_loc = p_loc3
      capt3.end_loc = q_loc3
      if (
        refill_buffer(1) < 1 ||
        @buffer[@cur] != "\'"
      )
        throw(0)
      end
      @cur_loc = @cur_loc.forward(@buffer, @cur, 1)
      @cur += 1
      answer.thunks.push(
        ThunkLeaf.new(
          :action_quotation_single_0,
          Capture.new(
            answer.pos, @cur,
            answer.pos_loc, @cur_loc,
          ),
          {},
          answer.capts.slice(0),
        )
      )
      @level -= 1
      debug { warn "#{ "  " * @level}MATCH   quotation_single #{answer.pos} #{@buffer[answer.pos...@cur].inspect}" }
      return answer
    end
    @level -= 1
    debug { warn "#{ "  " * @level}NOMATCH quotation_single #{answer.pos} #{@buffer[answer.pos...@cur].inspect}" }
    return nil
  end

  def evaluate_rule_quotation_double
    answer = ThunkChunk.new
    answer.pos = @cur
    answer.pos_loc = @cur_loc
    debug { warn "#{ "  " * @level}EVAL    quotation_double #{answer.pos} #{@buffer[answer.pos..-1].inspect}" }
    @level += 1
    answer.resize_captures(1)
    catch(0) do
      if (
        refill_buffer(1) < 1 ||
        @buffer[@cur] != "\""
      )
        throw(0)
      end
      @cur_loc = @cur_loc.forward(@buffer, @cur, 1)
      @cur += 1
      pos3 = @cur
      p_loc3 = @cur_loc
      i4 = 0
      pos4 = nil
      p_loc4 = nil
      n4 = nil
      catch(1) do
        pos4 = @cur
        p_loc4 = @cur_loc
        n4 = answer.thunks.length
        catch(2) do
          pos5 = @cur
          p_loc5 = @cur_loc
          n5 = answer.thunks.length
          if refill_buffer(1) >= 1
            u6 = @buffer[@cur]
            unless (
              u6 == "\\" ||
              u6 == "\"" ||
              u6 == "\n"
            )
              @cur_loc = @cur_loc.forward(@buffer, @cur, 1)
              @cur += 1
              throw(2)
            end
          end
          @cur = pos5
          @cur_loc = p_loc5
          answer.thunks[n5..-1] = []
          catch(3) do
            if (
              refill_buffer(2) < 2 ||
              @buffer[@cur, 2] != "\\\""
            )
              throw(3)
            end
            @cur_loc = @cur_loc.forward(@buffer, @cur, 2)
            @cur += 2
            throw(2)
          end
          @cur = pos5
          @cur_loc = p_loc5
          answer.thunks[n5..-1] = []
          catch(4) do
            if (
              refill_buffer(2) < 2 ||
              @buffer[@cur, 2] != "\\\n"
            )
              throw(4)
            end
            @cur_loc = @cur_loc.forward(@buffer, @cur, 2)
            @cur += 2
            throw(2)
          end
          @cur = pos5
          @cur_loc = p_loc5
          answer.thunks[n5..-1] = []
          catch(5) do
            if (
              refill_buffer(1) < 1 ||
              @buffer[@cur] != "\\"
            )
              throw(5)
            end
            @cur_loc = @cur_loc.forward(@buffer, @cur, 1)
            @cur += 1
            if refill_buffer(1) < 1
              throw(5)
            end
            u7 = @buffer[@cur]
            if (
              u7 == "\"" ||
              u7 == "\n"
            )
              throw(5)
            end
            @cur_loc = @cur_loc.forward(@buffer, @cur, 1)
            @cur += 1
            throw(2)
          end
          @cur = pos5
          @cur_loc = p_loc5
          answer.thunks[n5..-1] = []
          throw(1)
        end
        i4 += 1
        if @cur != pos4
          redo
        end
        pos4 = nil
      end
      if pos4
        @cur = pos4
        @cur_loc = p_loc4
        answer.thunks[n4..-1] = []
      end
      q3 = @cur
      capt3 = answer.capts[0]
      capt3.range_start = pos3
      capt3.range_end = q3
      q_loc3 = @cur_loc
      capt3.start_loc = p_loc3
      capt3.end_loc = q_loc3
      if (
        refill_buffer(1) < 1 ||
        @buffer[@cur] != "\""
      )
        throw(0)
      end
      @cur_loc = @cur_loc.forward(@buffer, @cur, 1)
      @cur += 1
      answer.thunks.push(
        ThunkLeaf.new(
          :action_quotation_double_0,
          Capture.new(
            answer.pos, @cur,
            answer.pos_loc, @cur_loc,
          ),
          {},
          answer.capts.slice(0),
        )
      )
      @level -= 1
      debug { warn "#{ "  " * @level}MATCH   quotation_double #{answer.pos} #{@buffer[answer.pos...@cur].inspect}" }
      return answer
    end
    @level -= 1
    debug { warn "#{ "  " * @level}NOMATCH quotation_double #{answer.pos} #{@buffer[answer.pos...@cur].inspect}" }
    return nil
  end

  def evaluate_rule_identifier
    answer = ThunkChunk.new
    answer.pos = @cur
    answer.pos_loc = @cur_loc
    debug { warn "#{ "  " * @level}EVAL    identifier #{answer.pos} #{@buffer[answer.pos..-1].inspect}" }
    @level += 1
    answer.resize_captures(0)
    catch(0) do
      if refill_buffer(1) < 1
        throw(0)
      end
      u3 = @buffer[@cur]
      if (!(
        (u3 >= "a" && u3 <= "z") ||
        (u3 >= "A" && u3 <= "Z") ||
        u3 == "_"
      ))
        throw(0)
      end
      @cur_loc = @cur_loc.forward(@buffer, @cur, 1)
      @cur += 1
      i3 = 0
      pos3 = nil
      p_loc3 = nil
      n3 = nil
      catch(1) do
        pos3 = @cur
        p_loc3 = @cur_loc
        n3 = answer.thunks.length
        if refill_buffer(1) < 1
          throw(1)
        end
        u4 = @buffer[@cur]
        if (!(
          (u4 >= "a" && u4 <= "z") ||
          (u4 >= "A" && u4 <= "Z") ||
          u4 == "_" ||
          (u4 >= "0" && u4 <= "9")
        ))
          throw(1)
        end
        @cur_loc = @cur_loc.forward(@buffer, @cur, 1)
        @cur += 1
        i3 += 1
        if @cur != pos3
          redo
        end
        pos3 = nil
      end
      if pos3
        @cur = pos3
        @cur_loc = p_loc3
        answer.thunks[n3..-1] = []
      end
      answer.thunks.push(
        ThunkLeaf.new(
          :action_identifier_0,
          Capture.new(
            answer.pos, @cur,
            answer.pos_loc, @cur_loc,
          ),
          {},
          {},
        )
      )
      @level -= 1
      debug { warn "#{ "  " * @level}MATCH   identifier #{answer.pos} #{@buffer[answer.pos...@cur].inspect}" }
      return answer
    end
    @level -= 1
    debug { warn "#{ "  " * @level}NOMATCH identifier #{answer.pos} #{@buffer[answer.pos...@cur].inspect}" }
    return nil
  end

  def evaluate_rule_spaces
    answer = ThunkChunk.new
    answer.pos = @cur
    answer.pos_loc = @cur_loc
    debug { warn "#{ "  " * @level}EVAL    spaces #{answer.pos} #{@buffer[answer.pos..-1].inspect}" }
    @level += 1
    answer.resize_captures(0)
    catch(0) do
      q2 = @cur
      q_loc2 = @cur_loc
      m2 = answer.thunks.length
      i2 = 0
      pos2 = nil
      p_loc2 = nil
      n2 = nil
      catch(1) do
        pos2 = @cur
        p_loc2 = @cur_loc
        n2 = answer.thunks.length
        if refill_buffer(1) < 1
          throw(1)
        end
        u3 = @buffer[@cur]
        if (!(
          u3 == " " ||
          u3 == "\t" ||
          u3 == "\v" ||
          u3 == "\f" ||
          u3 == "\r" ||
          u3 == "\n"
        ))
          throw(1)
        end
        @cur_loc = @cur_loc.forward(@buffer, @cur, 1)
        @cur += 1
        i2 += 1
        if @cur != pos2
          redo
        end
        pos2 = nil
      end
      if pos2
        @cur = pos2
        @cur_loc = p_loc2
        answer.thunks[n2..-1] = []
      end
      if i2 < 1
        @cur = q2
        @cur_loc = q_loc2
        answer.thunks[m2..-1] = []
        throw(0)
      end
      @level -= 1
      debug { warn "#{ "  " * @level}MATCH   spaces #{answer.pos} #{@buffer[answer.pos...@cur].inspect}" }
      return answer
    end
    @level -= 1
    debug { warn "#{ "  " * @level}NOMATCH spaces #{answer.pos} #{@buffer[answer.pos...@cur].inspect}" }
    return nil
  end

  def evaluate_rule_opt_spaces_or_comments
    answer = ThunkChunk.new
    answer.pos = @cur
    answer.pos_loc = @cur_loc
    debug { warn "#{ "  " * @level}EVAL    opt_spaces_or_comments #{answer.pos} #{@buffer[answer.pos..-1].inspect}" }
    @level += 1
    answer.resize_captures(0)
    i2 = 0
    pos2 = nil
    p_loc2 = nil
    n2 = nil
    catch(1) do
      pos2 = @cur
      p_loc2 = @cur_loc
      n2 = answer.thunks.length
      catch(2) do
        pos3 = @cur
        p_loc3 = @cur_loc
        n3 = answer.thunks.length
        if apply_rule(:evaluate_rule_comment, answer.thunks, nil, 0)
          throw(2)
        end
        @cur = pos3
        @cur_loc = p_loc3
        answer.thunks[n3..-1] = []
        if apply_rule(:evaluate_rule_spaces, answer.thunks, nil, 0)
          throw(2)
        end
        @cur = pos3
        @cur_loc = p_loc3
        answer.thunks[n3..-1] = []
        throw(1)
      end
      i2 += 1
      if @cur != pos2
        redo
      end
      pos2 = nil
    end
    if pos2
      @cur = pos2
      @cur_loc = p_loc2
      answer.thunks[n2..-1] = []
    end
    @level -= 1
    debug { warn "#{ "  " * @level}MATCH   opt_spaces_or_comments #{answer.pos} #{@buffer[answer.pos...@cur].inspect}" }
    return answer
  end

  def evaluate_rule_lf
    answer = ThunkChunk.new
    answer.pos = @cur
    answer.pos_loc = @cur_loc
    debug { warn "#{ "  " * @level}EVAL    lf #{answer.pos} #{@buffer[answer.pos..-1].inspect}" }
    @level += 1
    answer.resize_captures(0)
    catch(0) do
      pos3 = @cur
      p_loc3 = @cur_loc
      n3 = answer.thunks.length
      catch(2) do
        catch(1) do
          if (
            refill_buffer(1) < 1 ||
            @buffer[@cur] != "\r"
          )
            throw(1)
          end
          @cur_loc = @cur_loc.forward(@buffer, @cur, 1)
          @cur += 1
          throw(2)
        end
        @cur_loc = p_loc3
        @cur = pos3
        answer.thunks[n3..-1] = []
      end
      if (
        refill_buffer(1) < 1 ||
        @buffer[@cur] != "\n"
      )
        throw(0)
      end
      @cur_loc = @cur_loc.forward(@buffer, @cur, 1)
      @cur += 1
      @level -= 1
      debug { warn "#{ "  " * @level}MATCH   lf #{answer.pos} #{@buffer[answer.pos...@cur].inspect}" }
      return answer
    end
    @level -= 1
    debug { warn "#{ "  " * @level}NOMATCH lf #{answer.pos} #{@buffer[answer.pos...@cur].inspect}" }
    return nil
  end

  def evaluate_rule_footer
    answer = ThunkChunk.new
    answer.pos = @cur
    answer.pos_loc = @cur_loc
    debug { warn "#{ "  " * @level}EVAL    footer #{answer.pos} #{@buffer[answer.pos..-1].inspect}" }
    @level += 1
    answer.resize_captures(1)
    catch(0) do
      if (
        refill_buffer(2) < 2 ||
        @buffer[@cur, 2] != "%%"
      )
        throw(0)
      end
      @cur_loc = @cur_loc.forward(@buffer, @cur, 2)
      @cur += 2
      catch(1) do
        pos3 = @cur
        p_loc3 = @cur_loc
        n3 = answer.thunks.length
        if apply_rule(:evaluate_rule_lf, answer.thunks, nil, 0)
          throw(1)
        end
        @cur = pos3
        @cur_loc = p_loc3
        answer.thunks[n3..-1] = []
        if apply_rule(:evaluate_rule_EOF, answer.thunks, nil, 0)
          throw(1)
        end
        @cur = pos3
        @cur_loc = p_loc3
        answer.thunks[n3..-1] = []
        throw(0)
      end
      pos3 = @cur
      p_loc3 = @cur_loc
      i4 = 0
      pos4 = nil
      p_loc4 = nil
      n4 = nil
      catch(2) do
        pos4 = @cur
        p_loc4 = @cur_loc
        n4 = answer.thunks.length
        if refill_buffer(1) < 1
          throw(2)
        end
        u5 = @buffer[@cur]
        @cur_loc = @cur_loc.forward(@buffer, @cur, 1)
        @cur += 1
        i4 += 1
        if @cur != pos4
          redo
        end
        pos4 = nil
      end
      if pos4
        @cur = pos4
        @cur_loc = p_loc4
        answer.thunks[n4..-1] = []
      end
      q3 = @cur
      capt3 = answer.capts[0]
      capt3.range_start = pos3
      capt3.range_end = q3
      q_loc3 = @cur_loc
      capt3.start_loc = p_loc3
      capt3.end_loc = q_loc3
      answer.thunks.push(
        ThunkLeaf.new(
          :action_footer_0,
          Capture.new(
            answer.pos, @cur,
            answer.pos_loc, @cur_loc,
          ),
          {},
          answer.capts.slice(0),
        )
      )
      @level -= 1
      debug { warn "#{ "  " * @level}MATCH   footer #{answer.pos} #{@buffer[answer.pos...@cur].inspect}" }
      return answer
    end
    @level -= 1
    debug { warn "#{ "  " * @level}NOMATCH footer #{answer.pos} #{@buffer[answer.pos...@cur].inspect}" }
    return nil
  end

  def evaluate_rule_EOF
    answer = ThunkChunk.new
    answer.pos = @cur
    answer.pos_loc = @cur_loc
    debug { warn "#{ "  " * @level}EVAL    EOF #{answer.pos} #{@buffer[answer.pos..-1].inspect}" }
    @level += 1
    answer.resize_captures(0)
    catch(0) do
      if refill_buffer(1) >= 1
        throw(0)
      end
      @level -= 1
      debug { warn "#{ "  " * @level}MATCH   EOF #{answer.pos} #{@buffer[answer.pos...@cur].inspect}" }
      return answer
    end
    @level -= 1
    debug { warn "#{ "  " * @level}NOMATCH EOF #{answer.pos} #{@buffer[answer.pos...@cur].inspect}" }
    return nil
  end

  def setup_lr(rule, lr)
    lr.head ||= LrHead.new(rule)
    @lrstack.reverse_each do |lrentry|
      if lrentry.head == lr.head
        break
      end
      lrentry.head = lr.head
      lr.head.involved_set[lrentry.rule] = true
    end
  end

  def grow_lr(rule, memo, head, pos, p_loc)
    @heads[pos] = head
    while true
      @cur = pos - @pos
      @cur_loc = p_loc - @pos_loc
      head.involved_set_to_eval_set
      answer = public_send(rule)
      if !answer || @pos + @cur <= memo.pos
        break
      end
      memo.answer = answer
      memo.pos = @pos + @cur
      memo.pos_loc = @pos_loc + @cur_loc
    end
    @heads[pos] = nil
    @cur = memo.pos - @pos
    @cur_loc = memo.pos_loc - @pos_loc
    memo.answer
  end

  def lr_answer(rule, memo, pos, p_loc)
    head = memo.lr.head
    if head.rule_name != rule
      return memo.lr.seed
    end

    memo.answer = memo.lr.seed
    if !memo.answer
      return nil
    end
    grow_lr(rule, memo, head, pos, p_loc)
  end

  def rule_answer(rule)
    pos = @pos + @cur
    p_loc = @pos_loc + @cur_loc
    memo = @memos[pos, rule]
    head = @heads[pos]

    if head
      if !memo && rule != head.rule_name && !head.involved_set[rule]
        return nil
      end
      if head.eval_set.delete(rule)
        return public_send(rule)
      end
    end

    if memo
      @cur = memo.pos - @pos
      @cur_loc = memo.pos_loc - @pos_loc
      if !memo.lr
        return memo.answer
      end
      setup_lr(rule, memo.lr)
      return memo.lr.seed
    end

    lr = LrEntry.new
    lr.rule = rule
    @lrstack.push(lr)
    memo = LrMemo.new(lr, pos, p_loc)
    @memos[pos, rule] = memo
    answer = public_send(rule)
    @lrstack.pop
    memo.pos = @pos + @cur
    memo.pos_loc = @pos_loc + @cur_loc
    if !lr.head
      memo.answer = answer
      return answer
    end

    lr.seed = answer
    lr_answer(rule, memo, pos, p_loc)
  end

  def apply_rule(rule, thunks, values, index)
    answer = rule_answer(rule)
    if !answer
      return false
    end
    values ||= @global_values
    thunks << ThunkNode.new(answer.thunks, values, index)
    return true
  end

  def do_action(thunks, values, index)
    thunks.each do |thunk|
      thunk.do_action(self, values, index)
    end
  end

  class Location
    attr_reader :charnum, :linenum

    def initialize(charnum = 0, linenum = 0)
      @charnum = charnum
      @linenum = linenum
    end

    def +(other)
      if other.linenum == 0
        Location.new(@charnum + other.charnum, @linenum + other.linenum)
      else
        Location.new(           other.charnum, @linenum + other.linenum)
      end
    end

    def -(other)
      if other.linenum == self.linenum
        Location.new(@charnum - other.charnum, @linenum - other.linenum)
      elsif other.charnum == 0
        Location.new(@charnum - other.charnum, @linenum - other.linenum)
      else
        raise "unexpected location #{self.inspect} - #{other.inspect}"
      end
    end

    def forward(buffer, cur, n)
      Location.new(@charnum, @linenum).forward!(buffer, cur, n)
    end

    def forward!(buffer, cur, n)
      buffer[cur, n].scan(/(.*)(\n)?/) do
        if Regexp.last_match[2]
          @linenum += 1
          @charnum = 0
        else
          @charnum += Regexp.last_match[1].length
        end
      end
      self
    end
  end

  class LrMemoTable
    def initialize
      @memos = {}
    end

    def clear
      @memos.clear
    end

    def []=(index, rule_name, memo)
      entry = @memos[index] ||= {}
      entry[rule_name] = memo
    end

    def [](index, rule_name)
      @memos.dig(index, rule_name)
    end
  end

  class LrHead
    attr_accessor :rule_name, :involved_set, :eval_set

    def initialize(rule_name)
      @rule_name = rule_name
      @involved_set = {}
      @eval_set = {}
    end

    def involved_set_to_eval_set
      @eval_set.clear
      @involved_set.each do |k, v|
        @eval_set[k] = true
      end
    end
  end

  class ThunkChunk
    attr_accessor :thunks, :capts, :pos, :values
    attr_accessor :pos_loc

    def initialize
      super
      @thunks = []
      @capts = {}
      @pos = 0
      @values = {}
    end

    def resize_captures(len)
      len.times do |i|
        @capts[i] = Capture.new
      end
    end
  end

  class Thunk
  end

  class ThunkLeaf < Thunk
    attr_accessor :capt0, :capts, :value_refs, :action

    def initialize(action, capt0 = Capture.new, value_refs = {}, capts = {})
      @value_refs = value_refs
      @capts = capts
      @capt0 = capt0
      @action = action
    end

    def do_action(ctx, values, index)
      ctx.public_send(action, self, values, index)
    end
  end

  class ThunkNode < Thunk
    attr_accessor :thunks, :values, :index

    def initialize(thunks, values, index)
      @thunks = thunks
      @values = values
      @index = index
      values[index] ||= Value.new if values
    end

    def do_action(ctx, _values, _index)
      @thunks.each do |thunk|
        thunk.do_action(ctx, @values, @index)
      end
    end

    def clear
      @thunks.clear
    end
  end

  class LrEntry
    attr_accessor :rule, :head, :seed
  end

  class Capture
    attr_accessor :range_start, :range_end
    attr_accessor :start_loc, :end_loc

    def initialize(range_start = 0, range_end = 0, start_loc = nil, end_loc = nil)
      @range_start = range_start
      @range_end = range_end
      @start_loc = start_loc || Location.new
      @end_loc = end_loc || Location.new
    end

    def capture_string(buffer)
      @string ||= buffer[@range_start, @range_end - @range_start]
    end
  end

  class LrMemo
    attr_accessor :lr, :answer, :pos
    attr_accessor :pos_loc

    def initialize(lr, pos, pos_loc)
      @pos = pos
      @pos_loc = pos_loc
      @lr = lr
    end

    def answer=(answer)
      @lr = nil
      @answer = answer
    end
  end

  class Value
    attr_accessor :value
  end
end

class Packcr::Parser
  def getc
    @ifile.getc
  end
end
