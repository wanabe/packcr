/* A packrat parser generated by PackCR <%= Packcr::VERSION %> */

<%- @esource.each do |code| -%>
<%=   hstream.get_code_block(code, 0, @iname) -%>
<%- end -%>
<%- if !@esource.empty? -%>

<%- end -%>
#ifdef _MSC_VER
#undef _CRT_SECURE_NO_WARNINGS
#define _CRT_SECURE_NO_WARNINGS
#endif /* _MSC_VER */
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#ifndef _MSC_VER
#if defined __GNUC__ && defined _WIN32 /* MinGW */
#ifndef PCC_USE_SYSTEM_STRNLEN
#define strnlen(str, maxlen) pcc_strnlen(str, maxlen)
static size_t pcc_strnlen(const char *str, size_t maxlen) {
    size_t i;
    for (i = 0; i < maxlen && str[i]; i++);
    return i;
}
#endif /* !PCC_USE_SYSTEM_STRNLEN */
#endif /* defined __GNUC__ && defined _WIN32 */
#endif /* !_MSC_VER */

<%- @eheader.each do |code| -%>
<%=   hstream.get_code_block(code, 0, @iname) -%>
<%- end -%>
<%- if !@eheader.empty? -%>

<%- end -%>

<%- @header.each do |code| -%>
<%=   hstream.get_code_block(code, 0, @iname) -%>
<%- end -%>
#ifdef __cplusplus
extern "C" {
#endif

#ifdef __
#undef __
#endif

#ifdef __cplusplus
}
#endif

<%- @source.each do |code| -%>
<%=   hstream.get_code_block(code, 0, @iname) -%>
<%- end -%>
#if !defined __has_attribute || defined _MSC_VER
#define __attribute__(x)
#endif

#ifdef _MSC_VER
#define MARK_FUNC_AS_USED __pragma(warning(suppress:4505))
#else
#define MARK_FUNC_AS_USED __attribute__((__unused__))
#endif

#ifndef PCC_BUFFER_MIN_SIZE
#define PCC_BUFFER_MIN_SIZE 256
#endif /* !PCC_BUFFER_MIN_SIZE */

#ifndef PCC_ARRAY_MIN_SIZE
#define PCC_ARRAY_MIN_SIZE 2
#endif /* !PCC_ARRAY_MIN_SIZE */

#ifndef PCC_POOL_MIN_SIZE
#define PCC_POOL_MIN_SIZE 65536
#endif /* !PCC_POOL_MIN_SIZE */

#define PCC_DBG_EVALUATE 0
#define PCC_DBG_MATCH    1
#define PCC_DBG_NOMATCH  2

#define PCC_VOID_VALUE (~(size_t)0)

typedef struct pcc_range_tag {
    size_t start;
    size_t end;
} pcc_range_t;

typedef struct pcc_value_tag {
    <%= value_def %>value;
} pcc_value_t;

typedef <%= auxil_def %>pcc_auxil_t;

typedef struct pcc_value_table_tag {
    pcc_value_t *buf;
    size_t max;
    size_t len;
} pcc_value_table_t;

typedef struct pcc_value_refer_table_tag {
    pcc_value_t **buf;
    size_t max;
    size_t len;
} pcc_value_refer_table_t;

typedef struct pcc_capture_tag {
    VALUE robj;
    pcc_range_t range;
} pcc_capture_t;

typedef struct pcc_thunk_tag pcc_thunk_t;

struct pcc_thunk_tag {
    VALUE robj;
    size_t index;                       /* node */
    pcc_value_refer_table_t value_refs; /* leaf */
};

typedef enum pcc_lr_answer_type_tag {
    PCC_LR_ANSWER_LR,
    PCC_LR_ANSWER_CHUNK
} pcc_lr_answer_type_t;

typedef struct pcc_lr_answer_tag pcc_lr_answer_t;

struct pcc_lr_answer_tag {
    VALUE robj;
    pcc_lr_answer_type_t type;
};

#ifndef PCC_ERROR
#define PCC_ERROR(auxil) pcc_error()
MARK_FUNC_AS_USED
static void pcc_error(void) {
    fprintf(stderr, "Syntax error\n");
    exit(1);
}
#endif /* !PCC_ERROR */

#ifndef PCC_GETCHAR
#define PCC_GETCHAR(auxil) NUM2INT(rb_funcall(rb_mKernel, rb_intern("getb"), 0))
#endif /* !PCC_GETCHAR */

#ifndef PCC_REALLOC
#define PCC_REALLOC(auxil, ptr, size) pcc_realloc_e(ptr, size)
static void *pcc_realloc_e(void *ptr, size_t size) {
    void *const p = realloc(ptr, size);
    if (p == NULL) {
        fprintf(stderr, "Out of memory\n");
        exit(1);
    }
    return p;
}
#endif /* !PCC_REALLOC */

#ifndef PCC_DEBUG
#define PCC_DEBUG(auxil, event, rule, level, pos, buffer, length) ((void)0)
#endif /* !PCC_DEBUG */

static VALUE cLrEntry, cLrTableEntry, cLrHead, cLrAnswer, cThunk, cThunkChunk, cCapture, cValue;

static void pcc_thunk_mark(void *ptr) {
}

static void pcc_thunk_free(void *ptr) {
}

static size_t pcc_thunk_memsize(const void *ptr) {
    return sizeof(pcc_thunk_t);
}

static const rb_data_type_t pcc_thunk_data_type = {
    "pcc_thunk",
    {pcc_thunk_mark, pcc_thunk_free, pcc_thunk_memsize,},
    0, 0, RUBY_TYPED_WB_PROTECTED | RUBY_TYPED_FREE_IMMEDIATELY
};

static VALUE pcc_thunk_s_alloc(VALUE klass) {
    pcc_thunk_t *thunk;
    VALUE obj = TypedData_Make_Struct(klass, pcc_thunk_t, &pcc_thunk_data_type, thunk);

    return obj;
}

static void pcc_capture_mark(void *ptr) {
}

static void pcc_capture_free(void *ptr) {
}

static size_t pcc_capture_memsize(const void *ptr) {
    return sizeof(pcc_capture_t);
}

static const rb_data_type_t pcc_capture_data_type = {
    "pcc_capture",
    {pcc_capture_mark, pcc_capture_free, pcc_capture_memsize,},
    0, 0, RUBY_TYPED_WB_PROTECTED | RUBY_TYPED_FREE_IMMEDIATELY
};

static VALUE pcc_capture_s_alloc(VALUE klass) {
    pcc_capture_t *capt;
    VALUE obj = TypedData_Make_Struct(klass, pcc_capture_t, &pcc_capture_data_type, capt);
    capt->range.start = 0;
    capt->range.end = 0;
<%- if @location -%>
    rb_ivar_set(obj, rb_intern("@start_loc"), rb_funcall(cLocation, rb_intern("new"), 0));
    rb_ivar_set(obj, rb_intern("@end_loc"), rb_funcall(cLocation, rb_intern("new"), 0));
<%- end -%>

    return obj;
}

static void pcc_value_mark(void *ptr) {
}

static void pcc_value_free(void *ptr) {
}

static size_t pcc_value_memsize(const void *ptr) {
    return sizeof(pcc_value_t);
}

static const rb_data_type_t pcc_value_data_type = {
    "pcc_value",
    {pcc_value_mark, pcc_value_free, pcc_value_memsize,},
    0, 0, RUBY_TYPED_WB_PROTECTED | RUBY_TYPED_FREE_IMMEDIATELY
};

static VALUE pcc_value_s_alloc(VALUE klass) {
    pcc_value_t *value;
    VALUE obj = TypedData_Make_Struct(klass, pcc_value_t, &pcc_value_data_type, value);

    return obj;
}

static void pcc_lr_answer_mark(void *ptr) {
}

static void pcc_lr_answer_free(void *ptr) {
}

static size_t pcc_lr_answer_memsize(const void *ptr) {
    return sizeof(pcc_lr_answer_t);
}

static const rb_data_type_t pcc_lr_answer_data_type = {
    "pcc_lr_answer",
    {pcc_lr_answer_mark, pcc_lr_answer_free, pcc_lr_answer_memsize,},
    0, 0, RUBY_TYPED_WB_PROTECTED | RUBY_TYPED_FREE_IMMEDIATELY
};

static void pcc_value_refer_table__init(pcc_auxil_t auxil, pcc_value_refer_table_t *table) {
    table->len = 0;
    table->max = 0;
    table->buf = NULL;
}

static void pcc_value_refer_table__resize(pcc_auxil_t auxil, pcc_value_refer_table_t *table, size_t len) {
    size_t i;
    if (table->max < len) {
        size_t m = table->max;
        if (m == 0) m = PCC_ARRAY_MIN_SIZE;
        while (m < len && m != 0) m <<= 1;
        if (m == 0) m = len;
        table->buf = (pcc_value_t **)PCC_REALLOC(auxil, table->buf, sizeof(pcc_value_t *) * m);
        table->max = m;
    }
    for (i = table->len; i < len; i++) table->buf[i] = NULL;
    table->len = len;
}

MARK_FUNC_AS_USED
static pcc_thunk_t *pcc_thunk__create_leaf(pcc_auxil_t auxil, ID action, size_t valuec, size_t captc) {
    pcc_thunk_t *thunk;
    VALUE obj = TypedData_Make_Struct(cThunk, pcc_thunk_t, &pcc_thunk_data_type, thunk);
    thunk->robj = obj;
    rb_ivar_set(obj, rb_intern("@type"), ID2SYM(rb_intern("leaf")));
    pcc_value_refer_table__init(auxil, &thunk->value_refs);
    pcc_value_refer_table__resize(auxil, &thunk->value_refs, valuec);
    rb_ivar_set(obj, rb_intern("@capts"), rb_ary_new());
    rb_ivar_set(obj, rb_intern("@capt0"), rb_funcall(cCapture, rb_intern("new"), 0));
    rb_ivar_set(obj, rb_intern("@action"), ID2SYM(action));
    return thunk;
}

static pcc_thunk_t *pcc_thunk__create_node(pcc_auxil_t auxil, VALUE rthunks, VALUE rvalues, size_t index) {
    pcc_thunk_t *thunk;
    VALUE obj = TypedData_Make_Struct(cThunk, pcc_thunk_t, &pcc_thunk_data_type, thunk);
    thunk->robj = obj;
    rb_ivar_set(obj, rb_intern("@type"), ID2SYM(rb_intern("node")));
    rb_ivar_set(obj, rb_intern("@thunks"), rthunks);
    rb_ivar_set(obj, rb_intern("@values"), rvalues);
    thunk->index = index;
    return thunk;
}

static VALUE pcc_lr_answer_s_alloc(VALUE klass) {
    pcc_lr_answer_t *answer;
    VALUE obj = TypedData_Make_Struct(klass, pcc_lr_answer_t, &pcc_lr_answer_data_type, answer);
    answer->robj = obj;

    return obj;
}

static VALUE pcc_lr_answer_initialize(VALUE self, VALUE rtype, VALUE rpos<% if @location %>, VALUE pos_loc<% end %>) {
    pcc_lr_answer_t *answer;
    ID itype = SYM2ID(rtype);
    TypedData_Get_Struct(self, pcc_lr_answer_t, &pcc_lr_answer_data_type, answer);
    if (itype == rb_intern("lr")) {
        answer->type = PCC_LR_ANSWER_LR;
    } else if (itype == rb_intern("chunk")) {
        answer->type = PCC_LR_ANSWER_CHUNK;
    } else {
        rb_raise(rb_eRuntimeError, "invalid type for LrAnswer");
    }
    rb_ivar_set(self, rb_intern("@pos"), rpos);
<%- if @location -%>
    rb_ivar_set(self, rb_intern("@pos_loc"), pos_loc);
<%- end -%>
    return self;
}

static void pcc_lr_answer__set_chunk(VALUE rctx, VALUE ranswer, VALUE rchunk) {
    pcc_lr_answer_t *answer;
    VALUE rtype, ra;
    TypedData_Get_Struct(ranswer, pcc_lr_answer_t, &pcc_lr_answer_data_type, answer);
    switch (answer->type) {
    case PCC_LR_ANSWER_LR:
        rtype = ID2SYM(rb_intern("lr"));
        break;
    case PCC_LR_ANSWER_CHUNK:
        rtype = ID2SYM(rb_intern("chunk"));
        break;
    default:
        rb_raise(rb_eRuntimeError, "invalid type for set_chunk");
        rtype = Qnil;
    }
    ra = rb_funcall(cLrAnswer, rb_intern("new"), <% if @location %>3<% else %>2<% end %>, rtype, rb_ivar_get(ranswer, rb_intern("@pos"))<% if @location %>, rb_ivar_get(ranswer, rb_intern("@pos_loc"))<% end %>);
    switch (answer->type) {
    case PCC_LR_ANSWER_LR:
        rb_ivar_set(ra, rb_intern("@lr"), rb_ivar_get(ranswer, rb_intern("@lr")));
        break;
    case PCC_LR_ANSWER_CHUNK:
        rb_ivar_set(ra, rb_intern("@chunk"), rb_ivar_get(ranswer, rb_intern("@chunk")));
        break;
    default: /* unknown */
        break;
    }
    rb_ivar_set(ra, rb_intern("@hold"), rb_ivar_get(ranswer, rb_intern("@hold")));
    rb_ivar_set(ranswer, rb_intern("@hold"), ra);
    answer->type = PCC_LR_ANSWER_CHUNK;
    rb_ivar_set(ranswer, rb_intern("@chunk"), rchunk);
}

static size_t pcc_refill_buffer(VALUE rctx, size_t num) {
    return NUM2SIZET(rb_funcall(rctx, rb_intern("refill_buffer"), 1, SIZET2NUM(num)));
}

MARK_FUNC_AS_USED
static void pcc_commit_buffer(VALUE rctx) {
    rb_funcall(rctx, rb_intern("commit_buffer"), 0);
}

MARK_FUNC_AS_USED
static const char *pcc_get_capture_string(VALUE rctx, VALUE rcapt) {
    VALUE rstring = rb_ivar_get(rcapt, rb_intern("@string"));
    pcc_capture_t *capt;
    TypedData_Get_Struct(rcapt, pcc_capture_t, &pcc_capture_data_type, capt);
    if (NIL_P(rstring)) {
        rstring = rb_funcall(rb_ivar_get(rctx, rb_intern("@buffer")), rb_intern("[]"), 2, SIZET2NUM(capt->range.start), SIZET2NUM(capt->range.end - capt->range.start));
        rb_ivar_set(rcapt, rb_intern("@string"), rstring);
    }
    return StringValuePtr(rstring);
}

<% if @utf8 -%>
static size_t pcc_get_char_as_utf32(VALUE rctx, int *out) { /* with checking UTF-8 validity */
    int c, u;
    size_t n;
    if (pcc_refill_buffer(rctx, 1) < 1) return 0;
    c = (int)(unsigned char)RSTRING_PTR(rb_ivar_get(rctx, rb_intern("@buffer")))[NUM2SIZET(rb_ivar_get(rctx, rb_intern("@cur")))];
    n = (c < 0x80) ? 1 :
        ((c & 0xe0) == 0xc0) ? 2 :
        ((c & 0xf0) == 0xe0) ? 3 :
        ((c & 0xf8) == 0xf0) ? 4 : 0;
    if (n < 1) return 0;
    if (pcc_refill_buffer(rctx, n) < n) return 0;
    switch (n) {
    case 1:
        u = c;
        break;
    case 2:
        u = c & 0x1f;
        c = (int)(unsigned char)RSTRING_PTR(rb_ivar_get(rctx, rb_intern("@buffer")))[NUM2SIZET(rb_ivar_get(rctx, rb_intern("@cur"))) + 1];
        if ((c & 0xc0) != 0x80) return 0;
        u <<= 6; u |= c & 0x3f;
        if (u < 0x80) return 0;
        break;
    case 3:
        u = c & 0x0f;
        c = (int)(unsigned char)RSTRING_PTR(rb_ivar_get(rctx, rb_intern("@buffer")))[NUM2SIZET(rb_ivar_get(rctx, rb_intern("@cur"))) + 1];
        if ((c & 0xc0) != 0x80) return 0;
        u <<= 6; u |= c & 0x3f;
        c = (int)(unsigned char)RSTRING_PTR(rb_ivar_get(rctx, rb_intern("@buffer")))[NUM2SIZET(rb_ivar_get(rctx, rb_intern("@cur"))) + 2];
        if ((c & 0xc0) != 0x80) return 0;
        u <<= 6; u |= c & 0x3f;
        if (u < 0x800) return 0;
        break;
    case 4:
        u = c & 0x07;
        c = (int)(unsigned char)RSTRING_PTR(rb_ivar_get(rctx, rb_intern("@buffer")))[NUM2SIZET(rb_ivar_get(rctx, rb_intern("@cur"))) + 1];
        if ((c & 0xc0) != 0x80) return 0;
        u <<= 6; u |= c & 0x3f;
        c = (int)(unsigned char)RSTRING_PTR(rb_ivar_get(rctx, rb_intern("@buffer")))[NUM2SIZET(rb_ivar_get(rctx, rb_intern("@cur"))) + 2];
        if ((c & 0xc0) != 0x80) return 0;
        u <<= 6; u |= c & 0x3f;
        c = (int)(unsigned char)RSTRING_PTR(rb_ivar_get(rctx, rb_intern("@buffer")))[NUM2SIZET(rb_ivar_get(rctx, rb_intern("@cur"))) + 3];
        if ((c & 0xc0) != 0x80) return 0;
        u <<= 6; u |= c & 0x3f;
        if (u < 0x10000 || u > 0x10ffff) return 0;
        break;
    default:
        return 0;
    }
    if (out) *out = u;
    return n;
}

<% end -%>
MARK_FUNC_AS_USED
static VALUE pcc_apply_rule(VALUE rctx, ID rule, VALUE rthunks, VALUE rvalues, size_t index) {
    const size_t p = NUM2SIZET(rb_ivar_get(rctx, rb_intern("@pos"))) + NUM2SIZET(rb_ivar_get(rctx, rb_intern("@cur")));
<%- if @location -%>
    const VALUE p_loc = rb_funcall(rb_ivar_get(rctx, rb_intern("@pos_loc")), rb_intern("+"), 1, rb_ivar_get(rctx, rb_intern("@cur_loc")));
<%- end -%>
    VALUE b = Qtrue;
    VALUE rh, ra, rc = Qnil, rlrtable = rb_ivar_get(rctx, rb_intern("@lrtable"));
    pcc_lr_answer_t *a;
    ra = rb_funcall(rlrtable, rb_intern("get_answer"), 2, SIZET2NUM(p), ID2SYM(rule));
    if (NIL_P(ra)) {
        a = NULL;
    } else {
        TypedData_Get_Struct(ra, pcc_lr_answer_t, &pcc_lr_answer_data_type, a);
    }
    rh = rb_funcall(rlrtable, rb_intern("get_head"), 1, SIZET2NUM(p));
    if (!NIL_P(rh)) {
        VALUE rinvol = rb_ivar_get(rh, rb_intern("@invol"));
        ID rule_name = SYM2ID(rb_ivar_get(rh, rb_intern("@rule_name")));
        if (a == NULL && rule != rule_name && NIL_P(rb_funcall(rinvol, rb_intern("[]"), 1, ID2SYM(rule)))) {
            b = Qfalse;
            rc = Qnil;
        } else {
            VALUE reval = rb_ivar_get(rh, rb_intern("@eval"));
            if (RTEST(rb_funcall(reval, rb_intern("delete"), 1, ID2SYM(rule)))) {
                rc = rb_funcall(rctx, rule, 0);
                b = Qfalse;
                {
                    VALUE ranswer = rb_funcall(cLrAnswer, rb_intern("new"), <% if @location %>3<% else %>2<% end %>, ID2SYM(rb_intern("chunk")), SIZET2NUM(NUM2SIZET(rb_ivar_get(rctx, rb_intern("@pos"))) + NUM2SIZET(rb_ivar_get(rctx, rb_intern("@cur"))))<% if @location %>, rb_funcall(rb_ivar_get(rctx, rb_intern("@pos_loc")), rb_intern("+"), 1, rb_ivar_get(rctx, rb_intern("@cur_loc")))<% end %>);
                    TypedData_Get_Struct(ranswer, pcc_lr_answer_t, &pcc_lr_answer_data_type, a);
                }
                rb_ivar_set(a->robj, rb_intern("@chunk"), rc);
                rb_funcall(rlrtable, rb_intern("hold_answer"), 2, SIZET2NUM(p), a->robj);
            }
        }
    }
    if (RTEST(b)) {
        if (a != NULL) {
            rb_ivar_set(rctx, rb_intern("@cur"), SIZET2NUM(NUM2SIZET(rb_ivar_get(a->robj, rb_intern("@pos"))) - NUM2SIZET(rb_ivar_get(rctx, rb_intern("@pos")))));
<%- if @location -%>
            rb_ivar_set(rctx, rb_intern("@cur_loc"), rb_funcall(rb_ivar_get(a->robj, rb_intern("@pos_loc")), rb_intern("-"), 1, rb_ivar_get(rctx, rb_intern("@pos_loc"))));
<%- end -%>
            switch (a->type) {
            case PCC_LR_ANSWER_LR:
                {
                    VALUE rlr = rb_ivar_get(a->robj, rb_intern("@lr"));
                    VALUE rhead = rb_ivar_get(rlr, rb_intern("@head"));
                    if (NIL_P(rhead)) {
                        rhead = rb_funcall(cLrHead, rb_intern("new"), 0);
                        rb_ivar_set(rlr, rb_intern("@head"), rhead);
                        rb_ivar_set(rhead, rb_intern("@rule_name"), ID2SYM(rule));
                        rb_funcall(rlrtable, rb_intern("hold_head"), 2, SIZET2NUM(p), rhead);
                    }
                }
                {
                    size_t i = RARRAY_LEN(rb_ivar_get(rctx, rb_intern("@lrstack")));
                    VALUE rlr;
                    while (i > 0) {
                        VALUE rinvol;
                        i--;
                        VALUE rlrentry = rb_funcall(rb_ivar_get(rctx, rb_intern("@lrstack")), rb_intern("[]"), 1, SIZET2NUM(i));
                        VALUE rentry_head, ranswer_head;
                        rentry_head = rb_ivar_get(rlrentry, rb_intern("@head"));
                        rlr = rb_ivar_get(a->robj, rb_intern("@lr"));
                        ranswer_head = rb_ivar_get(rlr, rb_intern("@head"));
                        if (rentry_head == ranswer_head) break;
                        rb_ivar_set(rlrentry, rb_intern("@head"), ranswer_head);
                        rinvol = rb_ivar_get(ranswer_head, rb_intern("@invol"));
                        rb_funcall(rinvol, rb_intern("[]="), 2, rb_ivar_get(rlrentry, rb_intern("@rule")), Qtrue);
                    }
                    rlr = rb_ivar_get(a->robj, rb_intern("@lr"));
                    rc = rb_ivar_get(rlr, rb_intern("@seed"));
                }
                break;
            case PCC_LR_ANSWER_CHUNK:
                rc = rb_ivar_get(a->robj, rb_intern("@chunk"));
                break;
            default: /* unknown */
                break;
            }
        }
        else {
            VALUE rentry = rb_funcall(cLrEntry, rb_intern("new"), 0);
            rb_ivar_set(rentry, rb_intern("@rule"), ID2SYM(rule));
            rb_funcall(rb_ivar_get(rctx, rb_intern("@lrstack")), rb_intern("push"), 1, rentry);
            {
                VALUE ranswer = rb_funcall(cLrAnswer, rb_intern("new"), <% if @location %>3<% else %>2<% end %>, ID2SYM(rb_intern("lr")), SIZET2NUM(p)<% if @location %>, p_loc<% end %>);
                TypedData_Get_Struct(ranswer, pcc_lr_answer_t, &pcc_lr_answer_data_type, a);
            }
            rb_ivar_set(a->robj, rb_intern("@lr"), rentry);
            rb_funcall(rlrtable, rb_intern("set_answer"), 3, SIZET2NUM(p), ID2SYM(rule), a->robj);
            rc = rb_funcall(rctx, rule, 0);
            rb_funcall(rb_ivar_get(rctx, rb_intern("@lrstack")), rb_intern("pop"), 0);
            rb_ivar_set(a->robj, rb_intern("@pos"), SIZET2NUM(NUM2SIZET(rb_ivar_get(rctx, rb_intern("@pos"))) + NUM2SIZET(rb_ivar_get(rctx, rb_intern("@cur")))));
<%- if @location -%>
            rb_ivar_set(a->robj, rb_intern("@pos_loc"), rb_funcall(rb_ivar_get(rctx, rb_intern("@pos_loc")), rb_intern("+"), 1, rb_ivar_get(rctx, rb_intern("@cur_loc"))));
<%- end -%>
            if (NIL_P(rb_ivar_get(rentry, rb_intern("@head")))) {
                pcc_lr_answer__set_chunk(rctx, a->robj, rc);
            }
            else {
                ID rule_name;
                VALUE rlr = rb_ivar_get(a->robj, rb_intern("@lr"));
                rb_ivar_set(rentry, rb_intern("@seed"), rc);
                rh = rb_ivar_get(rlr, rb_intern("@head"));
                rule_name = SYM2ID(rb_ivar_get(rh, rb_intern("@rule_name")));
                if (rule_name != rule) {
                    rc = rb_ivar_get(rlr, rb_intern("@seed"));
                    {
                        VALUE ranswer = rb_funcall(cLrAnswer, rb_intern("new"), <% if @location %>3<% else %>2<% end %>, ID2SYM(rb_intern("chunk")), SIZET2NUM(NUM2SIZET(rb_ivar_get(rctx, rb_intern("@pos"))) + NUM2SIZET(rb_ivar_get(rctx, rb_intern("@cur"))))<% if @location %>, rb_funcall(rb_ivar_get(rctx, rb_intern("@pos_loc")), rb_intern("+"), 1, rb_ivar_get(rctx, rb_intern("@cur_loc")))<% end %>);
                        TypedData_Get_Struct(ranswer, pcc_lr_answer_t, &pcc_lr_answer_data_type, a);
                    }
                    rb_ivar_set(a->robj, rb_intern("@chunk"),  rc);
                    rb_funcall(rlrtable, rb_intern("hold_answer"), 2, SIZET2NUM(p), a->robj);
                }
                else {
                    VALUE rseed = rb_ivar_get(rlr, rb_intern("@seed"));
                    VALUE rchunk;
                    pcc_lr_answer__set_chunk(rctx, a->robj, rseed);
                    rchunk = rb_ivar_get(a->robj, rb_intern("@chunk"));
                    if (NIL_P(rchunk)) {
                        rc = Qnil;
                    }
                    else {
                        rb_funcall(rlrtable, rb_intern("set_head"), 2, SIZET2NUM(p), rh);
                        for (;;) {
                            rb_ivar_set(rctx, rb_intern("@cur"), SIZET2NUM(p - NUM2SIZET(rb_ivar_get(rctx, rb_intern("@pos")))));
<%- if @location -%>
                            rb_ivar_set(rctx, rb_intern("@cur_loc"), rb_funcall(p_loc, rb_intern("-"), 1, rb_ivar_get(rctx, rb_intern("@pos_loc"))));
<%- end -%>
                            rb_funcall(rh, rb_intern("invol_to_eval"), 0);
                            rc = rb_funcall(rctx, rule, 0);
                            if (NIL_P(rc) || NUM2SIZET(rb_ivar_get(rctx, rb_intern("@pos"))) + NUM2SIZET(rb_ivar_get(rctx, rb_intern("@cur"))) <= NUM2SIZET(rb_ivar_get(a->robj, rb_intern("@pos")))) break;
                            pcc_lr_answer__set_chunk(rctx, a->robj, rc);
                            rb_ivar_set(a->robj, rb_intern("@pos"), SIZET2NUM(NUM2SIZET(rb_ivar_get(rctx, rb_intern("@pos"))) + NUM2SIZET(rb_ivar_get(rctx, rb_intern("@cur")))));
<%- if @location -%>
                            a->pos_loc = pcc_location_add(rb_ivar_get(rctx, rb_intern("@pos_loc")), ctx->cur_loc);
<%- end -%>
                        }
                        rb_funcall(rlrtable, rb_intern("set_head"), 2, SIZET2NUM(p), Qnil);
                        rb_ivar_set(rctx, rb_intern("@cur"), SIZET2NUM(NUM2SIZET(rb_ivar_get(a->robj, rb_intern("@pos"))) - NUM2SIZET(rb_ivar_get(rctx, rb_intern("@pos")))));
<%- if @location -%>
                        rb_ivar_set(rctx, rb_intern("@cur_loc"), rb_funcall(rb_ivar_get(a->robj, rb_intern("@pos_loc")), rb_intern("-"), 1, rb_ivar_get(rctx, rb_intern("@pos_loc"))));
<%- end -%>
                        rchunk = rb_ivar_get(a->robj, rb_intern("@chunk"));
                        rc = rchunk;
                    }
                }
            }
        }
    }
    if (NIL_P(rc)) return Qfalse;
    if (!NIL_P(rvalues)) {
        rb_funcall(rvalues, rb_intern("[]="), 2, SIZET2NUM(index), rb_funcall(cValue, rb_intern("new"), 0)); /* in case */
    }
    {
        pcc_thunk_t *t = pcc_thunk__create_node(NULL, rb_ivar_get(rc, rb_intern("@thunks")), rvalues, index);
        rb_funcall(rthunks, rb_intern("push"), 1, t->robj);
    }
    return Qtrue;
}

static VALUE pcc_do_action(VALUE rctx, VALUE rthunks, VALUE rvalues, VALUE rindex) {
    size_t index = NUM2SIZET(rindex);
    size_t i;
    for (i = 0; i < (size_t)RARRAY_LEN(rthunks); i++) {
        pcc_thunk_t *thunk;
        VALUE rthunk = rb_funcall(rthunks, rb_intern("[]"), 1, SIZET2NUM(i));
        VALUE rtype = rb_ivar_get(rthunk, rb_intern("@type"));
        ID type = SYM2ID(rtype);
        TypedData_Get_Struct(rthunk, pcc_thunk_t, &pcc_thunk_data_type, thunk);
        if (type == rb_intern("leaf")) {
            rb_funcall(rctx, SYM2ID(rb_ivar_get(rthunk, rb_intern("@action"))), 3, thunk->robj, rvalues, SIZET2NUM(index));
        } else if (type == rb_intern("node")) {
            rb_funcall(rctx, rb_intern("do_action"), 3, rb_ivar_get(thunk->robj, rb_intern("@thunks")), rb_ivar_get(thunk->robj, rb_intern("@values")), SIZET2NUM(thunk->index));
        }
    }
    return rctx;
}

static inline pcc_capture_t *pcc_thunk_leaf__get_capt0(VALUE rthunk) {
    VALUE rcapt0 = rb_ivar_get(rthunk, rb_intern("@capt0"));
    pcc_capture_t *capt0;
    TypedData_Get_Struct(rcapt0, pcc_capture_t, &pcc_capture_data_type, capt0);
    return capt0;
}

static inline pcc_value_t *pcc_value__ptr(VALUE rvalues, VALUE rindex) {
    VALUE rvalue;
    pcc_value_t *value;
    rvalue = rb_funcall(rvalues, rb_intern("[]"), 1, rindex);
    if (NIL_P(rvalue)) {
        rvalue = rb_funcall(cValue, rb_intern("new"), 0);
        rb_funcall(rvalues, rb_intern("[]="), 2, rindex, rvalue);
    }
    TypedData_Get_Struct(rvalue, pcc_value_t, &pcc_value_data_type, value);
    return value;
}

static inline pcc_thunk_t *pcc_thunk__ptr(VALUE rthunk) {
    pcc_thunk_t *thunk;
    TypedData_Get_Struct(rthunk, pcc_thunk_t, &pcc_thunk_data_type, thunk);
    return thunk;
}

<%- @rules.each do |rule| -%>
<%-   rule.codes.each do |code| -%>
static VALUE pcc_action_<%= rule.name %>_<%= code.index %>(VALUE __pcc_ctx, VALUE __pcc_rin, VALUE __pcc_rvars, VALUE __pcc_rindex) {
#define __ pcc_value__ptr(__pcc_rvars, __pcc_rindex)->value
<%-     code.vars.each do |ref| -%>
#define <%= ref.var %> (pcc_thunk__ptr(__pcc_rin)->value_refs.buf[<%= ref.index %>]->value)
<%-     end -%>
#define _0 pcc_get_capture_string(__pcc_ctx, rb_ivar_get(__pcc_rin, rb_intern("@capt0")))
#define _0s ((const size_t)(__pcc_NUM2SIZET(rb_ivar_get(rctx, rb_intern("@pos"))) + pcc_thunk_leaf__get_capt0(__pcc_rin)->range.start))
#define _0e ((const size_t)(__pcc_NUM2SIZET(rb_ivar_get(rctx, rb_intern("@pos"))) + pcc_thunk_leaf__get_capt0(__pcc_rin)->range.end))
<%-     code.capts.each do |capture| -%>
#define _<%= capture.index + 1 %> pcc_get_capture_string(__pcc_ctx, rb_funcall(rb_ivar_get(__pcc_rin, rb_intern("@capts")), rb_intern("[]"), 1, SIZET2NUM(<%= capture.index %>)))
#define _<%= capture.index + 1 %>s ((const size_t)(__pcc_NUM2SIZET(rb_ivar_get(rctx, rb_intern("@pos"))) + pcc_thunk__ptr(__pcc_rin)->data.leaf.capts.buf[<%= capture.index %>]->range.start))
#define _<%= capture.index + 1 %>e ((const size_t)(__pcc_NUM2SIZET(rb_ivar_get(rctx, rb_intern("@pos"))) + pcc_thunk__ptr(__pcc_rin)->data.leaf.capts.buf[<%= capture.index %>]->range.end))
<%-       if @location -%>
#define _<%= capture.index + 1 %>sl ((const VALUE)(rb_funcall(rb_ivar_get(__pcc_ctx, rb_intern("@pos_loc")), rb_intern("+"), 1, rb_ivar_get(pcc_thunk__ptr(__pcc_rin)->data.leaf.capts.buf[<%= capture.index %>]->robj, rb_intern("@start_loc")))))
#define _<%= capture.index + 1 %>el ((const VALUE)(rb_funcall(rb_ivar_get(__pcc_ctx, rb_intern("@pos_loc")), rb_intern("+"), 1, rb_ivar_get(pcc_thunk__ptr(__pcc_rin)->data.leaf.capts.buf[<%= capture.index %>]->robj, rb_intern("@end_loc")))))
<%-       end -%>
<%-     end -%>
<%=     hstream.get_code_block(code.code, 4, @iname) -%>
<%-     code.capts.reverse_each do |capture| -%>
<%-       if @location -%>
#undef _<%= capture.index + 1 %>el
#undef _<%= capture.index + 1 %>sl
<%-       end -%>
#undef _<%= capture.index + 1 %>e
#undef _<%= capture.index + 1 %>s
#undef _<%= capture.index + 1 %>
<%-     end -%>
#undef _0e
#undef _0s
#undef _0
<%- code.vars.reverse_each do |ref| -%>
#undef <%= ref.var %>
<%-     end -%>
#undef __
#undef auxil
    return Qnil;
}

<%-   end -%>
<%- end -%>
<%- @rules.each do |node| -%>
static VALUE pcc_evaluate_rule_<%= node.name %>(VALUE rctx);
<%- end -%>

<%- @rules.each do |node| -%>
static VALUE pcc_evaluate_rule_<%= node.name %>(VALUE rctx) {
    VALUE rchunk = rb_funcall(cThunkChunk, rb_intern("new"), 0);
    rb_ivar_set(rchunk, rb_intern("@pos"), rb_ivar_get(rctx, rb_intern("@cur")));
<%- if @location -%>
    rb_ivar_set(rchunk, rb_intern("@pos_loc"), rb_ivar_get(rctx, rb_intern("@cur_loc")));
<%- end -%>
    //PCC_DEBUG(NULL, PCC_DBG_EVALUATE, "<%= node.name %>", NUM2SIZET(rb_ivar_get(rctx, rb_intern("@level"))), NUM2SIZET(rb_ivar_get(rchunk, rb_intern("@pos"))), (RSTRING_PTR(rb_ivar_get(rctx, rb_intern("@buffer"))) + NUM2SIZET(rb_ivar_get(rchunk, rb_intern("@pos")))), (RSTRING_LEN(rb_ivar_get(rctx, rb_intern("@buffer"))) - NUM2SIZET(rb_ivar_get(rchunk, rb_intern("@pos")))));
    rb_ivar_set(rctx, rb_intern("@level"), SIZET2NUM(NUM2SIZET(rb_ivar_get(rctx, rb_intern("@level"))) + 1));
    rb_funcall(rchunk, rb_intern("resize_captures"), 1, SIZET2NUM(<%= node.capts.length %>));
<%-   if node.vars.length > 0 -%>
    rb_ivar_set(rchunk, rb_intern("@values"), rb_ary_new());
<%-   end -%>
<%-   g = ::Packcr::Generator.new(node, @ascii, @location, :rb) -%>
<%-   r, str = g.generate_code_str(node.expr, 0, 4, false) -%>
<%=   str -%>
    rb_ivar_set(rctx, rb_intern("@level"), SIZET2NUM(NUM2SIZET(rb_ivar_get(rctx, rb_intern("@level"))) - 1));
    //PCC_DEBUG(NULL, PCC_DBG_MATCH, "<%= node.name %>", NUM2SIZET(rb_ivar_get(rctx, rb_intern("@level"))), NUM2SIZET(rb_ivar_get(rchunk, rb_intern("@pos")))$1 (RSTRING_PTR(rb_ivar_get(rctx, rb_intern("@buffer"))) + NUM2SIZET(rb_ivar_get(rchunk, rb_intern("@pos")))$1, (NUM2SIZET(rb_ivar_get(rctx, rb_intern("@cur"))) - NUM2SIZET(rb_ivar_get(rchunk, rb_intern("@pos")))$1);
    return rchunk;
<%-   if r != Packcr::CODE_REACH__ALWAYS_SUCCEED -%>
L0000:;
    rb_ivar_set(rctx, rb_intern("@level"), SIZET2NUM(NUM2SIZET(rb_ivar_get(rctx, rb_intern("@level"))) - 1));
    //PCC_DEBUG(NULL, PCC_DBG_NOMATCH, "<%= node.name %>", NUM2SIZET(rb_ivar_get(rctx, rb_intern("@level"))), NUM2SIZET(rb_ivar_get(rchunk, rb_intern("@pos")))$1 (RSTRING_PTR(rb_ivar_get(rctx, rb_intern("@buffer"))) + NUM2SIZET(rb_ivar_get(rchunk, rb_intern("@pos")))$1, (NUM2SIZET(rb_ivar_get(rctx, rb_intern("@cur"))) - NUM2SIZET(rb_ivar_get(rchunk, rb_intern("@pos")))$1);
    return Qnil;
<%-   end -%>
}

<%- end -%>

int <%= prefix %>_parse(VALUE rctx, <%= value_def %>*ret) {
<%- if !@rules.empty? -%>
    VALUE rthunks = rb_ivar_get(rctx, rb_intern("@thunks"));
    if (pcc_apply_rule(rctx, rb_intern("evaluate_rule_<%= @rules[0].name %>"), rthunks, Qnil, 0))
        rb_funcall(rctx, rb_intern("do_action"), 3, rthunks, Qnil, SIZET2NUM(0));
    else
        PCC_ERROR(NULL);
    pcc_commit_buffer(rctx);
<%- end -%>
    rb_funcall(rthunks, rb_intern("clear"), 0);
    return pcc_refill_buffer(rctx, 1) >= 1;
}

<%- @lheader.each do |code| -%>
<%=   hstream.get_code_block(code, 0, @iname) -%>
<%- end -%>

static VALUE <%= prefix %>_run(VALUE self) {
    while (<%= prefix %>_parse(self, NULL));
    return Qfalse;
}

void Init_<%= prefix %>(void) {
    VALUE c<%= class_name %> = rb_const_get(rb_cObject, rb_intern("<%= class_name %>"));

    rb_define_method(c<%= class_name %>, "run", <%= prefix %>_run, 0);
    rb_define_method(c<%= class_name %>, "do_action", pcc_do_action, 3);
    <%- @rules.each do |rule| -%>
    rb_define_method(c<%= class_name %>, "evaluate_rule_<%= rule.name %>", pcc_evaluate_rule_<%= rule.name %>, 0);
    <%-   rule.codes.each do |code| -%>
    rb_define_method(c<%= class_name %>, "action_<%= rule.name %>_<%= code.index %>", pcc_action_<%= rule.name %>_<%= code.index %>, 3);
    <%-   end -%>
    <%- end -%>

    cLrEntry = rb_const_get(c<%= class_name %>, rb_intern("LrEntry"));

    cLrTableEntry = rb_const_get(c<%= class_name %>, rb_intern("LrTableEntry"));

    cLrHead = rb_const_get(c<%= class_name %>, rb_intern("LrHead"));

    cLrAnswer = rb_define_class_under(c<%= class_name %>, "LrAnswer", rb_cObject);
    rb_define_alloc_func(cLrAnswer, pcc_lr_answer_s_alloc);
    rb_define_method(cLrAnswer, "initialize", pcc_lr_answer_initialize, <% if @location %>3<% else %>2<% end %>);

    cThunk = rb_define_class_under(c<%= class_name %>, "Thunk", rb_cObject);
    rb_define_alloc_func(cThunk, pcc_thunk_s_alloc);

    cThunkChunk = rb_const_get(c<%= class_name %>, rb_intern("ThunkChunk"));

    cCapture = rb_define_class_under(c<%= class_name %>, "Capture", rb_cObject);
    rb_define_alloc_func(cCapture, pcc_capture_s_alloc);

    cValue = rb_define_class_under(c<%= class_name %>, "Value", rb_cObject);
    rb_define_alloc_func(cValue, pcc_value_s_alloc);
}
