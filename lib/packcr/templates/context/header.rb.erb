/* A packrat parser generated by PackCR <%= Packcr::VERSION %> */

<%- @esource.each do |code| -%>
<%=   hstream.get_code_block(code, 0, @iname) -%>
<%- end -%>
<%- if !@esource.empty? -%>

<%- end -%>
#ifdef _MSC_VER
#undef _CRT_SECURE_NO_WARNINGS
#define _CRT_SECURE_NO_WARNINGS
#endif /* _MSC_VER */
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#ifndef _MSC_VER
#if defined __GNUC__ && defined _WIN32 /* MinGW */
#ifndef PCC_USE_SYSTEM_STRNLEN
#define strnlen(str, maxlen) pcc_strnlen(str, maxlen)
static size_t pcc_strnlen(const char *str, size_t maxlen) {
    size_t i;
    for (i = 0; i < maxlen && str[i]; i++);
    return i;
}
#endif /* !PCC_USE_SYSTEM_STRNLEN */
#endif /* defined __GNUC__ && defined _WIN32 */
#endif /* !_MSC_VER */

<%- @eheader.each do |code| -%>
<%=   hstream.get_code_block(code, 0, @iname) -%>
<%- end -%>
<%- if !@eheader.empty? -%>

<%- end -%>

<%- @header.each do |code| -%>
<%=   hstream.get_code_block(code, 0, @iname) -%>
<%- end -%>
#ifdef __cplusplus
extern "C" {
#endif

#ifdef __
#undef __
#endif

#ifdef __cplusplus
}
#endif

<%- @source.each do |code| -%>
<%=   hstream.get_code_block(code, 0, @iname) -%>
<%- end -%>
#if !defined __has_attribute || defined _MSC_VER
#define __attribute__(x)
#endif

#ifdef _MSC_VER
#define MARK_FUNC_AS_USED __pragma(warning(suppress:4505))
#else
#define MARK_FUNC_AS_USED __attribute__((__unused__))
#endif

#ifndef PCC_BUFFER_MIN_SIZE
#define PCC_BUFFER_MIN_SIZE 256
#endif /* !PCC_BUFFER_MIN_SIZE */

#ifndef PCC_ARRAY_MIN_SIZE
#define PCC_ARRAY_MIN_SIZE 2
#endif /* !PCC_ARRAY_MIN_SIZE */

#ifndef PCC_POOL_MIN_SIZE
#define PCC_POOL_MIN_SIZE 65536
#endif /* !PCC_POOL_MIN_SIZE */

#define PCC_DBG_EVALUATE 0
#define PCC_DBG_MATCH    1
#define PCC_DBG_NOMATCH  2

#define PCC_VOID_VALUE (~(size_t)0)

typedef struct pcc_range_tag {
    size_t start;
    size_t end;
} pcc_range_t;

typedef struct pcc_value_tag {
    <%= value_def %>value;
} pcc_value_t;

typedef <%= auxil_def %>pcc_auxil_t;

typedef struct pcc_value_table_tag {
    pcc_value_t *buf;
    size_t max;
    size_t len;
} pcc_value_table_t;

typedef struct pcc_value_refer_table_tag {
    pcc_value_t **buf;
    size_t max;
    size_t len;
} pcc_value_refer_table_t;

typedef struct pcc_capture_tag {
    VALUE robj;
    pcc_range_t range;
    char *string; /* mutable */
} pcc_capture_t;

typedef struct pcc_capture_const_table_tag {
    const pcc_capture_t **buf;
    size_t max;
    size_t len;
} pcc_capture_const_table_t;

typedef struct pcc_thunk_tag pcc_thunk_t;

typedef void (*pcc_action_t)(VALUE, pcc_thunk_t *, pcc_value_t *, size_t);

typedef enum pcc_thunk_type_tag {
    PCC_THUNK_LEAF,
    PCC_THUNK_NODE
} pcc_thunk_type_t;

typedef struct pcc_thunk_leaf_tag {
    pcc_value_refer_table_t value_refs;
    pcc_action_t action;
} pcc_thunk_leaf_t;

typedef struct pcc_thunk_node_tag {
    size_t index;
} pcc_thunk_node_t;

typedef union pcc_thunk_data_tag {
    pcc_thunk_leaf_t leaf;
    pcc_thunk_node_t node;
} pcc_thunk_data_t;

struct pcc_thunk_tag {
    VALUE robj;
    pcc_thunk_type_t type;
    pcc_thunk_data_t data;
};

typedef struct pcc_thunk_chunk_tag {
    VALUE robj;
    pcc_value_table_t values;
} pcc_thunk_chunk_t;

typedef struct pcc_lr_entry_tag pcc_lr_entry_t;

typedef enum pcc_lr_answer_type_tag {
    PCC_LR_ANSWER_LR,
    PCC_LR_ANSWER_CHUNK
} pcc_lr_answer_type_t;

typedef union pcc_lr_answer_data_tag {
    pcc_lr_entry_t *lr;
    pcc_thunk_chunk_t *chunk;
} pcc_lr_answer_data_t;

typedef struct pcc_lr_answer_tag pcc_lr_answer_t;

struct pcc_lr_answer_tag {
    VALUE robj;
    pcc_lr_answer_type_t type;
    pcc_lr_answer_data_t data;
    size_t pos; /* the absolute position in the input */
};

typedef pcc_thunk_chunk_t *(*pcc_rule_func_t)(VALUE);

typedef struct pcc_rule_tag {
    pcc_rule_func_t func;
    ID name;
} pcc_rule_t;

typedef struct pcc_rule_set_tag {
    VALUE robj;
    pcc_rule_t *buf;
    size_t max;
    size_t len;
} pcc_rule_set_t;

typedef struct pcc_lr_head_tag pcc_lr_head_t;

struct pcc_lr_head_tag {
    VALUE robj;
};

typedef struct pcc_lr_memo_tag {
    pcc_rule_t rule;
    pcc_lr_answer_t *answer;
} pcc_lr_memo_t;

typedef struct pcc_lr_memo_map_tag {
    pcc_lr_memo_t *buf;
    size_t max;
    size_t len;
} pcc_lr_memo_map_t;

struct pcc_lr_entry_tag {
    VALUE robj;
    pcc_rule_t rule;
    pcc_thunk_chunk_t *seed; /* just a reference */
    pcc_lr_head_t *head; /* just a reference */
};

#ifndef PCC_ERROR
#define PCC_ERROR(auxil) pcc_error()
MARK_FUNC_AS_USED
static void pcc_error(void) {
    fprintf(stderr, "Syntax error\n");
    exit(1);
}
#endif /* !PCC_ERROR */

#ifndef PCC_GETCHAR
#define PCC_GETCHAR(auxil) NUM2INT(rb_funcall(rb_mKernel, rb_intern("getb"), 0))
#endif /* !PCC_GETCHAR */

#ifndef PCC_MALLOC
#define PCC_MALLOC(auxil, size) pcc_malloc_e(size)
static void *pcc_malloc_e(size_t size) {
    void *const p = malloc(size);
    if (p == NULL) {
        fprintf(stderr, "Out of memory\n");
        exit(1);
    }
    return p;
}
#endif /* !PCC_MALLOC */

#ifndef PCC_REALLOC
#define PCC_REALLOC(auxil, ptr, size) pcc_realloc_e(ptr, size)
static void *pcc_realloc_e(void *ptr, size_t size) {
    void *const p = realloc(ptr, size);
    if (p == NULL) {
        fprintf(stderr, "Out of memory\n");
        exit(1);
    }
    return p;
}
#endif /* !PCC_REALLOC */

#ifndef PCC_DEBUG
#define PCC_DEBUG(auxil, event, rule, level, pos, buffer, length) ((void)0)
#endif /* !PCC_DEBUG */

static VALUE cLrEntry, cLrTableEntry, cLrHead, cLrAnswer, cThunk, cThunkChunk, cCapture, cValue, cRuleSet;

static void pcc_lr_entry_mark(void *ptr) {
}

static void pcc_lr_entry_free(void *ptr) {
    pcc_lr_entry_t *e = ptr;
    xfree(e);
}

static size_t pcc_lr_entry_memsize(const void *ptr) {
    return sizeof(pcc_lr_entry_t);
}

static const rb_data_type_t pcc_lr_entry_data_type = {
    "pcc_lr_entry",
    {pcc_lr_entry_mark, pcc_lr_entry_free, pcc_lr_entry_memsize,},
    0, 0, RUBY_TYPED_WB_PROTECTED | RUBY_TYPED_FREE_IMMEDIATELY
};

static VALUE pcc_lr_entry_s_alloc(VALUE klass) {
    pcc_lr_entry_t *lr;
    VALUE obj = TypedData_Make_Struct(klass, pcc_lr_entry_t, &pcc_lr_entry_data_type, lr);
    lr->robj = obj;
    lr->seed = NULL;
    lr->head = NULL;

    return obj;
}

static void pcc_lr_head_mark(void *ptr) {
}

static void pcc_lr_head_free(void *ptr) {
}

static size_t pcc_lr_head_memsize(const void *ptr) {
    return sizeof(pcc_lr_head_t);
}

static const rb_data_type_t pcc_lr_head_data_type = {
    "pcc_lr_head",
    {pcc_lr_head_mark, pcc_lr_head_free, pcc_lr_head_memsize,},
    0, 0, RUBY_TYPED_WB_PROTECTED | RUBY_TYPED_FREE_IMMEDIATELY
};

static void pcc_thunk_mark(void *ptr) {
}

static void pcc_thunk_free(void *ptr) {
}

static size_t pcc_thunk_memsize(const void *ptr) {
    return sizeof(pcc_thunk_t);
}

static const rb_data_type_t pcc_thunk_data_type = {
    "pcc_thunk",
    {pcc_thunk_mark, pcc_thunk_free, pcc_thunk_memsize,},
    0, 0, RUBY_TYPED_WB_PROTECTED | RUBY_TYPED_FREE_IMMEDIATELY
};

static VALUE pcc_thunk_s_alloc(VALUE klass) {
    pcc_thunk_t *thunk;
    VALUE obj = TypedData_Make_Struct(klass, pcc_thunk_t, &pcc_thunk_data_type, thunk);

    return obj;
}

static void pcc_thunk_chunk_mark(void *ptr) {
}

static void pcc_thunk_chunk_free(void *ptr) {
}

static size_t pcc_thunk_chunk_memsize(const void *ptr) {
    return sizeof(pcc_thunk_chunk_t);
}

static const rb_data_type_t pcc_thunk_chunk_data_type = {
    "pcc_thunk_chunk",
    {pcc_thunk_chunk_mark, pcc_thunk_chunk_free, pcc_thunk_chunk_memsize,},
    0, 0, RUBY_TYPED_WB_PROTECTED | RUBY_TYPED_FREE_IMMEDIATELY
};

static void pcc_capture_mark(void *ptr) {
}

static void pcc_capture_free(void *ptr) {
}

static size_t pcc_capture_memsize(const void *ptr) {
    return sizeof(pcc_capture_t);
}

static const rb_data_type_t pcc_capture_data_type = {
    "pcc_capture",
    {pcc_capture_mark, pcc_capture_free, pcc_capture_memsize,},
    0, 0, RUBY_TYPED_WB_PROTECTED | RUBY_TYPED_FREE_IMMEDIATELY
};

static VALUE pcc_capture_s_alloc(VALUE klass) {
    pcc_capture_t *capt;
    VALUE obj = TypedData_Make_Struct(klass, pcc_capture_t, &pcc_capture_data_type, capt);
    capt->range.start = 0;
    capt->range.end = 0;
<%- if @location -%>
    rb_ivar_set(obj, rb_intern("@start_loc"), rb_funcall(cLocation, rb_intern("new"), 0));
    rb_ivar_set(obj, rb_intern("@end_loc"), rb_funcall(cLocation, rb_intern("new"), 0));
<%- end -%>
    capt->string = NULL;

    return obj;
}

static void pcc_value_mark(void *ptr) {
}

static void pcc_value_free(void *ptr) {
}

static size_t pcc_value_memsize(const void *ptr) {
    return sizeof(pcc_value_t);
}

static const rb_data_type_t pcc_value_data_type = {
    "pcc_value",
    {pcc_value_mark, pcc_value_free, pcc_value_memsize,},
    0, 0, RUBY_TYPED_WB_PROTECTED | RUBY_TYPED_FREE_IMMEDIATELY
};

static VALUE pcc_value_s_alloc(VALUE klass) {
    pcc_value_t *value;
    VALUE obj = TypedData_Make_Struct(klass, pcc_value_t, &pcc_value_data_type, value);

    return obj;
}

static void pcc_lr_answer_mark(void *ptr) {
}

static void pcc_lr_answer_free(void *ptr) {
}

static size_t pcc_lr_answer_memsize(const void *ptr) {
    return sizeof(pcc_lr_answer_t);
}

static const rb_data_type_t pcc_lr_answer_data_type = {
    "pcc_lr_answer",
    {pcc_lr_answer_mark, pcc_lr_answer_free, pcc_lr_answer_memsize,},
    0, 0, RUBY_TYPED_WB_PROTECTED | RUBY_TYPED_FREE_IMMEDIATELY
};

static void pcc_rule_set_mark(void *ptr) {
}

static void pcc_rule_set_free(void *ptr) {
}

static size_t pcc_rule_set_memsize(const void *ptr) {
    return sizeof(pcc_rule_set_t);
}

static const rb_data_type_t pcc_rule_set_data_type = {
    "pcc_rule_set",
    {pcc_rule_set_mark, pcc_rule_set_free, pcc_rule_set_memsize,},
    0, 0, RUBY_TYPED_WB_PROTECTED | RUBY_TYPED_FREE_IMMEDIATELY
};

static VALUE pcc_rule_set_s_alloc(VALUE klass) {
    pcc_rule_set_t *set;
    VALUE obj = TypedData_Make_Struct(klass, pcc_rule_set_t, &pcc_rule_set_data_type, set);
    set->robj = obj;
    set->len = 0;
    set->max = 0;
    set->buf = NULL;

    return obj;
}

static char *pcc_strndup_e(pcc_auxil_t auxil, const char *str, size_t len) {
    const size_t m = strnlen(str, len);
    char *const s = (char *)PCC_MALLOC(auxil, m + 1);
    memcpy(s, str, m);
    s[m] = '\0';
    return s;
}

static void pcc_value_table__init(pcc_auxil_t auxil, pcc_value_table_t *table) {
    table->len = 0;
    table->max = 0;
    table->buf = NULL;
}

MARK_FUNC_AS_USED
static void pcc_value_table__resize(pcc_auxil_t auxil, pcc_value_table_t *table, size_t len) {
    if (table->max < len) {
        size_t m = table->max;
        if (m == 0) m = PCC_ARRAY_MIN_SIZE;
        while (m < len && m != 0) m <<= 1;
        if (m == 0) m = len;
        table->buf = (pcc_value_t *)PCC_REALLOC(auxil, table->buf, sizeof(pcc_value_t) * m);
        table->max = m;
    }
    table->len = len;
}

MARK_FUNC_AS_USED
static void pcc_value_table__clear(pcc_auxil_t auxil, pcc_value_table_t *table) {
    memset(table->buf, 0, sizeof(pcc_value_t) * table->len);
}

static void pcc_value_refer_table__init(pcc_auxil_t auxil, pcc_value_refer_table_t *table) {
    table->len = 0;
    table->max = 0;
    table->buf = NULL;
}

static void pcc_value_refer_table__resize(pcc_auxil_t auxil, pcc_value_refer_table_t *table, size_t len) {
    size_t i;
    if (table->max < len) {
        size_t m = table->max;
        if (m == 0) m = PCC_ARRAY_MIN_SIZE;
        while (m < len && m != 0) m <<= 1;
        if (m == 0) m = len;
        table->buf = (pcc_value_t **)PCC_REALLOC(auxil, table->buf, sizeof(pcc_value_t *) * m);
        table->max = m;
    }
    for (i = table->len; i < len; i++) table->buf[i] = NULL;
    table->len = len;
}

MARK_FUNC_AS_USED
static void pcc_capture_table__resize(pcc_auxil_t auxil, VALUE rtable, size_t len) {
    size_t i;
    for (i = RARRAY_LEN(rtable); i < len; i++) {
        VALUE rcapt = rb_funcall(cCapture, rb_intern("new"), 0);
        rb_funcall(rtable, rb_intern("<<"), 1, rcapt);
    }
}

MARK_FUNC_AS_USED
static pcc_thunk_t *pcc_thunk__create_leaf(pcc_auxil_t auxil, pcc_action_t action, size_t valuec, size_t captc) {
    pcc_thunk_t *thunk;
    VALUE obj = TypedData_Make_Struct(cThunk, pcc_thunk_t, &pcc_thunk_data_type, thunk);
    thunk->robj = obj;
    thunk->type = PCC_THUNK_LEAF;
    pcc_value_refer_table__init(auxil, &thunk->data.leaf.value_refs);
    pcc_value_refer_table__resize(auxil, &thunk->data.leaf.value_refs, valuec);
    rb_ivar_set(obj, rb_intern("@capts"), rb_ary_new());
    rb_ivar_set(obj, rb_intern("@capt0"), rb_funcall(cCapture, rb_intern("new"), 0));
    thunk->data.leaf.action = action;
    return thunk;
}

static pcc_thunk_t *pcc_thunk__create_node(pcc_auxil_t auxil, VALUE rthunks, pcc_value_t *values, size_t index) {
    pcc_thunk_t *thunk;
    VALUE obj = TypedData_Make_Struct(cThunk, pcc_thunk_t, &pcc_thunk_data_type, thunk);
    VALUE rvalues;
    thunk->robj = obj;
    thunk->type = PCC_THUNK_NODE;
    rb_ivar_set(obj, rb_intern("@thunks"), rthunks);
    if (values == NULL) {
        rvalues = Qnil;
    } else {
        rvalues = TypedData_Wrap_Struct(cValue, &pcc_value_data_type, values);
    }
    rb_ivar_set(obj, rb_intern("@values"), rvalues);
    thunk->data.node.index = index;
    return thunk;
}

static VALUE pcc_thunk_chunk_s_alloc(VALUE klass) {
    pcc_thunk_chunk_t *chunk;
    VALUE obj = TypedData_Make_Struct(klass, pcc_thunk_chunk_t, &pcc_thunk_chunk_data_type, chunk);
    chunk->robj = obj;
    pcc_value_table__init(NULL, &chunk->values);

    return obj;
}

static size_t pcc_rule_set__index(pcc_auxil_t auxil, VALUE rset, ID rule_name) {
    pcc_rule_set_t *set;
    TypedData_Get_Struct(rset, pcc_rule_set_t, &pcc_rule_set_data_type, set);
    size_t i;
    for (i = 0; i < set->len; i++) {
        if (set->buf[i].name == rule_name) return i;
    }
    return PCC_VOID_VALUE;
}

static VALUE pcc_rule_set__add(pcc_auxil_t auxil, VALUE rset, pcc_rule_t rule) {
    pcc_rule_set_t *set;
    TypedData_Get_Struct(rset, pcc_rule_set_t, &pcc_rule_set_data_type, set);
    const size_t i = pcc_rule_set__index(auxil, rset, rule.name);
    if (i != PCC_VOID_VALUE) return Qfalse;
    if (set->max <= set->len) {
        const size_t n = set->len + 1;
        size_t m = set->max;
        if (m == 0) m = PCC_ARRAY_MIN_SIZE;
        while (m < n && m != 0) m <<= 1;
        if (m == 0) m = n;
        set->buf = (pcc_rule_t *)PCC_REALLOC(auxil, set->buf, sizeof(pcc_rule_t) * m);
        set->max = m;
    }
    set->buf[set->len++] = rule;
    return Qtrue;
}

static VALUE pcc_rule_set__remove(pcc_auxil_t auxil, VALUE rset, ID rule_name) {
    pcc_rule_set_t *set;
    TypedData_Get_Struct(rset, pcc_rule_set_t, &pcc_rule_set_data_type, set);
    const size_t i = pcc_rule_set__index(auxil, rset, rule_name);
    if (i == PCC_VOID_VALUE) return Qfalse;
    memmove(set->buf + i, set->buf + (i + 1), sizeof(pcc_rule_t) * (set->len - (i + 1)));
    return Qtrue;
}

static void pcc_rule_set__clear(pcc_auxil_t auxil, VALUE rset) {
    pcc_rule_set_t *set;
    TypedData_Get_Struct(rset, pcc_rule_set_t, &pcc_rule_set_data_type, set);
    set->len = 0;
}

static void pcc_rule_set__copy(pcc_auxil_t auxil, VALUE rset, VALUE rsrc) {
    size_t i;
    pcc_rule_set_t *src;
    TypedData_Get_Struct(rsrc, pcc_rule_set_t, &pcc_rule_set_data_type, src);
    pcc_rule_set__clear(auxil, rset);
    for (i = 0; i < src->len; i++) {
        pcc_rule_set__add(auxil, rset, src->buf[i]);
    }
}

static VALUE pcc_lr_head_s_alloc(VALUE klass) {
    pcc_lr_head_t *head;
    VALUE obj = TypedData_Make_Struct(klass, pcc_lr_head_t, &pcc_lr_head_data_type, head);
    VALUE rinvol, reval;
    head->robj = obj;
    rinvol = rb_funcall(cRuleSet, rb_intern("new"), 0);
    rb_ivar_set(obj, rb_intern("@invol"), rinvol);
    reval = rb_funcall(cRuleSet, rb_intern("new"), 0);
    rb_ivar_set(obj, rb_intern("@eval"), reval);

    return obj;
}

static VALUE pcc_lr_answer_s_alloc(VALUE klass) {
    pcc_lr_answer_t *answer;
    VALUE obj = TypedData_Make_Struct(klass, pcc_lr_answer_t, &pcc_lr_answer_data_type, answer);
    answer->robj = obj;

    return obj;
}

static VALUE pcc_lr_answer_initialize(VALUE self, VALUE rtype, VALUE rpos<% if @location %>, VALUE pos_loc<% end %>) {
    size_t pos = NUM2SIZET(rpos);
    pcc_lr_answer_t *answer;
    ID itype = SYM2ID(rtype);
    TypedData_Get_Struct(self, pcc_lr_answer_t, &pcc_lr_answer_data_type, answer);
    if (itype == rb_intern("lr")) {
        answer->type = PCC_LR_ANSWER_LR;
    } else if (itype == rb_intern("chunk")) {
        answer->type = PCC_LR_ANSWER_CHUNK;
    } else {
        rb_raise(rb_eRuntimeError, "invalid type for LrAnswer");
    }
    answer->pos = pos;
<%- if @location -%>
    rb_ivar_set(answer->robj, rb_intern("@pos_loc"), pos_loc);
<%- end -%>
    switch (answer->type) {
    case PCC_LR_ANSWER_LR:
        answer->data.lr = NULL;
        break;
    case PCC_LR_ANSWER_CHUNK:
        answer->data.chunk = NULL;
        break;
    default: /* unknown */
        answer = NULL;
    }
    return answer->robj;
}

static void pcc_lr_answer__set_chunk(VALUE rctx, pcc_lr_answer_t *answer, pcc_thunk_chunk_t *chunk) {
    pcc_lr_answer_t *a;
    VALUE rtype;
    switch (answer->type) {
    case PCC_LR_ANSWER_LR:
        rtype = ID2SYM(rb_intern("lr"));
        break;
    case PCC_LR_ANSWER_CHUNK:
        rtype = ID2SYM(rb_intern("chunk"));
        break;
    default:
        rb_raise(rb_eRuntimeError, "invalid type for set_chunk");
        rtype = Qnil;
    }
    {
        VALUE ranswer = rb_funcall(cLrAnswer, rb_intern("new"), <% if @location %>3<% else %>2<% end %>, rtype, SIZET2NUM(answer->pos)<% if @location %>, rb_ivar_get(answer->robj, rb_intern("@pos_loc"))<% end %>);
        TypedData_Get_Struct(ranswer, pcc_lr_answer_t, &pcc_lr_answer_data_type, a);
    }
    switch (answer->type) {
    case PCC_LR_ANSWER_LR:
        a->data.lr = answer->data.lr;
        break;
    case PCC_LR_ANSWER_CHUNK:
        a->data.chunk = answer->data.chunk;
        break;
    default: /* unknown */
        break;
    }
    rb_ivar_set(a->robj, rb_intern("@hold"), rb_ivar_get(answer->robj, rb_intern("@hold")));
    rb_ivar_set(answer->robj, rb_intern("@hold"), a->robj);
    answer->type = PCC_LR_ANSWER_CHUNK;
    answer->data.chunk = chunk;
}

static size_t pcc_refill_buffer(VALUE rctx, size_t num) {
    return NUM2SIZET(rb_funcall(rctx, rb_intern("refill_buffer"), 1, SIZET2NUM(num)));
}

MARK_FUNC_AS_USED
static void pcc_commit_buffer(VALUE rctx) {
    rb_funcall(rctx, rb_intern("commit_buffer"), 0);
}

MARK_FUNC_AS_USED
static const char *pcc_get_capture_string(VALUE rctx, VALUE rcapt) {
    pcc_capture_t *capt;
    TypedData_Get_Struct(rcapt, pcc_capture_t, &pcc_capture_data_type, capt);
    if (capt->string == NULL)
        ((pcc_capture_t *)capt)->string =
            pcc_strndup_e(NULL, RSTRING_PTR(rb_ivar_get(rctx, rb_intern("@buffer"))) + capt->range.start, capt->range.end - capt->range.start);
    return capt->string;
}

<% if @utf8 -%>
static size_t pcc_get_char_as_utf32(VALUE rctx, int *out) { /* with checking UTF-8 validity */
    int c, u;
    size_t n;
    if (pcc_refill_buffer(rctx, 1) < 1) return 0;
    c = (int)(unsigned char)RSTRING_PTR(rb_ivar_get(rctx, rb_intern("@buffer")))[NUM2SIZET(rb_ivar_get(rctx, rb_intern("@cur")))];
    n = (c < 0x80) ? 1 :
        ((c & 0xe0) == 0xc0) ? 2 :
        ((c & 0xf0) == 0xe0) ? 3 :
        ((c & 0xf8) == 0xf0) ? 4 : 0;
    if (n < 1) return 0;
    if (pcc_refill_buffer(rctx, n) < n) return 0;
    switch (n) {
    case 1:
        u = c;
        break;
    case 2:
        u = c & 0x1f;
        c = (int)(unsigned char)RSTRING_PTR(rb_ivar_get(rctx, rb_intern("@buffer")))[NUM2SIZET(rb_ivar_get(rctx, rb_intern("@cur"))) + 1];
        if ((c & 0xc0) != 0x80) return 0;
        u <<= 6; u |= c & 0x3f;
        if (u < 0x80) return 0;
        break;
    case 3:
        u = c & 0x0f;
        c = (int)(unsigned char)RSTRING_PTR(rb_ivar_get(rctx, rb_intern("@buffer")))[NUM2SIZET(rb_ivar_get(rctx, rb_intern("@cur"))) + 1];
        if ((c & 0xc0) != 0x80) return 0;
        u <<= 6; u |= c & 0x3f;
        c = (int)(unsigned char)RSTRING_PTR(rb_ivar_get(rctx, rb_intern("@buffer")))[NUM2SIZET(rb_ivar_get(rctx, rb_intern("@cur"))) + 2];
        if ((c & 0xc0) != 0x80) return 0;
        u <<= 6; u |= c & 0x3f;
        if (u < 0x800) return 0;
        break;
    case 4:
        u = c & 0x07;
        c = (int)(unsigned char)RSTRING_PTR(rb_ivar_get(rctx, rb_intern("@buffer")))[NUM2SIZET(rb_ivar_get(rctx, rb_intern("@cur"))) + 1];
        if ((c & 0xc0) != 0x80) return 0;
        u <<= 6; u |= c & 0x3f;
        c = (int)(unsigned char)RSTRING_PTR(rb_ivar_get(rctx, rb_intern("@buffer")))[NUM2SIZET(rb_ivar_get(rctx, rb_intern("@cur"))) + 2];
        if ((c & 0xc0) != 0x80) return 0;
        u <<= 6; u |= c & 0x3f;
        c = (int)(unsigned char)RSTRING_PTR(rb_ivar_get(rctx, rb_intern("@buffer")))[NUM2SIZET(rb_ivar_get(rctx, rb_intern("@cur"))) + 3];
        if ((c & 0xc0) != 0x80) return 0;
        u <<= 6; u |= c & 0x3f;
        if (u < 0x10000 || u > 0x10ffff) return 0;
        break;
    default:
        return 0;
    }
    if (out) *out = u;
    return n;
}

<% end -%>
MARK_FUNC_AS_USED
static VALUE pcc_apply_rule(VALUE rctx, pcc_rule_t rule, VALUE rthunks, pcc_value_t *values, size_t index) {
    pcc_thunk_chunk_t *c = NULL;
    const size_t p = NUM2SIZET(rb_ivar_get(rctx, rb_intern("@pos"))) + NUM2SIZET(rb_ivar_get(rctx, rb_intern("@cur")));
<%- if @location -%>
    const VALUE p_loc = rb_funcall(rb_ivar_get(rctx, rb_intern("@pos_loc")), rb_intern("+"), 1, rb_ivar_get(rctx, rb_intern("@cur_loc")));
<%- end -%>
    VALUE b = Qtrue;
    VALUE rh, ra, rlrtable = rb_ivar_get(rctx, rb_intern("@lrtable"));
    pcc_lr_answer_t *a;
    pcc_lr_head_t *h = NULL;
    ra = rb_funcall(rlrtable, rb_intern("get_answer"), 2, SIZET2NUM(p), ID2SYM(rule.name));
    if (NIL_P(ra)) {
        a = NULL;
    } else {
        TypedData_Get_Struct(ra, pcc_lr_answer_t, &pcc_lr_answer_data_type, a);
    }
    rh = rb_funcall(rlrtable, rb_intern("get_head"), 1, SIZET2NUM(p));
    if (NIL_P(rh)) {
        h = NULL;
    } else {
        TypedData_Get_Struct(rh, pcc_lr_head_t, &pcc_lr_head_data_type, h);
    }
    if (h != NULL) {
        VALUE rinvol = rb_ivar_get(h->robj, rb_intern("@invol"));
        ID rule_name = SYM2ID(rb_ivar_get(h->robj, rb_intern("@rule_name")));
        if (a == NULL && rule.name != rule_name && pcc_rule_set__index(NULL, rinvol, rule.name) == PCC_VOID_VALUE) {
            b = Qfalse;
            c = NULL;
        } else {
            VALUE reval = rb_ivar_get(h->robj, rb_intern("@eval"));
            if (RTEST(pcc_rule_set__remove(NULL, reval, rule.name))) {
                b = Qfalse;
                c = rule.func(rctx);
                {
                    VALUE ranswer = rb_funcall(cLrAnswer, rb_intern("new"), <% if @location %>3<% else %>2<% end %>, ID2SYM(rb_intern("chunk")), SIZET2NUM(NUM2SIZET(rb_ivar_get(rctx, rb_intern("@pos"))) + NUM2SIZET(rb_ivar_get(rctx, rb_intern("@cur"))))<% if @location %>, rb_funcall(rb_ivar_get(rctx, rb_intern("@pos_loc")), rb_intern("+"), 1, rb_ivar_get(rctx, rb_intern("@cur_loc")))<% end %>);
                    TypedData_Get_Struct(ranswer, pcc_lr_answer_t, &pcc_lr_answer_data_type, a);
                }
                a->data.chunk = c;
                rb_funcall(rlrtable, rb_intern("hold_answer"), 2, SIZET2NUM(p), a->robj);
            }
        }
    }
    if (RTEST(b)) {
        if (a != NULL) {
            rb_ivar_set(rctx, rb_intern("@cur"), SIZET2NUM(a->pos - NUM2SIZET(rb_ivar_get(rctx, rb_intern("@pos")))));
<%- if @location -%>
            rb_ivar_set(rctx, rb_intern("@cur_loc"), rb_funcall(rb_ivar_get(a->robj, rb_intern("@pos_loc")), rb_intern("-"), 1, rb_ivar_get(rctx, rb_intern("@pos_loc"))));
<%- end -%>
            switch (a->type) {
            case PCC_LR_ANSWER_LR:
                if (a->data.lr->head == NULL) {
                    VALUE rhead = rb_funcall(cLrHead, rb_intern("new"), 0);
                    TypedData_Get_Struct(rhead, pcc_lr_head_t, &pcc_lr_head_data_type, a->data.lr->head);
                    rb_ivar_set(a->data.lr->head->robj, rb_intern("@rule_name"), ID2SYM(rule.name));
                    rb_funcall(rlrtable, rb_intern("hold_head"), 2, SIZET2NUM(p), a->data.lr->head->robj);
                }
                {
                    size_t i = RARRAY_LEN(rb_ivar_get(rctx, rb_intern("@lrstack")));
                    while (i > 0) {
                        VALUE rinvol;
                        i--;
                        VALUE rlrentry = rb_funcall(rb_ivar_get(rctx, rb_intern("@lrstack")), rb_intern("[]"), 1, SIZET2NUM(i));
                        pcc_lr_entry_t *lrentry;
                        TypedData_Get_Struct(rlrentry, pcc_lr_entry_t, &pcc_lr_entry_data_type, lrentry);
                        if (lrentry->head == a->data.lr->head) break;
                        lrentry->head = a->data.lr->head;
                        rinvol = rb_ivar_get(a->data.lr->head->robj, rb_intern("@invol"));
                        pcc_rule_set__add(NULL, rinvol, lrentry->rule);
                    }
                }
                c = a->data.lr->seed;
                break;
            case PCC_LR_ANSWER_CHUNK:
                c = a->data.chunk;
                break;
            default: /* unknown */
                break;
            }
        }
        else {
            VALUE rentry = rb_funcall(cLrEntry, rb_intern("new"), 0);
            pcc_lr_entry_t *e;
            TypedData_Get_Struct(rentry, pcc_lr_entry_t, &pcc_lr_entry_data_type, e);
            e->rule = rule;
            rb_funcall(rb_ivar_get(rctx, rb_intern("@lrstack")), rb_intern("push"), 1, rentry);
            {
                VALUE ranswer = rb_funcall(cLrAnswer, rb_intern("new"), <% if @location %>3<% else %>2<% end %>, ID2SYM(rb_intern("lr")), SIZET2NUM(p)<% if @location %>, p_loc<% end %>);
                TypedData_Get_Struct(ranswer, pcc_lr_answer_t, &pcc_lr_answer_data_type, a);
            }
            a->data.lr = e;
            rb_funcall(rlrtable, rb_intern("set_answer"), 3, SIZET2NUM(p), ID2SYM(rule.name), a->robj);
            c = rule.func(rctx);
            rb_funcall(rb_ivar_get(rctx, rb_intern("@lrstack")), rb_intern("pop"), 0);
            a->pos = NUM2SIZET(rb_ivar_get(rctx, rb_intern("@pos"))) + NUM2SIZET(rb_ivar_get(rctx, rb_intern("@cur")));
<%- if @location -%>
            rb_ivar_set(a->robj, rb_intern("@pos_loc"), rb_funcall(rb_ivar_get(rctx, rb_intern("@pos_loc")), rb_intern("+"), 1, rb_ivar_get(rctx, rb_intern("@cur_loc"))));
<%- end -%>
            if (e->head == NULL) {
                pcc_lr_answer__set_chunk(rctx, a, c);
            }
            else {
                ID rule_name;
                e->seed = c;
                h = a->data.lr->head;
                rule_name = SYM2ID(rb_ivar_get(h->robj, rb_intern("@rule_name")));
                if (rule_name != rule.name) {
                    c = a->data.lr->seed;
                    {
                        VALUE ranswer = rb_funcall(cLrAnswer, rb_intern("new"), <% if @location %>3<% else %>2<% end %>, ID2SYM(rb_intern("chunk")), SIZET2NUM(NUM2SIZET(rb_ivar_get(rctx, rb_intern("@pos"))) + NUM2SIZET(rb_ivar_get(rctx, rb_intern("@cur"))))<% if @location %>, rb_funcall(rb_ivar_get(rctx, rb_intern("@pos_loc")), rb_intern("+"), 1, rb_ivar_get(rctx, rb_intern("@cur_loc")))<% end %>);
                        TypedData_Get_Struct(ranswer, pcc_lr_answer_t, &pcc_lr_answer_data_type, a);
                    }
                    a->data.chunk = c;
                    rb_funcall(rlrtable, rb_intern("hold_answer"), 2, SIZET2NUM(p), a->robj);
                }
                else {
                    pcc_lr_answer__set_chunk(rctx, a, a->data.lr->seed);
                    if (a->data.chunk == NULL) {
                        c = NULL;
                    }
                    else {
                        rb_funcall(rlrtable, rb_intern("set_head"), 2, SIZET2NUM(p), h->robj);
                        for (;;) {
                            VALUE rinvol, reval;
                            rb_ivar_set(rctx, rb_intern("@cur"), SIZET2NUM(p - NUM2SIZET(rb_ivar_get(rctx, rb_intern("@pos")))));
<%- if @location -%>
                            rb_ivar_set(rctx, rb_intern("@cur_loc"), rb_funcall(p_loc, rb_intern("-"), 1, rb_ivar_get(rctx, rb_intern("@pos_loc"))));
<%- end -%>
                            rinvol = rb_ivar_get(h->robj, rb_intern("@invol"));
                            reval = rb_ivar_get(h->robj, rb_intern("@eval"));
                            pcc_rule_set__copy(NULL, reval, rinvol);
                            c = rule.func(rctx);
                            if (c == NULL || NUM2SIZET(rb_ivar_get(rctx, rb_intern("@pos"))) + NUM2SIZET(rb_ivar_get(rctx, rb_intern("@cur"))) <= a->pos) break;
                            pcc_lr_answer__set_chunk(rctx, a, c);
                            a->pos = NUM2SIZET(rb_ivar_get(rctx, rb_intern("@pos"))) + NUM2SIZET(rb_ivar_get(rctx, rb_intern("@cur")));
<%- if @location -%>
                            a->pos_loc = pcc_location_add(rb_ivar_get(rctx, rb_intern("@pos_loc")), ctx->cur_loc);
<%- end -%>
                        }
                        rb_funcall(rlrtable, rb_intern("set_head"), 2, SIZET2NUM(p), Qnil);
                        rb_ivar_set(rctx, rb_intern("@cur"), SIZET2NUM(a->pos - NUM2SIZET(rb_ivar_get(rctx, rb_intern("@pos")))));
<%- if @location -%>
                        rb_ivar_set(rctx, rb_intern("@cur_loc"), rb_funcall(rb_ivar_get(a->robj, rb_intern("@pos_loc")), rb_intern("-"), 1, rb_ivar_get(rctx, rb_intern("@pos_loc"))));
<%- end -%>
                        c = a->data.chunk;
                    }
                }
            }
        }
    }
    if (c == NULL) return Qfalse;
    if (values != NULL) {
        memset(values + index, 0, sizeof(pcc_value_t)); /* in case */
    }
    {
        pcc_thunk_t *t = pcc_thunk__create_node(NULL, rb_ivar_get(c->robj, rb_intern("@thunks")), values, index);
        rb_funcall(rthunks, rb_intern("push"), 1, t->robj);
    }
    return Qtrue;
}

MARK_FUNC_AS_USED
static void pcc_do_action(VALUE rctx, VALUE rthunks, pcc_value_t *values, size_t index) {
    size_t i;
    for (i = 0; i < (size_t)RARRAY_LEN(rthunks); i++) {
        pcc_thunk_t *thunk;
        VALUE rthunk = rb_funcall(rthunks, rb_intern("[]"), 1, SIZET2NUM(i));
        TypedData_Get_Struct(rthunk, pcc_thunk_t, &pcc_thunk_data_type, thunk);
        switch (thunk->type) {
        case PCC_THUNK_LEAF:
            thunk->data.leaf.action(rctx, thunk, values, index);
            break;
        case PCC_THUNK_NODE:
            {
                VALUE rnode_values = rb_ivar_get(thunk->robj, rb_intern("@values"));
                pcc_value_t *node_values;
                if (NIL_P(rnode_values)) {
                    node_values = NULL;
                } else {
                    TypedData_Get_Struct(rnode_values, pcc_value_t, &pcc_value_data_type, node_values);
                }
                pcc_do_action(rctx, rb_ivar_get(thunk->robj, rb_intern("@thunks")), node_values, thunk->data.node.index);
            }
            break;
        default: /* unknown */
            break;
        }
    }
}

static inline pcc_capture_t *pcc_thunk_leaf__get_capt0(VALUE rthunk) {
    VALUE rcapt0 = rb_ivar_get(rthunk, rb_intern("@capt0"));
    pcc_capture_t *capt0;
    TypedData_Get_Struct(rcapt0, pcc_capture_t, &pcc_capture_data_type, capt0);
    return capt0;
}

<%- @rules.each do |rule| -%>
<%-   rule.codes.each do |code| -%>
static void pcc_action_<%= rule.name %>_<%= code.index %>(VALUE __pcc_ctx, pcc_thunk_t *__pcc_in, pcc_value_t *__pcc_vars, size_t __pcc_index) {
#define __ __pcc_vars[__pcc_index].value
<%-     code.vars.each do |ref| -%>
#define <%= ref.var %> (__pcc_in->data.leaf.value_refs.buf[<%= ref.index %>]->value)
<%-     end -%>
#define _0 pcc_get_capture_string(__pcc_ctx, rb_ivar_get(__pcc_in->robj, rb_intern("@capt0")))
#define _0s ((const size_t)(__pcc_NUM2SIZET(rb_ivar_get(rctx, rb_intern("@pos"))) + pcc_thunk_leaf__get_capt0(__pcc_in->robj)->range.start))
#define _0e ((const size_t)(__pcc_NUM2SIZET(rb_ivar_get(rctx, rb_intern("@pos"))) + pcc_thunk_leaf__get_capt0(__pcc_in->robj)->range.end))
<%-     code.capts.each do |capture| -%>
#define _<%= capture.index + 1 %> pcc_get_capture_string(__pcc_ctx, rb_funcall(rb_ivar_get(__pcc_in->robj, rb_intern("@capts")), rb_intern("[]"), 1, SIZET2NUM(<%= capture.index %>)))
#define _<%= capture.index + 1 %>s ((const size_t)(__pcc_NUM2SIZET(rb_ivar_get(rctx, rb_intern("@pos"))) + __pcc_in->data.leaf.capts.buf[<%= capture.index %>]->range.start))
#define _<%= capture.index + 1 %>e ((const size_t)(__pcc_NUM2SIZET(rb_ivar_get(rctx, rb_intern("@pos"))) + __pcc_in->data.leaf.capts.buf[<%= capture.index %>]->range.end))
<%-       if @location -%>
#define _<%= capture.index + 1 %>sl ((const VALUE)(rb_funcall(rb_ivar_get(__pcc_ctx, rb_intern("@pos_loc")), rb_intern("+"), 1, rb_ivar_get(__pcc_in->data.leaf.capts.buf[<%= capture.index %>]->robj, rb_intern("@start_loc")))))
#define _<%= capture.index + 1 %>el ((const VALUE)(rb_funcall(rb_ivar_get(__pcc_ctx, rb_intern("@pos_loc")), rb_intern("+"), 1, rb_ivar_get(__pcc_in->data.leaf.capts.buf[<%= capture.index %>]->robj, rb_intern("@end_loc")))))
<%-       end -%>
<%-     end -%>
<%=     hstream.get_code_block(code.code, 4, @iname) -%>
<%-     code.capts.reverse_each do |capture| -%>
<%-       if @location -%>
#undef _<%= capture.index + 1 %>el
#undef _<%= capture.index + 1 %>sl
<%-       end -%>
#undef _<%= capture.index + 1 %>e
#undef _<%= capture.index + 1 %>s
#undef _<%= capture.index + 1 %>
<%-     end -%>
#undef _0e
#undef _0s
#undef _0
<%- code.vars.reverse_each do |ref| -%>
#undef <%= ref.var %>
<%-     end -%>
#undef __
#undef auxil
}

<%-   end -%>
<%- end -%>
<%- @rules.each do |node| -%>
static pcc_thunk_chunk_t *pcc_evaluate_rule_<%= node.name %>(VALUE rctx);
<%- end -%>

<%- @rules.each do |node| -%>
static pcc_thunk_chunk_t *pcc_evaluate_rule_<%= node.name %>(VALUE rctx) {
    VALUE rchunk = rb_funcall(cThunkChunk, rb_intern("new"), 0);
    pcc_thunk_chunk_t *chunk;
    TypedData_Get_Struct(rchunk, pcc_thunk_chunk_t, &pcc_thunk_chunk_data_type, chunk);
    rb_ivar_set(chunk->robj, rb_intern("@pos"), rb_ivar_get(rctx, rb_intern("@cur")));
<%- if @location -%>
    rb_ivar_set(chunk->robj, rb_intern("@pos_loc"), rb_ivar_get(rctx, rb_intern("@cur_loc")));
<%- end -%>
    //PCC_DEBUG(NULL, PCC_DBG_EVALUATE, "<%= node.name %>", NUM2SIZET(rb_ivar_get(rctx, rb_intern("@level"))), NUM2SIZET(rb_ivar_get(chunk->robj, rb_intern("@pos"))), (RSTRING_PTR(rb_ivar_get(rctx, rb_intern("@buffer"))) + NUM2SIZET(rb_ivar_get(chunk->robj, rb_intern("@pos")))), (RSTRING_LEN(rb_ivar_get(rctx, rb_intern("@buffer"))) - NUM2SIZET(rb_ivar_get(chunk->robj, rb_intern("@pos")))));
    rb_ivar_set(rctx, rb_intern("@level"), SIZET2NUM(NUM2SIZET(rb_ivar_get(rctx, rb_intern("@level"))) + 1));
    pcc_value_table__resize(NULL, &chunk->values, <%= node.vars.length %>);
    pcc_capture_table__resize(NULL, rb_ivar_get(chunk->robj, rb_intern("@capts")), <%= node.capts.length %>);
<%-   if node.vars.length > 0 -%>
    pcc_value_table__clear(NULL, &chunk->values);
<%-   end -%>
<%-   g = ::Packcr::Generator.new(node, @ascii, @location, :rb) -%>
<%-   r, str = g.generate_code_str(node.expr, 0, 4, false) -%>
<%=   str -%>
    rb_ivar_set(rctx, rb_intern("@level"), SIZET2NUM(NUM2SIZET(rb_ivar_get(rctx, rb_intern("@level"))) - 1));
    //PCC_DEBUG(NULL, PCC_DBG_MATCH, "<%= node.name %>", NUM2SIZET(rb_ivar_get(rctx, rb_intern("@level"))), NUM2SIZET(rb_ivar_get(chunk->robj, rb_intern("@pos")))$1 (RSTRING_PTR(rb_ivar_get(rctx, rb_intern("@buffer"))) + NUM2SIZET(rb_ivar_get(chunk->robj, rb_intern("@pos")))$1, (NUM2SIZET(rb_ivar_get(rctx, rb_intern("@cur"))) - NUM2SIZET(rb_ivar_get(chunk->robj, rb_intern("@pos")))$1);
    return chunk;
<%-   if r != Packcr::CODE_REACH__ALWAYS_SUCCEED -%>
L0000:;
    rb_ivar_set(rctx, rb_intern("@level"), SIZET2NUM(NUM2SIZET(rb_ivar_get(rctx, rb_intern("@level"))) - 1));
    //PCC_DEBUG(NULL, PCC_DBG_NOMATCH, "<%= node.name %>", NUM2SIZET(rb_ivar_get(rctx, rb_intern("@level"))), NUM2SIZET(rb_ivar_get(chunk->robj, rb_intern("@pos")))$1 (RSTRING_PTR(rb_ivar_get(rctx, rb_intern("@buffer"))) + NUM2SIZET(rb_ivar_get(chunk->robj, rb_intern("@pos")))$1, (NUM2SIZET(rb_ivar_get(rctx, rb_intern("@cur"))) - NUM2SIZET(rb_ivar_get(chunk->robj, rb_intern("@pos")))$1);
    return NULL;
<%-   end -%>
}

<%- end -%>

int <%= prefix %>_parse(VALUE rctx, <%= value_def %>*ret) {
<%- if !@rules.empty? -%>
    VALUE rthunks = rb_ivar_get(rctx, rb_intern("@thunks"));
    pcc_rule_t rule = {pcc_evaluate_rule_<%= @rules[0].name %>, rb_intern("<%= @rules[0].name %>")};
    if (pcc_apply_rule(rctx, rule, rthunks, NULL, 0))
        pcc_do_action(rctx, rthunks, NULL, 0);
    else
        PCC_ERROR(NULL);
    pcc_commit_buffer(rctx);
<%- end -%>
    rb_funcall(rthunks, rb_intern("clear"), 0);
    return pcc_refill_buffer(rctx, 1) >= 1;
}

<%- @lheader.each do |code| -%>
<%=   hstream.get_code_block(code, 0, @iname) -%>
<%- end -%>

static VALUE <%= prefix %>_run(VALUE self) {
    while (<%= prefix %>_parse(self, NULL));
    return Qfalse;
}

void Init_<%= prefix %>(void) {
    VALUE c<%= class_name %> = rb_const_get(rb_cObject, rb_intern("<%= class_name %>"));

    rb_define_method(c<%= class_name %>, "run", <%= prefix %>_run, 0);

    cLrEntry = rb_define_class_under(c<%= class_name %>, "LrEntry", rb_cObject);
    rb_define_alloc_func(cLrEntry, pcc_lr_entry_s_alloc);

    cLrTableEntry = rb_const_get(c<%= class_name %>, rb_intern("LrTableEntry"));

    cLrHead = rb_define_class_under(c<%= class_name %>, "LrHead", rb_cObject);
    rb_define_alloc_func(cLrHead, pcc_lr_head_s_alloc);

    cLrAnswer = rb_define_class_under(c<%= class_name %>, "LrAnswer", rb_cObject);
    rb_define_alloc_func(cLrAnswer, pcc_lr_answer_s_alloc);
    rb_define_method(cLrAnswer, "initialize", pcc_lr_answer_initialize, <% if @location %>3<% else %>2<% end %>);

    cThunk = rb_define_class_under(c<%= class_name %>, "Thunk", rb_cObject);
    rb_define_alloc_func(cThunk, pcc_thunk_s_alloc);

    cThunkChunk = rb_define_class_under(c<%= class_name %>, "ThunkChunk", rb_cObject);
    rb_define_alloc_func(cThunkChunk, pcc_thunk_chunk_s_alloc);

    cCapture = rb_define_class_under(c<%= class_name %>, "Capture", rb_cObject);
    rb_define_alloc_func(cCapture, pcc_capture_s_alloc);

    cValue = rb_define_class_under(c<%= class_name %>, "Value", rb_cObject);
    rb_define_alloc_func(cValue, pcc_value_s_alloc);

    cRuleSet = rb_define_class_under(c<%= class_name %>, "RuleSet", rb_cObject);
    rb_define_alloc_func(cRuleSet, pcc_rule_set_s_alloc);
}
