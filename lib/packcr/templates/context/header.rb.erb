/* A packrat parser generated by PackCR <%= Packcr::VERSION %> */

<%- @esource.each do |code| -%>
<%=   hstream.get_code_block(code, 0, @iname) -%>
<%- end -%>
<%- if !@esource.empty? -%>

<%- end -%>
#ifdef _MSC_VER
#undef _CRT_SECURE_NO_WARNINGS
#define _CRT_SECURE_NO_WARNINGS
#endif /* _MSC_VER */
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#ifndef _MSC_VER
#if defined __GNUC__ && defined _WIN32 /* MinGW */
#ifndef PCC_USE_SYSTEM_STRNLEN
#define strnlen(str, maxlen) pcc_strnlen(str, maxlen)
static size_t pcc_strnlen(const char *str, size_t maxlen) {
    size_t i;
    for (i = 0; i < maxlen && str[i]; i++);
    return i;
}
#endif /* !PCC_USE_SYSTEM_STRNLEN */
#endif /* defined __GNUC__ && defined _WIN32 */
#endif /* !_MSC_VER */

<%- @eheader.each do |code| -%>
<%=   hstream.get_code_block(code, 0, @iname) -%>
<%- end -%>
<%- if !@eheader.empty? -%>

<%- end -%>

<%- @header.each do |code| -%>
<%=   hstream.get_code_block(code, 0, @iname) -%>
<%- end -%>
#ifdef __cplusplus
extern "C" {
#endif

#ifdef __
#undef __
#endif

typedef struct <%= prefix %>_context_tag <%= prefix %>_context_t;

<%= prefix %>_context_t *<%= prefix %>_create(<%= auxil_def %>auxil);
int <%= prefix %>_parse(<%= prefix %>_context_t *ctx, <%= value_def %>*ret);

#ifdef __cplusplus
}
#endif

<%- if @location -%>

typedef struct pcc_location_tag {
<%-   @location.each do |code| -%>
<%=     hstream.get_code_block(code, 4, @iname) -%>
<%-   end -%>
} pcc_location_t;
<%- end -%>

<%- @source.each do |code| -%>
<%=   hstream.get_code_block(code, 0, @iname) -%>
<%- end -%>
#if !defined __has_attribute || defined _MSC_VER
#define __attribute__(x)
#endif

#ifdef _MSC_VER
#define MARK_FUNC_AS_USED __pragma(warning(suppress:4505))
#else
#define MARK_FUNC_AS_USED __attribute__((__unused__))
#endif

#ifndef PCC_BUFFER_MIN_SIZE
#define PCC_BUFFER_MIN_SIZE 256
#endif /* !PCC_BUFFER_MIN_SIZE */

#ifndef PCC_ARRAY_MIN_SIZE
#define PCC_ARRAY_MIN_SIZE 2
#endif /* !PCC_ARRAY_MIN_SIZE */

#ifndef PCC_POOL_MIN_SIZE
#define PCC_POOL_MIN_SIZE 65536
#endif /* !PCC_POOL_MIN_SIZE */

#define PCC_DBG_EVALUATE 0
#define PCC_DBG_MATCH    1
#define PCC_DBG_NOMATCH  2

#define PCC_VOID_VALUE (~(size_t)0)

typedef struct pcc_range_tag {
    size_t start;
    size_t end;
<%- if @location -%>
    pcc_location_t start_loc;
    pcc_location_t end_loc;
<%- end -%>
} pcc_range_t;

typedef <%= value_def %>pcc_value_t;

typedef <%= auxil_def %>pcc_auxil_t;

<% if prefix != "pcc" -%>
typedef <%= prefix%>_context_t pcc_context_t;

<% end -%>
typedef struct pcc_value_table_tag {
    pcc_value_t *buf;
    size_t max;
    size_t len;
} pcc_value_table_t;

typedef struct pcc_value_refer_table_tag {
    pcc_value_t **buf;
    size_t max;
    size_t len;
} pcc_value_refer_table_t;

typedef struct pcc_capture_tag {
    pcc_range_t range;
    char *string; /* mutable */
} pcc_capture_t;

typedef struct pcc_capture_table_tag {
    pcc_capture_t *buf;
    size_t max;
    size_t len;
} pcc_capture_table_t;

typedef struct pcc_capture_const_table_tag {
    const pcc_capture_t **buf;
    size_t max;
    size_t len;
} pcc_capture_const_table_t;

typedef struct pcc_thunk_tag pcc_thunk_t;

typedef void (*pcc_action_t)(pcc_context_t *, pcc_thunk_t *, pcc_value_t *);

typedef enum pcc_thunk_type_tag {
    PCC_THUNK_LEAF,
    PCC_THUNK_NODE
} pcc_thunk_type_t;

typedef struct pcc_thunk_leaf_tag {
    pcc_value_refer_table_t values;
    pcc_capture_const_table_t capts;
    pcc_capture_t capt0;
    pcc_action_t action;
} pcc_thunk_leaf_t;

typedef struct pcc_thunk_node_tag {
    VALUE robj;
    pcc_value_t *value; /* just a reference */
} pcc_thunk_node_t;

typedef union pcc_thunk_data_tag {
    pcc_thunk_leaf_t leaf;
    pcc_thunk_node_t node;
} pcc_thunk_data_t;

struct pcc_thunk_tag {
    VALUE robj;
    pcc_thunk_type_t type;
    pcc_thunk_data_t data;
};

typedef struct pcc_thunk_chunk_tag {
    VALUE robj;
    pcc_value_table_t values;
    pcc_capture_table_t capts;
    size_t pos; /* the starting position in the character buffer */
<%- if @location -%>
    pcc_location_t pos_loc;
<%- end -%>
} pcc_thunk_chunk_t;

typedef struct pcc_lr_entry_tag pcc_lr_entry_t;

typedef enum pcc_lr_answer_type_tag {
    PCC_LR_ANSWER_LR,
    PCC_LR_ANSWER_CHUNK
} pcc_lr_answer_type_t;

typedef union pcc_lr_answer_data_tag {
    pcc_lr_entry_t *lr;
    pcc_thunk_chunk_t *chunk;
} pcc_lr_answer_data_t;

typedef struct pcc_lr_answer_tag pcc_lr_answer_t;

struct pcc_lr_answer_tag {
    pcc_lr_answer_type_t type;
    pcc_lr_answer_data_t data;
    size_t pos; /* the absolute position in the input */
<%- if @location -%>
    pcc_location_t pos_loc;
<%- end -%>
    pcc_lr_answer_t *hold;
};

typedef pcc_thunk_chunk_t *(*pcc_rule_t)(pcc_context_t *);

typedef struct pcc_rule_set_tag {
    pcc_rule_t *buf;
    size_t max;
    size_t len;
} pcc_rule_set_t;

typedef struct pcc_lr_head_tag pcc_lr_head_t;

struct pcc_lr_head_tag {
    pcc_rule_t rule;
    pcc_rule_set_t invol;
    pcc_rule_set_t eval;
    pcc_lr_head_t *hold;
};

typedef struct pcc_lr_memo_tag {
    pcc_rule_t rule;
    pcc_lr_answer_t *answer;
} pcc_lr_memo_t;

typedef struct pcc_lr_memo_map_tag {
    pcc_lr_memo_t *buf;
    size_t max;
    size_t len;
} pcc_lr_memo_map_t;

typedef struct pcc_lr_table_entry_tag {
    pcc_lr_head_t *head; /* just a reference */
    pcc_lr_memo_map_t memos;
    pcc_lr_answer_t *hold_a;
    pcc_lr_head_t *hold_h;
} pcc_lr_table_entry_t;

typedef struct pcc_lr_table_tag {
    pcc_lr_table_entry_t **buf;
    size_t max;
    size_t len;
    size_t ofs;
} pcc_lr_table_t;

struct pcc_lr_entry_tag {
    pcc_rule_t rule;
    pcc_thunk_chunk_t *seed; /* just a reference */
    pcc_lr_head_t *head; /* just a reference */
};

typedef struct pcc_lr_stack_tag {
    pcc_lr_entry_t **buf;
    size_t max;
    size_t len;
} pcc_lr_stack_t;

typedef struct pcc_memory_entry_tag pcc_memory_entry_t;
typedef struct pcc_memory_pool_tag pcc_memory_pool_t;

struct pcc_memory_entry_tag {
    pcc_memory_entry_t *next;
};

struct pcc_memory_pool_tag {
    pcc_memory_pool_t *next;
    size_t allocated;
    size_t unused;
};

struct <%= prefix %>_context_tag {
    VALUE robj;
    <%- if @location -%>
    pcc_location_t pos_loc;
    pcc_location_t cur_loc;
    <%- end -%>
    pcc_lr_table_t lrtable;
    pcc_auxil_t auxil;
};

#ifndef PCC_ERROR
#define PCC_ERROR(auxil) pcc_error()
MARK_FUNC_AS_USED
static void pcc_error(void) {
    fprintf(stderr, "Syntax error\n");
    exit(1);
}
#endif /* !PCC_ERROR */

#ifndef PCC_GETCHAR
#define PCC_GETCHAR(auxil) NUM2INT(rb_funcall(rb_mKernel, rb_intern("getb"), 0))
#endif /* !PCC_GETCHAR */

#ifndef PCC_MALLOC
#define PCC_MALLOC(auxil, size) pcc_malloc_e(size)
static void *pcc_malloc_e(size_t size) {
    void *const p = malloc(size);
    if (p == NULL) {
        fprintf(stderr, "Out of memory\n");
        exit(1);
    }
    return p;
}
#endif /* !PCC_MALLOC */

#ifndef PCC_REALLOC
#define PCC_REALLOC(auxil, ptr, size) pcc_realloc_e(ptr, size)
static void *pcc_realloc_e(void *ptr, size_t size) {
    void *const p = realloc(ptr, size);
    if (p == NULL) {
        fprintf(stderr, "Out of memory\n");
        exit(1);
    }
    return p;
}
#endif /* !PCC_REALLOC */

#ifndef PCC_DEBUG
#define PCC_DEBUG(auxil, event, rule, level, pos, buffer, length) ((void)0)
#endif /* !PCC_DEBUG */

static VALUE cLrEntry, cThunk, cThunkChunk;

static void pcc_lr_entry_mark(void *ptr) {
}

static void pcc_lr_entry_free(void *ptr) {
    pcc_lr_entry_t *e = ptr;
    xfree(e);
}

static size_t pcc_lr_entry_memsize(const void *ptr) {
    return sizeof(pcc_lr_entry_t);
}

static const rb_data_type_t pcc_lr_entry_data_type = {
    "pcc_lr_entry",
    {pcc_lr_entry_mark, pcc_lr_entry_free, pcc_lr_entry_memsize,},
    0, 0, RUBY_TYPED_WB_PROTECTED | RUBY_TYPED_FREE_IMMEDIATELY
};

static VALUE pcc_lr_entry_s_alloc(VALUE klass) {
    pcc_lr_entry_t *e;
    VALUE obj = TypedData_Make_Struct(klass, pcc_lr_entry_t, &pcc_lr_entry_data_type, e);

    return obj;
}

static void pcc_thunk_mark(void *ptr) {
}

static void pcc_thunk_free(void *ptr) {
}

static size_t pcc_thunk_memsize(const void *ptr) {
    return sizeof(pcc_thunk_t);
}

static const rb_data_type_t pcc_thunk_data_type = {
    "pcc_thunk",
    {pcc_thunk_mark, pcc_thunk_free, pcc_thunk_memsize,},
    0, 0, RUBY_TYPED_WB_PROTECTED | RUBY_TYPED_FREE_IMMEDIATELY
};

static VALUE pcc_thunk_s_alloc(VALUE klass) {
    pcc_thunk_t *thunk;
    VALUE obj = TypedData_Make_Struct(klass, pcc_thunk_t, &pcc_thunk_data_type, thunk);

    return obj;
}

static void pcc_thunk_chunk_mark(void *ptr) {
}

static void pcc_thunk_chunk_free(void *ptr) {
}

static size_t pcc_thunk_chunk_memsize(const void *ptr) {
    return sizeof(pcc_thunk_chunk_t);
}

static const rb_data_type_t pcc_thunk_chunk_data_type = {
    "pcc_thunk_chunk",
    {pcc_thunk_chunk_mark, pcc_thunk_chunk_free, pcc_thunk_chunk_memsize,},
    0, 0, RUBY_TYPED_WB_PROTECTED | RUBY_TYPED_FREE_IMMEDIATELY
};

static VALUE pcc_thunk_chunk_s_alloc(VALUE klass) {
    pcc_thunk_chunk_t *chunk;
    VALUE obj = TypedData_Make_Struct(klass, pcc_thunk_chunk_t, &pcc_thunk_chunk_data_type, chunk);

    return obj;
}

static char *pcc_strndup_e(pcc_auxil_t auxil, const char *str, size_t len) {
    const size_t m = strnlen(str, len);
    char *const s = (char *)PCC_MALLOC(auxil, m + 1);
    memcpy(s, str, m);
    s[m] = '\0';
    return s;
}

static void pcc_value_table__init(pcc_auxil_t auxil, pcc_value_table_t *table) {
    table->len = 0;
    table->max = 0;
    table->buf = NULL;
}

MARK_FUNC_AS_USED
static void pcc_value_table__resize(pcc_auxil_t auxil, pcc_value_table_t *table, size_t len) {
    if (table->max < len) {
        size_t m = table->max;
        if (m == 0) m = PCC_ARRAY_MIN_SIZE;
        while (m < len && m != 0) m <<= 1;
        if (m == 0) m = len;
        table->buf = (pcc_value_t *)PCC_REALLOC(auxil, table->buf, sizeof(pcc_value_t) * m);
        table->max = m;
    }
    table->len = len;
}

MARK_FUNC_AS_USED
static void pcc_value_table__clear(pcc_auxil_t auxil, pcc_value_table_t *table) {
    memset(table->buf, 0, sizeof(pcc_value_t) * table->len);
}

static void pcc_value_refer_table__init(pcc_auxil_t auxil, pcc_value_refer_table_t *table) {
    table->len = 0;
    table->max = 0;
    table->buf = NULL;
}

static void pcc_value_refer_table__resize(pcc_auxil_t auxil, pcc_value_refer_table_t *table, size_t len) {
    size_t i;
    if (table->max < len) {
        size_t m = table->max;
        if (m == 0) m = PCC_ARRAY_MIN_SIZE;
        while (m < len && m != 0) m <<= 1;
        if (m == 0) m = len;
        table->buf = (pcc_value_t **)PCC_REALLOC(auxil, table->buf, sizeof(pcc_value_t *) * m);
        table->max = m;
    }
    for (i = table->len; i < len; i++) table->buf[i] = NULL;
    table->len = len;
}

static void pcc_capture_table__init(pcc_auxil_t auxil, pcc_capture_table_t *table) {
    table->len = 0;
    table->max = 0;
    table->buf = NULL;
}

MARK_FUNC_AS_USED
static void pcc_capture_table__resize(pcc_auxil_t auxil, pcc_capture_table_t *table, size_t len) {
    size_t i;
    if (table->max < len) {
        size_t m = table->max;
        if (m == 0) m = PCC_ARRAY_MIN_SIZE;
        while (m < len && m != 0) m <<= 1;
        if (m == 0) m = len;
        table->buf = (pcc_capture_t *)PCC_REALLOC(auxil, table->buf, sizeof(pcc_capture_t) * m);
        table->max = m;
    }
    for (i = table->len; i < len; i++) {
        table->buf[i].range.start = 0;
        table->buf[i].range.end = 0;
<%- if @location -%>
        pcc_location_init(&table->buf[i].range.start_loc);
        pcc_location_init(&table->buf[i].range.end_loc);
<%- end -%>
        table->buf[i].string = NULL;
    }
    table->len = len;
}

static void pcc_capture_const_table__init(pcc_auxil_t auxil, pcc_capture_const_table_t *table) {
    table->len = 0;
    table->max = 0;
    table->buf = NULL;
}

static void pcc_capture_const_table__resize(pcc_auxil_t auxil, pcc_capture_const_table_t *table, size_t len) {
    size_t i;
    if (table->max < len) {
        size_t m = table->max;
        if (m == 0) m = PCC_ARRAY_MIN_SIZE;
        while (m < len && m != 0) m <<= 1;
        if (m == 0) m = len;
        table->buf = (const pcc_capture_t **)PCC_REALLOC(auxil, (pcc_capture_t **)table->buf, sizeof(const pcc_capture_t *) * m);
        table->max = m;
    }
    for (i = table->len; i < len; i++) table->buf[i] = NULL;
    table->len = len;
}

MARK_FUNC_AS_USED
static pcc_thunk_t *pcc_thunk__create_leaf(pcc_auxil_t auxil, pcc_action_t action, size_t valuec, size_t captc) {
    pcc_thunk_t *thunk;
    VALUE obj = TypedData_Make_Struct(cThunk, pcc_thunk_t, &pcc_thunk_data_type, thunk);
    thunk->robj = obj;
    thunk->type = PCC_THUNK_LEAF;
    pcc_value_refer_table__init(auxil, &thunk->data.leaf.values);
    pcc_value_refer_table__resize(auxil, &thunk->data.leaf.values, valuec);
    pcc_capture_const_table__init(auxil, &thunk->data.leaf.capts);
    pcc_capture_const_table__resize(auxil, &thunk->data.leaf.capts, captc);
    thunk->data.leaf.capt0.range.start = 0;
    thunk->data.leaf.capt0.range.end = 0;
<%- if @location -%>
    pcc_location_init(&thunk->data.leaf.capt0.range.start_loc);
    pcc_location_init(&thunk->data.leaf.capt0.range.end_loc);
<%- end -%>
    thunk->data.leaf.capt0.string = NULL;
    thunk->data.leaf.action = action;
    return thunk;
}

static pcc_thunk_t *pcc_thunk__create_node(pcc_auxil_t auxil, VALUE rthunks, pcc_value_t *value) {
    pcc_thunk_t *thunk;
    VALUE obj = TypedData_Make_Struct(cThunk, pcc_thunk_t, &pcc_thunk_data_type, thunk);
    thunk->robj = obj;
    thunk->type = PCC_THUNK_NODE;
    rb_ivar_set(obj, rb_intern("@thunks"), rthunks);
    thunk->data.node.value = value;
    return thunk;
}

MARK_FUNC_AS_USED
static pcc_thunk_chunk_t *pcc_thunk_chunk__create(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *chunk;
    VALUE obj = TypedData_Make_Struct(cThunkChunk, pcc_thunk_chunk_t, &pcc_thunk_chunk_data_type, chunk);
    chunk->robj = obj;
    pcc_value_table__init(ctx->auxil, &chunk->values);
    pcc_capture_table__init(ctx->auxil, &chunk->capts);
    rb_ivar_set(obj, rb_intern("@thunks"), rb_ary_new());
    chunk->pos = 0;
    return chunk;
}

static void pcc_rule_set__init(pcc_auxil_t auxil, pcc_rule_set_t *set) {
    set->len = 0;
    set->max = 0;
    set->buf = NULL;
}

static size_t pcc_rule_set__index(pcc_auxil_t auxil, const pcc_rule_set_t *set, pcc_rule_t rule) {
    size_t i;
    for (i = 0; i < set->len; i++) {
        if (set->buf[i] == rule) return i;
    }
    return PCC_VOID_VALUE;
}

static VALUE pcc_rule_set__add(pcc_auxil_t auxil, pcc_rule_set_t *set, pcc_rule_t rule) {
    const size_t i = pcc_rule_set__index(auxil, set, rule);
    if (i != PCC_VOID_VALUE) return Qfalse;
    if (set->max <= set->len) {
        const size_t n = set->len + 1;
        size_t m = set->max;
        if (m == 0) m = PCC_ARRAY_MIN_SIZE;
        while (m < n && m != 0) m <<= 1;
        if (m == 0) m = n;
        set->buf = (pcc_rule_t *)PCC_REALLOC(auxil, set->buf, sizeof(pcc_rule_t) * m);
        set->max = m;
    }
    set->buf[set->len++] = rule;
    return Qtrue;
}

static VALUE pcc_rule_set__remove(pcc_auxil_t auxil, pcc_rule_set_t *set, pcc_rule_t rule) {
    const size_t i = pcc_rule_set__index(auxil, set, rule);
    if (i == PCC_VOID_VALUE) return Qfalse;
    memmove(set->buf + i, set->buf + (i + 1), sizeof(pcc_rule_t) * (set->len - (i + 1)));
    return Qtrue;
}

static void pcc_rule_set__clear(pcc_auxil_t auxil, pcc_rule_set_t *set) {
    set->len = 0;
}

static void pcc_rule_set__copy(pcc_auxil_t auxil, pcc_rule_set_t *set, const pcc_rule_set_t *src) {
    size_t i;
    pcc_rule_set__clear(auxil, set);
    for (i = 0; i < src->len; i++) {
        pcc_rule_set__add(auxil, set, src->buf[i]);
    }
}

static pcc_lr_head_t *pcc_lr_head__create(pcc_context_t *ctx, pcc_rule_t rule) {
    pcc_lr_head_t *const head = (pcc_lr_head_t *)xmalloc(sizeof(pcc_lr_head_t));
    head->rule = rule;
    pcc_rule_set__init(ctx->auxil, &head->invol);
    pcc_rule_set__init(ctx->auxil, &head->eval);
    head->hold = NULL;
    return head;
}

static pcc_lr_answer_t *pcc_lr_answer__create(pcc_context_t *ctx, pcc_lr_answer_type_t type, size_t pos<% if @location %>, pcc_location_t pos_loc<% end %>) {
    pcc_lr_answer_t *answer = (pcc_lr_answer_t *)xmalloc(sizeof(pcc_lr_answer_t));
    answer->type = type;
    answer->pos = pos;
<%- if @location -%>
    answer->pos_loc = pos_loc;
<%- end -%>
    answer->hold = NULL;
    switch (answer->type) {
    case PCC_LR_ANSWER_LR:
        answer->data.lr = NULL;
        break;
    case PCC_LR_ANSWER_CHUNK:
        answer->data.chunk = NULL;
        break;
    default: /* unknown */
        answer = NULL;
    }
    return answer;
}

static void pcc_lr_answer__set_chunk(pcc_context_t *ctx, pcc_lr_answer_t *answer, pcc_thunk_chunk_t *chunk) {
    pcc_lr_answer_t *const a = pcc_lr_answer__create(ctx, answer->type, answer->pos<% if @location %>, answer->pos_loc<% end %>);
    switch (answer->type) {
    case PCC_LR_ANSWER_LR:
        a->data.lr = answer->data.lr;
        break;
    case PCC_LR_ANSWER_CHUNK:
        a->data.chunk = answer->data.chunk;
        break;
    default: /* unknown */
        break;
    }
    a->hold = answer->hold;
    answer->hold = a;
    answer->type = PCC_LR_ANSWER_CHUNK;
    answer->data.chunk = chunk;
}

static void pcc_lr_memo_map__init(pcc_auxil_t auxil, pcc_lr_memo_map_t *map) {
    map->len = 0;
    map->max = 0;
    map->buf = NULL;
}

static size_t pcc_lr_memo_map__index(pcc_context_t *ctx, pcc_lr_memo_map_t *map, pcc_rule_t rule) {
    size_t i;
    for (i = 0; i < map->len; i++) {
        if (map->buf[i].rule == rule) return i;
    }
    return PCC_VOID_VALUE;
}

static void pcc_lr_memo_map__put(pcc_context_t *ctx, pcc_lr_memo_map_t *map, pcc_rule_t rule, pcc_lr_answer_t *answer) {
    const size_t i = pcc_lr_memo_map__index(ctx, map, rule);
    if (i != PCC_VOID_VALUE) {
        map->buf[i].answer = answer;
    }
    else {
        if (map->max <= map->len) {
            const size_t n = map->len + 1;
            size_t m = map->max;
            if (m == 0) m = PCC_ARRAY_MIN_SIZE;
            while (m < n && m != 0) m <<= 1;
            if (m == 0) m = n;
            map->buf = (pcc_lr_memo_t *)PCC_REALLOC(ctx->auxil, map->buf, sizeof(pcc_lr_memo_t) * m);
            map->max = m;
        }
        map->buf[map->len].rule = rule;
        map->buf[map->len].answer = answer;
        map->len++;
    }
}

static pcc_lr_answer_t *pcc_lr_memo_map__get(pcc_context_t *ctx, pcc_lr_memo_map_t *map, pcc_rule_t rule) {
    const size_t i = pcc_lr_memo_map__index(ctx, map, rule);
    return (i != PCC_VOID_VALUE) ? map->buf[i].answer : NULL;
}

static pcc_lr_table_entry_t *pcc_lr_table_entry__create(pcc_context_t *ctx) {
    pcc_lr_table_entry_t *const entry = (pcc_lr_table_entry_t *)PCC_MALLOC(ctx->auxil, sizeof(pcc_lr_table_entry_t));
    entry->head = NULL;
    pcc_lr_memo_map__init(ctx->auxil, &entry->memos);
    entry->hold_a = NULL;
    entry->hold_h = NULL;
    return entry;
}

static void pcc_lr_table__init(pcc_auxil_t auxil, pcc_lr_table_t *table) {
    table->ofs = 0;
    table->len = 0;
    table->max = 0;
    table->buf = NULL;
}

static void pcc_lr_table__resize(pcc_context_t *ctx, pcc_lr_table_t *table, size_t len) {
    size_t i;
    if (table->max < len) {
        size_t m = table->max;
        if (m == 0) m = PCC_ARRAY_MIN_SIZE;
        while (m < len && m != 0) m <<= 1;
        if (m == 0) m = len;
        table->buf = (pcc_lr_table_entry_t **)PCC_REALLOC(ctx->auxil, table->buf, sizeof(pcc_lr_table_entry_t *) * m);
        table->max = m;
    }
    for (i = table->len; i < len; i++) table->buf[i] = NULL;
    table->len = len;
}

static void pcc_lr_table__set_head(pcc_context_t *ctx, pcc_lr_table_t *table, size_t index, pcc_lr_head_t *head) {
    index += table->ofs;
    if (index >= table->len) pcc_lr_table__resize(ctx, table, index + 1);
    if (table->buf[index] == NULL) table->buf[index] = pcc_lr_table_entry__create(ctx);
    table->buf[index]->head = head;
}

static void pcc_lr_table__hold_head(pcc_context_t *ctx, pcc_lr_table_t *table, size_t index, pcc_lr_head_t *head) {
    index += table->ofs;
    if (index >= table->len) pcc_lr_table__resize(ctx, table, index + 1);
    if (table->buf[index] == NULL) table->buf[index] = pcc_lr_table_entry__create(ctx);
    head->hold = table->buf[index]->hold_h;
    table->buf[index]->hold_h = head;
}

static void pcc_lr_table__set_answer(pcc_context_t *ctx, pcc_lr_table_t *table, size_t index, pcc_rule_t rule, pcc_lr_answer_t *answer) {
    index += table->ofs;
    if (index >= table->len) pcc_lr_table__resize(ctx, table, index + 1);
    if (table->buf[index] == NULL) table->buf[index] = pcc_lr_table_entry__create(ctx);
    pcc_lr_memo_map__put(ctx, &table->buf[index]->memos, rule, answer);
}

static void pcc_lr_table__hold_answer(pcc_context_t *ctx, pcc_lr_table_t *table, size_t index, pcc_lr_answer_t *answer) {
    index += table->ofs;
    if (index >= table->len) pcc_lr_table__resize(ctx, table, index + 1);
    if (table->buf[index] == NULL) table->buf[index] = pcc_lr_table_entry__create(ctx);
    answer->hold = table->buf[index]->hold_a;
    table->buf[index]->hold_a = answer;
}

static pcc_lr_head_t *pcc_lr_table__get_head(pcc_context_t *ctx, pcc_lr_table_t *table, size_t index) {
    index += table->ofs;
    if (index >= table->len || table->buf[index] == NULL) return NULL;
    return table->buf[index]->head;
}

static pcc_lr_answer_t *pcc_lr_table__get_answer(pcc_context_t *ctx, pcc_lr_table_t *table, size_t index, pcc_rule_t rule) {
    index += table->ofs;
    if (index >= table->len || table->buf[index] == NULL) return NULL;
    return pcc_lr_memo_map__get(ctx, &table->buf[index]->memos, rule);
}

static void pcc_lr_table__shift(pcc_context_t *ctx, pcc_lr_table_t *table, size_t count) {
    if (count > table->len - table->ofs) count = table->len - table->ofs;
    if (table->ofs > (table->max >> 1)) {
        memmove(table->buf, table->buf + table->ofs, sizeof(pcc_lr_table_entry_t *) * (table->len - table->ofs));
        table->len -= table->ofs;
        table->ofs = 0;
    }
}

static pcc_lr_entry_t *pcc_lr_entry__create(pcc_auxil_t auxil, pcc_rule_t rule) {
    pcc_lr_entry_t *const lr = (pcc_lr_entry_t *)PCC_MALLOC(auxil, sizeof(pcc_lr_entry_t));
    lr->rule = rule;
    lr->seed = NULL;
    lr->head = NULL;
    return lr;
}

static pcc_context_t *pcc_context__init(pcc_auxil_t auxil, pcc_context_t *const ctx) {
<%- if @location -%>
    pcc_location_init(&ctx->pos_loc);
    pcc_location_init(&ctx->cur_loc);
<%- end -%>
    pcc_lr_table__init(auxil, &ctx->lrtable);
    ctx->auxil = auxil;
    return ctx;
}

static pcc_context_t *pcc_context__create(pcc_auxil_t auxil) {
    pcc_context_t *const ctx = (pcc_context_t *)PCC_MALLOC(auxil, sizeof(pcc_context_t));
    return pcc_context__init(auxil, ctx);
}

static size_t pcc_refill_buffer(pcc_context_t *ctx, size_t num) {
    size_t len = (size_t) (RSTRING_LEN(rb_ivar_get(ctx->robj, rb_intern("@buffer"))));
    if (len >= NUM2SIZET(rb_ivar_get(ctx->robj, rb_intern("@cur"))) + num) return len - NUM2SIZET(rb_ivar_get(ctx->robj, rb_intern("@cur")));
    while (len < NUM2SIZET(rb_ivar_get(ctx->robj, rb_intern("@cur"))) + num) {
        const int c = PCC_GETCHAR(ctx->auxil);
        if (c < 0) break;
        rb_funcall(rb_ivar_get(ctx->robj, rb_intern("@buffer")), rb_intern("<<"), 1, INT2NUM(c));
        len = (size_t) (RSTRING_LEN(rb_ivar_get(ctx->robj, rb_intern("@buffer"))));
    }
    return len - NUM2SIZET(rb_ivar_get(ctx->robj, rb_intern("@cur")));
}

MARK_FUNC_AS_USED
static void pcc_commit_buffer(pcc_context_t *ctx) {
    VALUE rbuffer = rb_ivar_get(ctx->robj, rb_intern("@buffer"));
    rb_ivar_set(ctx->robj, rb_intern("@buffer"),
      rb_funcall(rbuffer, rb_intern("[]"), 2, INT2NUM(NUM2SIZET(rb_ivar_get(ctx->robj, rb_intern("@cur")))), INT2NUM(RSTRING_LEN(rbuffer) - NUM2SIZET(rb_ivar_get(ctx->robj, rb_intern("@cur")))))
    );
    rb_ivar_set(ctx->robj, rb_intern("@pos"), SIZET2NUM(NUM2SIZET(rb_ivar_get(ctx->robj, rb_intern("@pos"))) + NUM2SIZET(rb_ivar_get(ctx->robj, rb_intern("@cur")))));
    pcc_lr_table__shift(ctx, &ctx->lrtable, NUM2SIZET(rb_ivar_get(ctx->robj, rb_intern("@cur"))));
    rb_ivar_set(ctx->robj, rb_intern("@cur"), SIZET2NUM(0));
<%- if @location -%>
    ctx->pos_loc = pcc_location_add(ctx->pos_loc, ctx->cur_loc);
    pcc_location_init(&ctx->cur_loc);
<%- end -%>
}

MARK_FUNC_AS_USED
static const char *pcc_get_capture_string(pcc_context_t *ctx, const pcc_capture_t *capt) {
    if (capt->string == NULL)
        ((pcc_capture_t *)capt)->string =
            pcc_strndup_e(ctx->auxil, RSTRING_PTR(rb_ivar_get(ctx->robj, rb_intern("@buffer"))) + capt->range.start, capt->range.end - capt->range.start);
    return capt->string;
}

<% if @utf8 -%>
static size_t pcc_get_char_as_utf32(pcc_context_t *ctx, int *out) { /* with checking UTF-8 validity */
    int c, u;
    size_t n;
    if (pcc_refill_buffer(ctx, 1) < 1) return 0;
    c = (int)(unsigned char)RSTRING_PTR(rb_ivar_get(ctx->robj, rb_intern("@buffer")))[NUM2SIZET(rb_ivar_get(ctx->robj, rb_intern("@cur")))];
    n = (c < 0x80) ? 1 :
        ((c & 0xe0) == 0xc0) ? 2 :
        ((c & 0xf0) == 0xe0) ? 3 :
        ((c & 0xf8) == 0xf0) ? 4 : 0;
    if (n < 1) return 0;
    if (pcc_refill_buffer(ctx, n) < n) return 0;
    switch (n) {
    case 1:
        u = c;
        break;
    case 2:
        u = c & 0x1f;
        c = (int)(unsigned char)RSTRING_PTR(rb_ivar_get(ctx->robj, rb_intern("@buffer")))[NUM2SIZET(rb_ivar_get(ctx->robj, rb_intern("@cur"))) + 1];
        if ((c & 0xc0) != 0x80) return 0;
        u <<= 6; u |= c & 0x3f;
        if (u < 0x80) return 0;
        break;
    case 3:
        u = c & 0x0f;
        c = (int)(unsigned char)RSTRING_PTR(rb_ivar_get(ctx->robj, rb_intern("@buffer")))[NUM2SIZET(rb_ivar_get(ctx->robj, rb_intern("@cur"))) + 1];
        if ((c & 0xc0) != 0x80) return 0;
        u <<= 6; u |= c & 0x3f;
        c = (int)(unsigned char)RSTRING_PTR(rb_ivar_get(ctx->robj, rb_intern("@buffer")))[NUM2SIZET(rb_ivar_get(ctx->robj, rb_intern("@cur"))) + 2];
        if ((c & 0xc0) != 0x80) return 0;
        u <<= 6; u |= c & 0x3f;
        if (u < 0x800) return 0;
        break;
    case 4:
        u = c & 0x07;
        c = (int)(unsigned char)RSTRING_PTR(rb_ivar_get(ctx->robj, rb_intern("@buffer")))[NUM2SIZET(rb_ivar_get(ctx->robj, rb_intern("@cur"))) + 1];
        if ((c & 0xc0) != 0x80) return 0;
        u <<= 6; u |= c & 0x3f;
        c = (int)(unsigned char)RSTRING_PTR(rb_ivar_get(ctx->robj, rb_intern("@buffer")))[NUM2SIZET(rb_ivar_get(ctx->robj, rb_intern("@cur"))) + 2];
        if ((c & 0xc0) != 0x80) return 0;
        u <<= 6; u |= c & 0x3f;
        c = (int)(unsigned char)RSTRING_PTR(rb_ivar_get(ctx->robj, rb_intern("@buffer")))[NUM2SIZET(rb_ivar_get(ctx->robj, rb_intern("@cur"))) + 3];
        if ((c & 0xc0) != 0x80) return 0;
        u <<= 6; u |= c & 0x3f;
        if (u < 0x10000 || u > 0x10ffff) return 0;
        break;
    default:
        return 0;
    }
    if (out) *out = u;
    return n;
}

<% end -%>
MARK_FUNC_AS_USED
static VALUE pcc_apply_rule(pcc_context_t *ctx, pcc_rule_t rule, VALUE rthunks, pcc_value_t *value) {
    static pcc_value_t null;
    pcc_thunk_chunk_t *c = NULL;
    const size_t p = NUM2SIZET(rb_ivar_get(ctx->robj, rb_intern("@pos"))) + NUM2SIZET(rb_ivar_get(ctx->robj, rb_intern("@cur")));
<%- if @location -%>
    const pcc_location_t p_loc = pcc_location_add(ctx->pos_loc, ctx->cur_loc);
<%- end -%>
    VALUE b = Qtrue;
    pcc_lr_answer_t *a = pcc_lr_table__get_answer(ctx, &ctx->lrtable, p, rule);
    pcc_lr_head_t *h = pcc_lr_table__get_head(ctx, &ctx->lrtable, p);
    if (h != NULL) {
        if (a == NULL && rule != h->rule && pcc_rule_set__index(ctx->auxil, &h->invol, rule) == PCC_VOID_VALUE) {
            b = Qfalse;
            c = NULL;
        }
        else if (RTEST(pcc_rule_set__remove(ctx->auxil, &h->eval, rule))) {
            b = Qfalse;
            c = rule(ctx);
            a = pcc_lr_answer__create(ctx, PCC_LR_ANSWER_CHUNK, NUM2SIZET(rb_ivar_get(ctx->robj, rb_intern("@pos"))) + NUM2SIZET(rb_ivar_get(ctx->robj, rb_intern("@cur")))<% if @location %>, pcc_location_add(ctx->pos_loc, ctx->cur_loc)<% end %>);
            a->data.chunk = c;
            pcc_lr_table__hold_answer(ctx, &ctx->lrtable, p, a);
        }
    }
    if (RTEST(b)) {
        if (a != NULL) {
            rb_ivar_set(ctx->robj, rb_intern("@cur"), SIZET2NUM(a->pos - NUM2SIZET(rb_ivar_get(ctx->robj, rb_intern("@pos")))));
<%- if @location -%>
            ctx->cur_loc = pcc_location_sub(a->pos_loc, ctx->pos_loc);
<%- end -%>
            switch (a->type) {
            case PCC_LR_ANSWER_LR:
                if (a->data.lr->head == NULL) {
                    a->data.lr->head = pcc_lr_head__create(ctx, rule);
                    pcc_lr_table__hold_head(ctx, &ctx->lrtable, p, a->data.lr->head);
                }
                {
                    size_t i = RARRAY_LEN(rb_ivar_get(ctx->robj, rb_intern("@lrstack")));
                    while (i > 0) {
                        i--;
                        VALUE rlrentry = rb_funcall(rb_ivar_get(ctx->robj, rb_intern("@lrstack")), rb_intern("[]"), 1, SIZET2NUM(i));
                        pcc_lr_entry_t *lrentry;
                        TypedData_Get_Struct(rlrentry, pcc_lr_entry_t, &pcc_lr_entry_data_type, lrentry);
                        if (lrentry->head == a->data.lr->head) break;
                        lrentry->head = a->data.lr->head;
                        pcc_rule_set__add(ctx->auxil, &a->data.lr->head->invol, lrentry->rule);
                    }
                }
                c = a->data.lr->seed;
                break;
            case PCC_LR_ANSWER_CHUNK:
                c = a->data.chunk;
                break;
            default: /* unknown */
                break;
            }
        }
        else {
            pcc_lr_entry_t *const e = pcc_lr_entry__create(ctx->auxil, rule);
            VALUE rentry = TypedData_Wrap_Struct(cLrEntry, &pcc_lr_entry_data_type, e);
            rb_funcall(rb_ivar_get(ctx->robj, rb_intern("@lrstack")), rb_intern("push"), 1, rentry);
            a = pcc_lr_answer__create(ctx, PCC_LR_ANSWER_LR, p<% if @location %>, p_loc<% end %>);
            a->data.lr = e;
            pcc_lr_table__set_answer(ctx, &ctx->lrtable, p, rule, a);
            c = rule(ctx);
            rb_funcall(rb_ivar_get(ctx->robj, rb_intern("@lrstack")), rb_intern("pop"), 0);
            a->pos = NUM2SIZET(rb_ivar_get(ctx->robj, rb_intern("@pos"))) + NUM2SIZET(rb_ivar_get(ctx->robj, rb_intern("@cur")));
<%- if @location -%>
            a->pos_loc = pcc_location_add(ctx->pos_loc, ctx->cur_loc);
<%- end -%>
            if (e->head == NULL) {
                pcc_lr_answer__set_chunk(ctx, a, c);
            }
            else {
                e->seed = c;
                h = a->data.lr->head;
                if (h->rule != rule) {
                    c = a->data.lr->seed;
                    a = pcc_lr_answer__create(ctx, PCC_LR_ANSWER_CHUNK, NUM2SIZET(rb_ivar_get(ctx->robj, rb_intern("@pos"))) + NUM2SIZET(rb_ivar_get(ctx->robj, rb_intern("@cur")))<% if @location %>, pcc_location_add(ctx->pos_loc, ctx->cur_loc)<% end %>);
                    a->data.chunk = c;
                    pcc_lr_table__hold_answer(ctx, &ctx->lrtable, p, a);
                }
                else {
                    pcc_lr_answer__set_chunk(ctx, a, a->data.lr->seed);
                    if (a->data.chunk == NULL) {
                        c = NULL;
                    }
                    else {
                        pcc_lr_table__set_head(ctx, &ctx->lrtable, p, h);
                        for (;;) {
                            rb_ivar_set(ctx->robj, rb_intern("@cur"), SIZET2NUM(p - NUM2SIZET(rb_ivar_get(ctx->robj, rb_intern("@pos")))));
<%- if @location -%>
                            ctx->cur_loc = pcc_location_sub(p_loc, ctx->pos_loc);
<%- end -%>
                            pcc_rule_set__copy(ctx->auxil, &h->eval, &h->invol);
                            c = rule(ctx);
                            if (c == NULL || NUM2SIZET(rb_ivar_get(ctx->robj, rb_intern("@pos"))) + NUM2SIZET(rb_ivar_get(ctx->robj, rb_intern("@cur"))) <= a->pos) break;
                            pcc_lr_answer__set_chunk(ctx, a, c);
                            a->pos = NUM2SIZET(rb_ivar_get(ctx->robj, rb_intern("@pos"))) + NUM2SIZET(rb_ivar_get(ctx->robj, rb_intern("@cur")));
<%- if @location -%>
                            a->pos_loc = pcc_location_add(ctx->pos_loc, ctx->cur_loc);
<%- end -%>
                        }
                        pcc_lr_table__set_head(ctx, &ctx->lrtable, p, NULL);
                        rb_ivar_set(ctx->robj, rb_intern("@cur"), SIZET2NUM(a->pos - NUM2SIZET(rb_ivar_get(ctx->robj, rb_intern("@pos")))));
<%- if @location -%>
                        ctx->cur_loc = pcc_location_sub(a->pos_loc, ctx->pos_loc);
<%- end -%>
                        c = a->data.chunk;
                    }
                }
            }
        }
    }
    if (c == NULL) return Qfalse;
    if (value == NULL) value = &null;
    memset(value, 0, sizeof(pcc_value_t)); /* in case */
    {
        pcc_thunk_t *t = pcc_thunk__create_node(ctx->auxil, rb_ivar_get(c->robj, rb_intern("@thunks")), value);
        rb_funcall(rthunks, rb_intern("push"), 1, t->robj);
    }
    return Qtrue;
}

MARK_FUNC_AS_USED
static void pcc_do_action(pcc_context_t *ctx, VALUE rthunks, pcc_value_t *value) {
    size_t i;
    for (i = 0; i < RARRAY_LEN(rthunks); i++) {
        pcc_thunk_t *thunk;
        VALUE rthunk = rb_funcall(rthunks, rb_intern("[]"), 1, SIZET2NUM(i));
        TypedData_Get_Struct(rthunk, pcc_thunk_t, &pcc_thunk_data_type, thunk);
        switch (thunk->type) {
        case PCC_THUNK_LEAF:
            thunk->data.leaf.action(ctx, thunk, value);
            break;
        case PCC_THUNK_NODE:
            pcc_do_action(ctx, rb_ivar_get(thunk->robj, rb_intern("@thunks")), thunk->data.node.value);
            break;
        default: /* unknown */
            break;
        }
    }
}

<%- @rules.each do |rule| -%>
<%-   rule.codes.each do |code| -%>
static void pcc_action_<%= rule.name %>_<%= code.index %>(<%= prefix %>_context_t *__pcc_ctx, pcc_thunk_t *__pcc_in, pcc_value_t *__pcc_out) {
#define auxil (__pcc_ctx->auxil)
#define __ (*__pcc_out)
<%-     code.vars.each do |ref| -%>
#define <%= ref.var %> (*__pcc_in->data.leaf.values.buf[<%= ref.index %>])
<%      end -%>
#define _0 pcc_get_capture_string(__pcc_ctx, &__pcc_in->data.leaf.capt0)
#define _0s ((const size_t)(__pcc_NUM2SIZET(rb_ivar_get(ctx->robj, rb_intern("@pos"))) + __pcc_in->data.leaf.capt0.range.start))
#define _0e ((const size_t)(__pcc_NUM2SIZET(rb_ivar_get(ctx->robj, rb_intern("@pos"))) + __pcc_in->data.leaf.capt0.range.end))
<%      code.capts.each do |capture| -%>
#define _<%= capture.index + 1 %> pcc_get_capture_string(__pcc_ctx, __pcc_in->data.leaf.capts.buf[<%= capture.index %>])
#define _<%= capture.index + 1 %>s ((const size_t)(__pcc_NUM2SIZET(rb_ivar_get(ctx->robj, rb_intern("@pos"))) + __pcc_in->data.leaf.capts.buf[<%= capture.index %>]->range.start))
#define _<%= capture.index + 1 %>e ((const size_t)(__pcc_NUM2SIZET(rb_ivar_get(ctx->robj, rb_intern("@pos"))) + __pcc_in->data.leaf.capts.buf[<%= capture.index %>]->range.end))
<%-       if @location -%>
#define _<%= capture.index + 1 %>sl ((const pcc_location_t)(pcc_location_add(__pcc_ctx->pos_loc, __pcc_in->data.leaf.capts.buf[<%= capture.index %>]->range.start_loc)))
#define _<%= capture.index + 1 %>el ((const pcc_location_t)(pcc_location_add(__pcc_ctx->pos_loc, __pcc_in->data.leaf.capts.buf[<%= capture.index %>]->range.end_loc)))
<%-       end -%>
<%-     end -%>
<%=     hstream.get_code_block(code.code, 4, @iname) -%>
<%-     code.capts.reverse_each do |capture| -%>
<%-       if @location -%>
#undef _<%= capture.index + 1 %>el
#undef _<%= capture.index + 1 %>sl
<%-       end -%>
#undef _<%= capture.index + 1 %>e
#undef _<%= capture.index + 1 %>s
#undef _<%= capture.index + 1 %>
<%-     end -%>
#undef _0e
#undef _0s
#undef _0
<%- code.vars.reverse_each do |ref| -%>
#undef <%= ref.var %>
<%-     end -%>
#undef __
#undef auxil
}

<%-   end -%>
<%- end -%>
<%- @rules.each do |node| -%>
static pcc_thunk_chunk_t *pcc_evaluate_rule_<%= node.name %>(pcc_context_t *ctx);
<%- end -%>

<%- @rules.each do |node| -%>
static pcc_thunk_chunk_t *pcc_evaluate_rule_<%= node.name %>(pcc_context_t *ctx) {
    pcc_thunk_chunk_t *const chunk = pcc_thunk_chunk__create(ctx);
    chunk->pos = NUM2SIZET(rb_ivar_get(ctx->robj, rb_intern("@cur")));
<%- if @location -%>
    chunk->pos_loc = ctx->cur_loc;
<%- end -%>
    PCC_DEBUG(ctx->auxil, PCC_DBG_EVALUATE, "<%= node.name %>", NUM2SIZET(rb_ivar_get(ctx->robj, rb_intern("@level"))), chunk->pos, (RSTRING_PTR(rb_ivar_get(ctx->robj, rb_intern("@buffer"))) + chunk->pos), (RSTRING_LEN(rb_ivar_get(ctx->robj, rb_intern("@buffer"))) - chunk->pos));
    rb_ivar_set(ctx->robj, rb_intern("@level"), SIZET2NUM(NUM2SIZET(rb_ivar_get(ctx->robj, rb_intern("@level"))) + 1));
    pcc_value_table__resize(ctx->auxil, &chunk->values, <%= node.vars.length %>);
    pcc_capture_table__resize(ctx->auxil, &chunk->capts, <%= node.capts.length %>);
<%-   if node.vars.length > 0 -%>
    pcc_value_table__clear(ctx->auxil, &chunk->values);
<%-   end -%>
<%-   g = ::Packcr::Generator.new(node, @ascii, @location, :rb) -%>
<%-   r, str = g.generate_code_str(node.expr, 0, 4, false) -%>
<%=   str -%>
    rb_ivar_set(ctx->robj, rb_intern("@level"), SIZET2NUM(NUM2SIZET(rb_ivar_get(ctx->robj, rb_intern("@level"))) - 1));
    PCC_DEBUG(ctx->auxil, PCC_DBG_MATCH, "<%= node.name %>", NUM2SIZET(rb_ivar_get(ctx->robj, rb_intern("@level"))), chunk->pos, (RSTRING_PTR(rb_ivar_get(ctx->robj, rb_intern("@buffer"))) + chunk->pos), (NUM2SIZET(rb_ivar_get(ctx->robj, rb_intern("@cur"))) - chunk->pos));
    return chunk;
<%-   if r != Packcr::CODE_REACH__ALWAYS_SUCCEED -%>
L0000:;
    rb_ivar_set(ctx->robj, rb_intern("@level"), SIZET2NUM(NUM2SIZET(rb_ivar_get(ctx->robj, rb_intern("@level"))) - 1));
    PCC_DEBUG(ctx->auxil, PCC_DBG_NOMATCH, "<%= node.name %>", NUM2SIZET(rb_ivar_get(ctx->robj, rb_intern("@level"))), chunk->pos, (RSTRING_PTR(rb_ivar_get(ctx->robj, rb_intern("@buffer"))) + chunk->pos), (NUM2SIZET(rb_ivar_get(ctx->robj, rb_intern("@cur"))) - chunk->pos));
    return NULL;
<%-   end -%>
}

<%- end -%>
<%= prefix %>_context_t *<%= prefix %>_create(<%= auxil_def %>auxil) {
    return pcc_context__create(auxil);
}

int <%= prefix %>_parse(<%= prefix %>_context_t *ctx, <%= value_def %>*ret) {
<%- if !@rules.empty? -%>
    VALUE rthunks = rb_ivar_get(ctx->robj, rb_intern("@thunks"));
    if (pcc_apply_rule(ctx, pcc_evaluate_rule_<%= @rules[0].name %>, rthunks, ret))
        pcc_do_action(ctx, rthunks, ret);
    else
        PCC_ERROR(ctx->auxil);
    pcc_commit_buffer(ctx);
<%- end -%>
    rb_funcall(rthunks, rb_intern("clear"), 0);
    return pcc_refill_buffer(ctx, 1) >= 1;
}

<%- @lheader.each do |code| -%>
<%=   hstream.get_code_block(code, 0, @iname) -%>
<%- end -%>

static void <%= prefix %>_mark(void *ptr) {
}

static void <%= prefix %>_free(void *ptr) {
    <%= prefix %>_context_t *ctx = ptr;

    xfree(ctx);
}

static size_t <%= prefix %>_memsize(const void *ptr) {
    return sizeof(<%= prefix %>_context_t);
}

static const rb_data_type_t <%= prefix %>_data_type = {
    "<%= prefix %>",
    {<%= prefix %>_mark, <%= prefix %>_free, <%= prefix %>_memsize,},
    0, 0, RUBY_TYPED_WB_PROTECTED | RUBY_TYPED_FREE_IMMEDIATELY
};

static VALUE <%= prefix %>_s_alloc(VALUE klass) {
    <%= prefix %>_context_t *ctx;
    VALUE obj = TypedData_Make_Struct(klass, <%= prefix %>_context_t, &<%= prefix %>_data_type, ctx);
    ctx->robj = obj;
    pcc_context__init(NULL, ctx);

    return obj;
}

static VALUE <%= prefix %>_initialize(VALUE self) {
    return self;
}

static VALUE <%= prefix %>_run(VALUE self) {
    <%= prefix %>_context_t *ctx;
    TypedData_Get_Struct(self, <%= prefix %>_context_t, &<%= prefix %>_data_type, ctx);
    while (<%= prefix %>_parse(ctx, NULL));
    return Qfalse;
}

void Init_<%= prefix %>(void) {
    VALUE c<%= class_name %> = rb_define_class("<%= class_name %>", rb_cObject);

    rb_define_alloc_func(c<%= class_name %>, <%= prefix %>_s_alloc);
    rb_define_method(c<%= class_name %>, "_initialize", <%= prefix %>_initialize, 0);
    rb_define_method(c<%= class_name %>, "run", <%= prefix %>_run, 0);

    cLrEntry = rb_define_class_under(rb_cObject, "LrEntry", c<%= class_name %>);
    rb_define_alloc_func(cLrEntry, pcc_lr_entry_s_alloc);

    cThunk = rb_define_class_under(rb_cObject, "Thunk", c<%= class_name %>);
    rb_define_alloc_func(cThunk, pcc_thunk_s_alloc);

    cThunkChunk = rb_define_class_under(rb_cObject, "ThunkChunk", c<%= class_name %>);
    rb_define_alloc_func(cThunkChunk, pcc_thunk_chunk_s_alloc);
}
