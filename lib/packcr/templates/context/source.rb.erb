# A packrat parser generated by PackCR <%= Packcr::VERSION %>
<%- if !@source.empty? -%>

<%-   @source.each do |code| -%>
<%=     sstream.get_code_block(code, 0, @iname) -%>
<%-   end -%>
<%- end -%>

class <%= class_name %>
  def initialize(<% if @auxil_type %><%= auxil_type %>, <% end %>debug: false)
    <%- if @utf8 -%>
    @buffer = +""
    <%- else -%>
    @buffer = +"".b
    <%- end %>
    @pos = 0
    @cur = 0
    @level = 0
    @lrstack = []
    @thunk = ThunkNode.new([], nil, 0)
    @lrtable = LrTable.new
    @debug = debug
    @global_values = []
    <%- if @location -%>
    @pos_loc = Location.new
    @cur_loc = Location.new
    <%- end -%>
    <%-   @init.each do |code| -%>
    <%- %><%= sstream.get_code_block(code, 4, @iname) -%>
    <%-   end -%>
  end

  def debug
    yield if @debug
  end

  def getc
    <%- if @utf8 -%>
    $stdin.getc
    <%- else -%>
    $stdin.getc&.b
    <%- end -%>
  end

  def refill_buffer(num, mode = nil)
    len = @buffer.length
    if len >= @cur + num
      return len - @cur
    end
    while len < @cur + num
      c = getc
      break if !c
      @buffer << c
      len = @buffer.length
    end
    return len - @cur
  end

  def commit_buffer
    @buffer = @buffer[@cur, @buffer.length - @cur]
    @pos += @cur
    @lrtable.clear
    @cur = 0
    <%- if @location -%>
    @pos_loc = @pos_loc + @cur_loc
    @cur_loc = Location.new
    <%- end -%>
  end

  def parse
    pos = @pos
    <%- if !@rules.empty? -%>
    if apply_rule(:evaluate_rule_<%= @rules[0].name %>, @thunk.thunks, nil, 0)
      @thunk.do_action(self, nil, 0)
    else
      raise SyntaxError, "can't parse"
    end
    commit_buffer
    <%- end -%>
    @thunk.clear
    refill_buffer(1) >= 1 && pos != @pos
  end

  def run
    nil while parse
  end

  <%- @rules.each do |rule| -%>
  <%-   rule.codes.each do |code| -%>
  def action_<%= rule.name %>_<%= code.index %>(__pcc_in, __pcc_vars, __pcc_index)
    ____ = (__pcc_vars[__pcc_index] ||= Value.new).value if __pcc_vars
    <%-   code.vars.each do |ref| -%>
    <%= ref.var %> = (__pcc_in.value_refs[<%= ref.index %>]  ||= Value.new).value
    <%-   end -%>
    __0 = __pcc_in.capt0.capture_string(@buffer)
    __0s = @pos + __pcc_in.capt0.range_start
    __0e = @pos + __pcc_in.capt0.range_end
    <%-   if @location -%>
    __0sl = @pos_loc + __pcc_in.capt0.start_loc
    __0el = @pos_loc + __pcc_in.capt0.end_loc
    <%-   end -%>
    <%-   if @capture_in_code -%>
    __0c = __pcc_in.capt0
    <%-   end -%>
    <%-   code.capts.each do |capture| -%>
    __<%= capture.index + 1 %> = __pcc_in.capts[<%= capture.index %>].capture_string(@buffer)
    __<%= capture.index + 1 %>s = @pos + __pcc_in.capts[<%= capture.index %>].range_start
    __<%= capture.index + 1 %>e = @pos + __pcc_in.capts[<%= capture.index %>].range_end
    <%-     if @location -%>
    __<%= capture.index + 1 %>sl = @pos_loc + __pcc_in.capts[<%= capture.index %>].start_loc
    __<%= capture.index + 1 %>el = @pos_loc + __pcc_in.capts[<%= capture.index %>].end_loc
    <%-     end -%>
    <%-     if @capture_in_code -%>
    __<%= capture.index + 1 %>c = __pcc_in.capts[<%= capture.index %>]
    <%-     end -%>
    <%-   end -%>
    <%- %><%=   sstream.get_code_block(code.code, 4, @iname) -%>

    __pcc_vars[__pcc_index].value = ____ if __pcc_vars
  end

  <%-   end -%>
  <%- end -%>
  <%- @rules.each do |rule| -%>
  def evaluate_rule_<%= rule.name %>
    chunk = ThunkChunk.new
    chunk.pos = @cur
    <%- if @location -%>
    chunk.pos_loc = @cur_loc
    <%- end -%>
    debug { warn "#{ "  " * @level}EVAL    <%= rule.name %> #{chunk.pos} #{@buffer[chunk.pos..-1].inspect}" }
    @level += 1
    chunk.resize_captures(<%= rule.capts.length %>)
    <%-   if rule.vars.length > 0 -%>
    chunk.values = {}
    <%-   end -%>
    catch(0) do
      <%-   g = ::Packcr::Generator.new(rule, @ascii, @location, :rb) -%>
      <%-   r, code = g.generate_code_str(rule.expr, 0, 6, false) -%>
      <%- %><%= code -%>
      debug { warn "#{ "  " * @level}MATCH   <%= rule.name %> #{chunk.pos} #{@buffer[chunk.pos...@cur].inspect}" }
      return chunk
    ensure
      @level -= 1
    end
    <%-   if r != Packcr::CODE_REACH__ALWAYS_SUCCEED -%>
    debug { warn "#{ "  " * @level}NOMATCH <%= rule.name %> #{chunk.pos} #{@buffer[chunk.pos...@cur].inspect}" }
    return nil
    <%-   end -%>
  end

  <%- end -%>

  def apply_rule(rule, thunks, values, index)
    pos = @pos + @cur
    <%- if @location -%>
    p_loc = @pos_loc + @cur_loc
    <%- end -%>
    a = @lrtable.get_answer(pos, rule)
    h = @lrtable.get_head(pos)

    if h && !a && rule != h.rule_name && !h.invol[rule]
      return false
    end

    if h&.eval&.delete(rule)
      c = public_send(rule)
      a = LrAnswer.new(:chunk, @pos + @cur<% if @location %>, @pos_loc + @cur_loc<% end %>)
      a.chunk = c
    elsif a
      @cur = a.pos - @pos
      <%- if @location -%>
      @cur_loc = a.pos_loc - @pos_loc
      <%- end -%>
      type = a.type
      if type == :lr
        lr = a.lr
        head = lr.head
        if !head
          head = LrHead.new
          lr.head = head
          head.rule_name = rule
        end
        @lrstack.reverse_each do |lrentry|
          entry_head = lrentry.head
          lr = a.lr
          answer_head = lr.head
          if entry_head == answer_head
            break
          end
          lrentry.head = answer_head
          invol = answer_head.invol
          invol[lrentry.rule] = true
        end
        lr = a.lr
        c = lr.seed
      elsif type == :chunk
        c = a.chunk
      end
    else
      entry = LrEntry.new
      entry.rule = rule
      @lrstack.push(entry)
      a = LrAnswer.new(:lr, pos<% if @location %>, p_loc<% end %>)
      a.lr = entry
      @lrtable.set_answer(pos, rule, a)
      c = public_send(rule)
      @lrstack.pop
      a.pos = @pos + @cur
      <%- if @location -%>
      a.pos_loc = @pos_loc + @cur_loc
      <%- end -%>
      if !entry.head
        a.set_chunk(c)
      else
        lr = a.lr
        entry.seed = c
        h = lr.head
        if h.rule_name != rule
          c = lr.seed
          a = LrAnswer.new(:chunk, @pos + @cur<% if @location %>, @pos_loc + @cur_loc<% end %>)
          a.chunk = c
        else
          seed = lr.seed
          a.set_chunk(seed)
          chunk = a.chunk
          if !chunk
            return nil
          end
          @lrtable.set_head(pos, h)
          while true
            @cur = pos - @pos
            <%- if @location -%>
            @cur_loc = p_loc - @pos_loc
            <%- end -%>
            h.invol_to_eval
            c = public_send(rule)
            if !c || @pos + @cur <= a.pos
              break
            end
            a.set_chunk(c)
            a.pos = @pos + @cur
            <%- if @location -%>
            a.pos_loc = @pos_loc + @cur_loc
            <%- end -%>
          end
          @lrtable.set_head(pos, nil)
          @cur = a.pos - @pos
          <%- if @location -%>
          @cur_loc = a.pos_loc - @pos_loc
          <%- end -%>
          c = a.chunk
        end
      end
    end

    if !c
      return false
    end
    values ||= @global_values
    t = ThunkNode.new(c.thunks, values, index)
    thunks << t
    return true
  end

  def do_action(thunks, values, index)
    thunks.each do |thunk|
      thunk.do_action(self, values, index)
    end
  end

  <%-   @location&.each do |code| -%>
  <%- %><%= sstream.get_code_block(code, 2, @iname) -%>
  <%-   end -%>

  class LrTable
    def initialize
      super
      @buf = {}
    end

    def clear
      @buf.clear
    end

    def set_head(index, head)
      entry = @buf[index] ||= LrTableEntry.new
      entry.head = head
    end

    def set_answer(index, rule_name, answer)
      entry = @buf[index] ||= LrTableEntry.new
      entry.memos[rule_name] = answer
    end

    def get_head(index)
      @buf[index]&.head
    end

    def get_answer(index, rule_name)
      entry = @buf[index]
      if !entry
        return nil
      end
      entry.memos[rule_name]
    end
  end

  class LrTableEntry
    attr_accessor :head, :memos

    def initialize
      @memos = {}
    end
  end

  class LrHead
    attr_accessor :rule_name, :invol, :eval

    def initialize
      @invol = {}
      @eval = {}
    end

    def invol_to_eval
      @eval.clear
      @invol.each do |k, v|
        @eval[k] = true
      end
    end
  end

  class ThunkChunk
    attr_accessor :thunks, :capts, :pos, :values
    <%- if @location -%>
    attr_accessor :pos_loc
    <%- end -%>

    def initialize
      super
      @thunks = []
      @capts = {}
      @pos = 0
      @values = {}
    end

    def resize_captures(len)
      len.times do |i|
        @capts[i] = Capture.new
      end
    end
  end

  class Thunk
  end

  class ThunkLeaf < Thunk
    attr_accessor :capt0, :capts, :value_refs, :action

    def initialize(action, capt0 = Capture.new, value_refs = {}, capts = {})
      @value_refs = value_refs
      @capts = capts
      @capt0 = capt0
      @action = action
    end

    def do_action(ctx, values, index)
      ctx.public_send(action, self, values, index)
    end
  end

  class ThunkNode < Thunk
    attr_accessor :thunks, :values, :index

    def initialize(thunks, values, index)
      @thunks = thunks
      @values = values
      @index = index
      values[index] ||= Value.new if values
    end

    def do_action(ctx, _values, _index)
      @thunks.each do |thunk|
        thunk.do_action(ctx, @values, @index)
      end
    end

    def clear
      @thunks.clear
    end
  end

  class LrEntry
    attr_accessor :rule, :head, :seed
  end

  class Capture
    attr_accessor :range_start, :range_end
    <%- if @location -%>
    attr_accessor :start_loc, :end_loc
    <%- end -%>

    def initialize(range_start = 0, range_end = 0<% if @location %>, start_loc = nil, end_loc = nil<% end%>)
      @range_start = range_start
      @range_end = range_end
      <%- if @location -%>
      @start_loc = start_loc || Location.new
      @end_loc = end_loc || Location.new
      <%- end -%>
    end

    def capture_string(buffer)
      @string ||= buffer[@range_start, @range_end - @range_start]
    end
  end

  class LrAnswer
    attr_accessor :lr, :chunk, :pos, :type
    <%- if @location -%>
    attr_accessor :pos_loc
    <%- end -%>

    def initialize(type, pos<% if @location %>, pos_loc<% end %>)
      @type = type
      @pos = pos
      <%- if @location -%>
      @pos_loc = pos_loc
      <%- end -%>
    end

    def set_chunk(chunk)
      a = LrAnswer.new(@type, @pos<% if @location %>, @pos_loc<% end %>)
      if @type == :lr
        a.lr = @lr
      elsif @type == :chunk
        a.chunk = @chunk
      end
      @type = :chunk
      @chunk = chunk
    end
  end

  class Value
    attr_accessor :value
  end
end
<%- if !@lsource.empty? -%>

<%-   @lsource.each do |code| -%>
<%=     sstream.get_code_block(code, 0, @iname) -%>
<%-   end -%>
<%- end -%>
