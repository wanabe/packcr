# A packrat parser generated by PackCR <%= Packcr::VERSION %>
<%- if !@source.empty? -%>

<%-   @source.each do |code| -%>
<%=     sstream.get_code_block(code, 0, @iname) -%>
<%-   end -%>
<%- end -%>

class <%= class_name %>
  def initialize(<% if @auxil_type %><%= auxil_type %>, <% end %>debug: false)
    <%- if @utf8 -%>
    @buffer = +""
    <%- else -%>
    @buffer = +"".b
    <%- end %>
    @pos = 0
    @cur = 0
    @level = 0
    @lrstack = []
    @thunk = ThunkNode.new([], nil, 0)
    @lrtable = LrTable.new
    @debug = debug
    @global_values = {}
    <%- if @location -%>
    @pos_loc = Location.new
    @cur_loc = Location.new
    <%- end -%>
    <%-   @init.each do |code| -%>
    <%- %><%= sstream.get_code_block(code, 4, @iname) -%>
    <%-   end -%>
  end

  def debug
    yield if @debug
  end

  def getc
    <%- if @utf8 -%>
    $stdin.getc
    <%- else -%>
    $stdin.getc&.b
    <%- end -%>
  end

  def refill_buffer(num, mode = nil)
    len = @buffer.length
    if len >= @cur + num
      return len - @cur
    end
    while len < @cur + num
      c = getc
      break if !c
      @buffer << c
      len = @buffer.length
    end
    return len - @cur
  end

  def commit_buffer
    @buffer = @buffer[@cur, @buffer.length - @cur]
    @pos += @cur
    @lrtable.clear
    @cur = 0
    <%- if @location -%>
    @pos_loc = @pos_loc + @cur_loc
    @cur_loc = Location.new
    <%- end -%>
  end

  def parse
    pos = @pos
    <%- if !@rules.empty? -%>
    if apply_rule(:evaluate_rule_<%= @rules[0].name %>, @thunk.thunks, nil, 0)
      @thunk.do_action(self, nil, 0)
    else
      raise SyntaxError, "can't parse"
    end
    commit_buffer
    <%- end -%>
    @thunk.clear
    refill_buffer(1) >= 1 && pos != @pos
  end

  def run
    nil while parse
  end

  <%- @rules.each do |rule| -%>
  <%-   rule.codes.each do |code| -%>
  def action_<%= rule.name %>_<%= code.index %>(__pcc_in, __pcc_vars, __pcc_index)
    ____ = (__pcc_vars[__pcc_index] ||= Value.new).value if __pcc_vars
    <%-   code.vars.each do |ref| -%>
    <%= ref.var %> = (__pcc_in.value_refs[<%= ref.index %>]  ||= Value.new).value
    <%-   end -%>
    __0 = __pcc_in.capt0.capture_string(@buffer)
    __0s = @pos + __pcc_in.capt0.range_start
    __0e = @pos + __pcc_in.capt0.range_end
    <%-   if @location -%>
    __0sl = @pos_loc + __pcc_in.capt0.start_loc
    __0el = @pos_loc + __pcc_in.capt0.end_loc
    <%-   end -%>
    <%-   if @capture_in_code -%>
    __0c = __pcc_in.capt0
    <%-   end -%>
    <%-   code.capts.each do |capture| -%>
    __<%= capture.index + 1 %> = __pcc_in.capts[<%= capture.index %>].capture_string(@buffer)
    __<%= capture.index + 1 %>s = @pos + __pcc_in.capts[<%= capture.index %>].range_start
    __<%= capture.index + 1 %>e = @pos + __pcc_in.capts[<%= capture.index %>].range_end
    <%-     if @location -%>
    __<%= capture.index + 1 %>sl = @pos_loc + __pcc_in.capts[<%= capture.index %>].start_loc
    __<%= capture.index + 1 %>el = @pos_loc + __pcc_in.capts[<%= capture.index %>].end_loc
    <%-     end -%>
    <%-     if @capture_in_code -%>
    __<%= capture.index + 1 %>c = __pcc_in.capts[<%= capture.index %>]
    <%-     end -%>
    <%-   end -%>
    <%- %><%=   sstream.get_code_block(code.code, 4, @iname) -%>

    __pcc_vars[__pcc_index].value = ____ if __pcc_vars
  end

  <%-   end -%>
  <%- end -%>
  <%- @rules.each do |rule| -%>
  def evaluate_rule_<%= rule.name %>
    chunk = ThunkChunk.new
    chunk.pos = @cur
    <%- if @location -%>
    chunk.pos_loc = @cur_loc
    <%- end -%>
    debug { warn "#{ "  " * @level}EVAL    <%= rule.name %> #{chunk.pos} #{@buffer[chunk.pos..-1].inspect}" }
    @level += 1
    chunk.resize_captures(<%= rule.capts.length %>)
    <%-   if rule.vars.length > 0 -%>
    chunk.values = {}
    <%-   end -%>
    catch(0) do
      <%-   g = ::Packcr::Generator.new(rule, @ascii, @location, :rb) -%>
      <%-   r, code = g.generate_code_str(rule.expr, 0, 6, false) -%>
      <%- %><%= code -%>
      debug { warn "#{ "  " * @level}MATCH   <%= rule.name %> #{chunk.pos} #{@buffer[chunk.pos...@cur].inspect}" }
      return chunk
    ensure
      @level -= 1
    end
    <%-   if r != Packcr::CODE_REACH__ALWAYS_SUCCEED -%>
    debug { warn "#{ "  " * @level}NOMATCH <%= rule.name %> #{chunk.pos} #{@buffer[chunk.pos...@cur].inspect}" }
    return nil
    <%-   end -%>
  end

  <%- end -%>

  def rule_chunk(rule, thunks, values, index)
    pos = @pos + @cur
    <%- if @location -%>
    p_loc = @pos_loc + @cur_loc
    <%- end -%>
    answer = @lrtable.answers[pos, rule]
    head = @lrtable.heads[pos]

    if head
      if !answer && rule != head.rule_name && !head.invol[rule]
        return nil
      end
      if head.eval.delete(rule)
        return public_send(rule)
      end
    end

    if answer
      @cur = answer.pos - @pos
      <%- if @location -%>
      @cur_loc = answer.pos_loc - @pos_loc
      <%- end -%>
      if !answer.lr
        return answer.chunk
      end
      lr = answer.lr
      head = lr.head
      if !head
        head = LrHead.new
        lr.head = head
        head.rule_name = rule
      end
      @lrstack.reverse_each do |lrentry|
        entry_head = lrentry.head
        lr = answer.lr
        answer_head = lr.head
        if entry_head == answer_head
          break
        end
        lrentry.head = answer_head
        invol = answer_head.invol
        invol[lrentry.rule] = true
      end
      return answer.lr.seed
    end

    entry = LrEntry.new
    entry.rule = rule
    @lrstack.push(entry)
    answer = LrAnswer.new(entry, pos<% if @location %>, p_loc<% end %>)
    @lrtable.answers[pos, rule] = answer
    chunk = public_send(rule)
    @lrstack.pop
    answer.pos = @pos + @cur
    <%- if @location -%>
    answer.pos_loc = @pos_loc + @cur_loc
    <%- end -%>
    if !entry.head
      answer.chunk = chunk
      return chunk
    end

    lr = answer.lr
    entry.seed = chunk
    head = lr.head
    if head.rule_name != rule
      return lr.seed
    end

    seed = lr.seed
    answer.chunk = seed
    chunk = answer.chunk
    if !chunk
      return nil
    end
    @lrtable.heads[pos] = head
    while true
      @cur = pos - @pos
      <%- if @location -%>
      @cur_loc = p_loc - @pos_loc
      <%- end -%>
      head.invol_to_eval
      chunk = public_send(rule)
      if !chunk || @pos + @cur <= answer.pos
        break
      end
      answer.chunk = chunk
      answer.pos = @pos + @cur
      <%- if @location -%>
      answer.pos_loc = @pos_loc + @cur_loc
      <%- end -%>
    end
    @lrtable.heads[pos] = nil
    @cur = answer.pos - @pos
    <%- if @location -%>
    @cur_loc = answer.pos_loc - @pos_loc
    <%- end -%>
    answer.chunk
  end

  def apply_rule(rule, thunks, values, index)
    chunk = rule_chunk(rule, thunks, values, index)
    if !chunk
      return false
    end
    values ||= @global_values
    thunk = ThunkNode.new(chunk.thunks, values, index)
    thunks << thunk
    return true
  end

  def do_action(thunks, values, index)
    thunks.each do |thunk|
      thunk.do_action(self, values, index)
    end
  end

  <%-   @location&.each do |code| -%>
  <%- %><%= sstream.get_code_block(code, 2, @iname) -%>
  <%-   end -%>

  class LrTable
    attr_reader :heads, :answers

    def initialize
      @heads = {}
      @answers = LrAnswerTable.new
    end

    def clear
      @heads.clear
      @answers.clear
    end
  end

  class LrAnswerTable
    def initialize
      @answers = {}
    end

    def clear
      @answers.clear
    end

    def []=(index, rule_name, answer)
      entry = @answers[index] ||= {}
      entry[rule_name] = answer
    end

    def [](index, rule_name)
      @answers.dig(index, rule_name)
    end
  end

  class LrHead
    attr_accessor :rule_name, :invol, :eval

    def initialize
      @invol = {}
      @eval = {}
    end

    def invol_to_eval
      @eval.clear
      @invol.each do |k, v|
        @eval[k] = true
      end
    end
  end

  class ThunkChunk
    attr_accessor :thunks, :capts, :pos, :values
    <%- if @location -%>
    attr_accessor :pos_loc
    <%- end -%>

    def initialize
      super
      @thunks = []
      @capts = {}
      @pos = 0
      @values = {}
    end

    def resize_captures(len)
      len.times do |i|
        @capts[i] = Capture.new
      end
    end
  end

  class Thunk
  end

  class ThunkLeaf < Thunk
    attr_accessor :capt0, :capts, :value_refs, :action

    def initialize(action, capt0 = Capture.new, value_refs = {}, capts = {})
      @value_refs = value_refs
      @capts = capts
      @capt0 = capt0
      @action = action
    end

    def do_action(ctx, values, index)
      ctx.public_send(action, self, values, index)
    end
  end

  class ThunkNode < Thunk
    attr_accessor :thunks, :values, :index

    def initialize(thunks, values, index)
      @thunks = thunks
      @values = values
      @index = index
      values[index] ||= Value.new if values
    end

    def do_action(ctx, _values, _index)
      @thunks.each do |thunk|
        thunk.do_action(ctx, @values, @index)
      end
    end

    def clear
      @thunks.clear
    end
  end

  class LrEntry
    attr_accessor :rule, :head, :seed
  end

  class Capture
    attr_accessor :range_start, :range_end
    <%- if @location -%>
    attr_accessor :start_loc, :end_loc
    <%- end -%>

    def initialize(range_start = 0, range_end = 0<% if @location %>, start_loc = nil, end_loc = nil<% end%>)
      @range_start = range_start
      @range_end = range_end
      <%- if @location -%>
      @start_loc = start_loc || Location.new
      @end_loc = end_loc || Location.new
      <%- end -%>
    end

    def capture_string(buffer)
      @string ||= buffer[@range_start, @range_end - @range_start]
    end
  end

  class LrAnswer
    attr_accessor :lr, :chunk, :pos
    <%- if @location -%>
    attr_accessor :pos_loc
    <%- end -%>

    def initialize(lr, pos<% if @location %>, pos_loc<% end %>)
      @pos = pos
      <%- if @location -%>
      @pos_loc = pos_loc
      <%- end -%>
      @lr = lr
    end

    def chunk=(chunk)
      @lr = nil
      @chunk = chunk
    end
  end

  class Value
    attr_accessor :value
  end
end
<%- if !@lsource.empty? -%>

<%-   @lsource.each do |code| -%>
<%=     sstream.get_code_block(code, 0, @iname) -%>
<%-   end -%>
<%- end -%>
