module Kernel
  def getb
    $stdin.readbyte
  rescue EOFError
    -1
  end
end

class <%= class_name %>
  def initialize
    @buffer = +"".b
    @pos = 0
    @cur = 0
    @level = 0
    @lrstack = []
    @thunks = []
    @lrtable = LrTable.new
<%- if @location -%>
    @pos_loc = Location.new
    @cur_loc = Location.new
<%- end -%>
  end

  def refill_buffer(num)
    len = @buffer.length
    if len >= @cur + num
      return len - @cur
    end
    while len < @cur + num
        c = getb
        break if c < 0
        @buffer << c
        len = @buffer.length
    end
    return len - @cur
  end

  def commit_buffer
    @buffer = @buffer[@cur, @buffer.length - @cur]
    @pos += @cur;
    @lrtable.shift(@cur)
    @cur = 0
    <%- if @location -%>
    @pos_loc = @pos_loc + @cur_loc
    @cur_loc = Location.new
    <%- end -%>
  end

  class LrTable
    def initialize
      super
      @buf = []
    end

    def shift(count)
      @buf[0, count] = []
    end

    def resize(len)
      (@buf.length...len).each do |i|
        @buf << nil
      end
    end

    def set_head(index, head)
      if index >= @buf.length
        resize(index + 1)
      end
      entry = @buf[index] ||= LrTableEntry.new
      entry.head = head
    end

    def hold_head(index, head)
      if index >= @buf.length
        resize(index + 1)
      end
      entry = @buf[index] ||= LrTableEntry.new
      head.hold, entry.hold_h = entry.hold_h, head
    end

    def set_answer(index, rule_name, answer)
      if index >= @buf.length
        resize(index + 1)
      end
      entry = @buf[index] ||= LrTableEntry.new
      entry.memos[rule_name] = answer
    end

    def hold_answer(index, answer)
      if index >= @buf.length
        resize(index + 1)
      end
      entry = @buf[index] ||= LrTableEntry.new
      answer.hold, entry.hold_a = entry.hold_a, answer
    end

    def get_head(index)
      @buf[index]&.head
    end

    def get_answer(index, rule_name)
      if index >= @buf.length
        return nil
      end
      entry = @buf[index]
      if !entry
        return nil
      end
      memos = entry.memos
      memos[rule_name]
    end
  end

  class LrTableEntry
    attr_accessor :head, :hold_a, :hold_h, :memos

    def initialize
      @memos = {}
    end
  end
end

require_relative "<%= prefix%>.so"

class <%= class_name %>
  class ThunkChunk
    def initialize
      super
      @thunks = []
      @pos = 0
    end
  end

  class LrHead
    attr_accessor :hold
  end

  class LrAnswer
    attr_accessor :hold
  end
end
