module Kernel
  def getb
    $stdin.readbyte
  rescue EOFError
    -1
  end
end

class <%= class_name %>
  def initialize
    @buffer = +"".b
    @pos = 0
    @cur = 0
    @level = 0
    @lrstack = []
    @thunks = []
    @lrtable = LrTable.new
<%- if @location -%>
    @pos_loc = Location.new
    @cur_loc = Location.new
<%- end -%>
  end

  def refill_buffer(num)
    len = @buffer.length
    if len >= @cur + num
      return len - @cur
    end
    while len < @cur + num
        c = getb
        break if c < 0
        @buffer << c
        len = @buffer.length
    end
    return len - @cur
  end

  def commit_buffer
    @buffer = @buffer[@cur, @buffer.length - @cur]
    @pos += @cur;
    @lrtable.shift(@cur)
    @cur = 0
    <%- if @location -%>
    @pos_loc = @pos_loc + @cur_loc
    @cur_loc = Location.new
    <%- end -%>
  end

  def parse
    <%- if !@rules.empty? -%>
    if apply_rule(:evaluate_rule_<%= @rules[0].name %>, @thunks, nil, 0)
      do_action(@thunks, nil, 0)
    else
      raise SyntaxError, "can't parse"
    end
    commit_buffer
    <%- end -%>
    @thunks.clear
    refill_buffer(1) >= 1
  end

  def run
    nil while parse
  end

  class LrTable
    def initialize
      super
      @buf = []
    end

    def shift(count)
      @buf[0, count] = []
    end

    def resize(len)
      (@buf.length...len).each do |i|
        @buf << nil
      end
    end

    def set_head(index, head)
      if index >= @buf.length
        resize(index + 1)
      end
      entry = @buf[index] ||= LrTableEntry.new
      entry.head = head
    end

    def hold_head(index, head)
      if index >= @buf.length
        resize(index + 1)
      end
      entry = @buf[index] ||= LrTableEntry.new
      head.hold, entry.hold_h = entry.hold_h, head
    end

    def set_answer(index, rule_name, answer)
      if index >= @buf.length
        resize(index + 1)
      end
      entry = @buf[index] ||= LrTableEntry.new
      entry.memos[rule_name] = answer
    end

    def hold_answer(index, answer)
      if index >= @buf.length
        resize(index + 1)
      end
      entry = @buf[index] ||= LrTableEntry.new
      answer.hold, entry.hold_a = entry.hold_a, answer
    end

    def get_head(index)
      @buf[index]&.head
    end

    def get_answer(index, rule_name)
      if index >= @buf.length
        return nil
      end
      entry = @buf[index]
      if !entry
        return nil
      end
      memos = entry.memos
      memos[rule_name]
    end
  end

  class LrTableEntry
    attr_accessor :head, :hold_a, :hold_h, :memos

    def initialize
      @memos = {}
    end
  end

  class LrHead
    attr_accessor :hold

    def initialize
      @invol = {}
      @eval = {}
    end

    def invol_to_eval
      @eval.clear
      @invol.each do |k, v|
        @eval[k] = true
      end
    end
  end

  class ThunkChunk
    def initialize
      super
      @thunks = []
      @capts = []
      @pos = 0
      @values = []
    end

    def resize_captures(len)
      (@capts.length...len).each do |i|
        @capts << Capture.new
      end
    end
  end

  class Thunk
  end

  class ThunkLeaf < Thunk
    def initialize(action)
      @type = :leaf
      @value_refs = []
      @capts = []
      @capt0 = Capture.new
      @action = action
    end
  end

  class ThunkNode < Thunk
    def initialize(thunks, values, index)
      @type = :node
      @thunks = thunks
      @values = values
      @index = index
    end
  end

  class LrEntry
  end

  class Capture
    def initialize
      @range_start = 0
      @range_end = 0
      <%- if @location -%>
      @start_loc = Location.new
      @end_loc = Location.new
      <%- end -%>
    end
  end
end

require_relative "<%= prefix%>.so"

class <%= class_name %>
  class LrAnswer
    attr_accessor :hold
  end
end
