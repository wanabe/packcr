# A packrat parser generated by PackCR <%= Packcr::VERSION %>
<%- if !code(:source).empty? -%>

<%-   code(:source).each do |code| -%>
<%=     stream.get_code_block(code, 0, @iname) -%>
<%-   end -%>
<%- end -%>

class <%= class_name %>
  def initialize(<% if @auxil_type %><%= auxil_type %>, <% end %>debug: false)
    <%- if @utf8 -%>
    @buffer = +""
    <%- else -%>
    @buffer = +"".b
    <%- end %>
    @buffer_start_position = 0
    @position_offset = 0
    @level = 0
    @lrstack = []
    @thunk = ThunkNode.new([], nil, 0)
    @heads = {}
    @memos = LrMemoTable.new
    @debug = debug
    @global_values = {}
    <%- if @location -%>
    @buffer_start_position_loc = Location.new
    @position_offset_loc = Location.new
    <%- end -%>
    <%- code(:init).each do |code| -%>
    <%- %><%= stream.get_code_block(code, 4, @iname) -%>
    <%- end -%>
  end

  def debug
    yield if @debug
  end

  def getc
    <%- if @utf8 -%>
    $stdin.getc
    <%- else -%>
    $stdin.getc&.b
    <%- end -%>
  end

  def refill_buffer(num, mode = nil)
    len = @buffer.length
    if len >= @position_offset + num
      return len - @position_offset
    end
    while len < @position_offset + num
      c = getc
      break if !c
      @buffer << c
      len = @buffer.length
    end
    return len - @position_offset
  end

  def commit_buffer
    @buffer = @buffer[@position_offset, @buffer.length - @position_offset]
    @buffer_start_position += @position_offset
    @heads.clear
    @memos.clear
    @position_offset = 0
    <%- if @location -%>
    @buffer_start_position_loc = @buffer_start_position_loc + @position_offset_loc
    @position_offset_loc = Location.new
    <%- end -%>
  end

  def parse
    pos = @buffer_start_position
    <%- if !@root.rules.empty? -%>
    if apply_rule(:evaluate_rule_<%= @root.rules[0].name %>, @thunk.thunks, nil, 0)
      @thunk.do_action(self, nil, 0)
    else
      raise SyntaxError, "can't parse"
    end
    commit_buffer
    <%- end -%>
    @thunk.clear
    refill_buffer(1) >= 1 && pos != @buffer_start_position
  end

  def run
    nil while parse
  end

  <%- @root.rules.each do |rule| -%>
  <%-   rule.codes.each do |code| -%>
  def action_<%= rule.name %>_<%= code.index %>(__pcc_in, __pcc_vars, __pcc_index)
    ____ = (__pcc_vars[__pcc_index] ||= Value.new).value if __pcc_vars
    <%-   code.vars.each do |ref| -%>
    <%= ref.var %> = (__pcc_in.value_refs[<%= ref.index %>]  ||= Value.new).value
    <%-   end -%>
    __0 = __pcc_in.capt0.capture_string(@buffer)
    __0s = @buffer_start_position + __pcc_in.capt0.range_start
    __0e = @buffer_start_position + __pcc_in.capt0.range_end
    <%-   if @location -%>
    __0sl = @buffer_start_position_loc + __pcc_in.capt0.start_loc
    __0el = @buffer_start_position_loc + __pcc_in.capt0.end_loc
    <%-   end -%>
    <%-   if @capture_in_code -%>
    __0c = __pcc_in.capt0
    <%-   end -%>
    <%-   code.capts.each do |capture| -%>
    __<%= capture.index + 1 %> = __pcc_in.capts[<%= capture.index %>].capture_string(@buffer)
    __<%= capture.index + 1 %>s = @buffer_start_position + __pcc_in.capts[<%= capture.index %>].range_start
    __<%= capture.index + 1 %>e = @buffer_start_position + __pcc_in.capts[<%= capture.index %>].range_end
    <%-     if @location -%>
    __<%= capture.index + 1 %>sl = @buffer_start_position_loc + __pcc_in.capts[<%= capture.index %>].start_loc
    __<%= capture.index + 1 %>el = @buffer_start_position_loc + __pcc_in.capts[<%= capture.index %>].end_loc
    <%-     end -%>
    <%-     if @capture_in_code -%>
    __<%= capture.index + 1 %>c = __pcc_in.capts[<%= capture.index %>]
    <%-     end -%>
    <%-   end -%>
    <%- %><%=   stream.get_code_block(code.code, 4, @iname) -%>

    __pcc_vars[__pcc_index].value = ____ if __pcc_vars
  end

  <%-   end -%>
  <%- end -%>
  <%- @root.rules.each do |rule| -%>
  def evaluate_rule_<%= rule.name %>
    answer = ThunkChunk.new
    answer.pos = @position_offset
    <%-   if @location -%>
    answer.pos_loc = @position_offset_loc
    <%-   end -%>
    <%-   gen = ::Packcr::Generator.new(rule, @ascii, @location, :rb) -%>
    <%-   -%><%= gen.generate_code(rule, 0, 4, false) -%>
  end

  <%- end -%>
  def setup_lr(rule, lr)
    lr.head ||= LrHead.new(rule)
    @lrstack.reverse_each do |lrentry|
      if lrentry.head == lr.head
        break
      end
      lrentry.head = lr.head
      lr.head.involved_set[lrentry.rule] = true
    end
  end

  def grow_lr(rule, memo, head, offset<% if @location %>, offset_loc<% end %>)
    @heads[offset] = head
    while true
      @position_offset = offset
      <%- if @location -%>
      @position_offset_loc = offset_loc
      <%- end -%>
      head.involved_set_to_eval_set
      answer = public_send(rule)
      if !answer || @position_offset <= memo.offset
        break
      end
      memo.answer = answer
      memo.offset = @position_offset
      <%- if @location -%>
      memo.offset_loc = @position_offset_loc
      <%- end -%>
    end
    @heads[offset] = nil
    @position_offset = memo.offset
    <%- if @location -%>
    @position_offset_loc = memo.offset_loc
    <%- end -%>
    memo.answer
  end

  def lr_answer(rule, memo, offset<% if @location %>, offset_loc<% end %>)
    head = memo.lr.head
    if head.rule_name != rule
      return memo.lr.seed
    end

    memo.answer = memo.lr.seed
    if !memo.answer
      return nil
    end
    grow_lr(rule, memo, head, offset<% if @location %>, offset_loc<% end %>)
  end

  def rule_answer(rule)
    offset = @position_offset
    <%- if @location -%>
    offset_loc = @position_offset_loc
    <%- end -%>
    memo = @memos[offset, rule]
    head = @heads[offset]

    if head
      if !memo && rule != head.rule_name && !head.involved_set[rule]
        return nil
      end
      if head.eval_set.delete(rule)
        return public_send(rule)
      end
    end

    if memo
      @position_offset = memo.offset
      <%- if @location -%>
      @position_offset_loc = memo.offset_loc
      <%- end -%>
      if !memo.lr
        return memo.answer
      end
      setup_lr(rule, memo.lr)
      return memo.lr.seed
    end

    lr = LrEntry.new
    lr.rule = rule
    @lrstack.push(lr)
    memo = LrMemo.new(lr, offset<% if @location %>, offset_loc<% end %>)
    @memos[offset, rule] = memo
    answer = public_send(rule)
    @lrstack.pop
    memo.offset = @position_offset
    <%- if @location -%>
    memo.offset_loc = @position_offset_loc
    <%- end -%>
    if !lr.head
      memo.answer = answer
      return answer
    end

    lr.seed = answer
    lr_answer(rule, memo, offset<% if @location %>, offset_loc<% end %>)
  end

  def apply_rule(rule, thunks, values, index)
    answer = rule_answer(rule)
    if !answer
      return false
    end
    values ||= @global_values
    thunks << ThunkNode.new(answer.thunks, values, index)
    return true
  end

  def do_action(thunks, values, index)
    thunks.each do |thunk|
      thunk.do_action(self, values, index)
    end
  end

  <%-   code(:location).each do |code| -%>
  <%- %><%= stream.get_code_block(code, 2, @iname) -%>

  <%-   end -%>
  class LrMemoTable
    def initialize
      @memos = {}
    end

    def clear
      @memos.clear
    end

    def []=(index, rule_name, memo)
      entry = @memos[index] ||= {}
      entry[rule_name] = memo
    end

    def [](index, rule_name)
      @memos.dig(index, rule_name)
    end
  end

  class LrHead
    attr_accessor :rule_name, :involved_set, :eval_set

    def initialize(rule_name)
      @rule_name = rule_name
      @involved_set = {}
      @eval_set = {}
    end

    def involved_set_to_eval_set
      @eval_set.clear
      @involved_set.each do |k, v|
        @eval_set[k] = true
      end
    end
  end

  class ThunkChunk
    attr_accessor :thunks, :capts, :pos, :values
    <%- if @location -%>
    attr_accessor :pos_loc
    <%- end -%>

    def initialize
      super
      @thunks = []
      @capts = {}
      @pos = 0
      @values = {}
    end

    def resize_captures(len)
      len.times do |i|
        @capts[i] = Capture.new
      end
    end
  end

  class Thunk
  end

  class ThunkLeaf < Thunk
    attr_accessor :capt0, :capts, :value_refs, :action

    def initialize(action, capt0 = Capture.new, value_refs = {}, capts = {})
      @value_refs = value_refs
      @capts = capts
      @capt0 = capt0
      @action = action
    end

    def do_action(ctx, values, index)
      ctx.public_send(action, self, values, index)
    end
  end

  class ThunkNode < Thunk
    attr_accessor :thunks, :values, :index

    def initialize(thunks, values, index)
      @thunks = thunks
      @values = values
      @index = index
      values[index] ||= Value.new if values
    end

    def do_action(ctx, _values, _index)
      @thunks.each do |thunk|
        thunk.do_action(ctx, @values, @index)
      end
    end

    def clear
      @thunks.clear
    end
  end

  class LrEntry
    attr_accessor :rule, :head, :seed
  end

  class Capture
    attr_accessor :range_start, :range_end
    <%- if @location -%>
    attr_accessor :start_loc, :end_loc
    <%- end -%>

    def initialize(range_start = 0, range_end = 0<% if @location %>, start_loc = nil, end_loc = nil<% end%>)
      @range_start = range_start
      @range_end = range_end
      <%- if @location -%>
      @start_loc = start_loc || Location.new
      @end_loc = end_loc || Location.new
      <%- end -%>
    end

    def capture_string(buffer)
      @string ||= buffer[@range_start, @range_end - @range_start]
    end
  end

  class LrMemo
    attr_accessor :lr, :answer, :offset
    <%- if @location -%>
    attr_accessor :offset_loc
    <%- end -%>

    def initialize(lr, offset<% if @location %>, offset_loc<% end %>)
      @offset = offset
      <%- if @location -%>
      @offset_loc = offset_loc
      <%- end -%>
      @lr = lr
    end

    def answer=(answer)
      @lr = nil
      @answer = answer
    end
  end

  class Value
    attr_accessor :value
  end
end
<%- if !code(:lsource).empty? -%>

<%-   code(:lsource).each do |code| -%>
<%=     stream.get_code_block(code, 0, @iname) -%>
<%-   end -%>
<%- end -%>
