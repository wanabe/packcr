# A packrat parser generated by PackCR <%= Packcr::VERSION %>

module Kernel
  def getb
    $stdin.readbyte
  rescue EOFError
    -1
  end
end

class <%= class_name %>
  def initialize
    @buffer = +"".b
    @pos = 0
    @cur = 0
    @level = 0
    @lrstack = []
    @thunks = []
    @lrtable = LrTable.new
<%- if @location -%>
    @pos_loc = Location.new
    @cur_loc = Location.new
<%- end -%>
  end

  def refill_buffer(num)
    len = @buffer.length
    if len >= @cur + num
      return len - @cur
    end
    while len < @cur + num
        c = getb
        break if c < 0
        @buffer << c
        len = @buffer.length
    end
    return len - @cur
  end

  def commit_buffer
    @buffer = @buffer[@cur, @buffer.length - @cur]
    @pos += @cur;
    @lrtable.shift(@cur)
    @cur = 0
    <%- if @location -%>
    @pos_loc = @pos_loc + @cur_loc
    @cur_loc = Location.new
    <%- end -%>
  end

  def parse
    <%- if !@rules.empty? -%>
    if apply_rule(:evaluate_rule_<%= @rules[0].name %>, @thunks, nil, 0)
      do_action(@thunks, nil, 0)
    else
      raise SyntaxError, "can't parse"
    end
    commit_buffer
    <%- end -%>
    @thunks.clear
    refill_buffer(1) >= 1
  end

  def run
    nil while parse
  end

  <%- @rules.each do |rule| -%>
  <%-   rule.codes.each do |code| -%>
  def action_<%= rule.name %>_<%= code.index %>(__pcc_in, __pcc_vars, __pcc_index)
    ____ = (__pcc_vars[__pcc_index] ||= Value.new).value if __pcc_vars
    <%-   code.vars.each do |ref| -%>
    <%= ref.var %> = (__pcc_in.value_refs[<%= ref.index %>]  ||= Value.new).value
    <%-   end -%>
    __0 = __pcc_in.capt0.capture_string(@buffer)
    __0s = @pos + __pcc_in.capt0.range_start
    __0e = @pos + __pcc_in.capt0.range_end
    <%-   code.capts.each do |capture| -%>
    __<%= capture.index + 1 %> = __pcc_in.capts[<%= capture.index %>].capture_string(@buffer)
    __<%= capture.index + 1 %>s = @pos + __pcc_in.capts[<%= capture.index %>].range_start
    __<%= capture.index + 1 %>e = @pos + __pcc_in.capts[<%= capture.index %>].range_end
    <%-     if @location -%>
    __<%= capture.index + 1 %>sl = @pos_loc + __pcc_in.capts[<%= capture.index %>].start_loc
    __<%= capture.index + 1 %>el = @pos_loc + __pcc_in.capts[<%= capture.index %>].end_loc
    <%-     end -%>
    <%-   end -%>
    <%=   sstream.get_code_block(code.code, 4, @iname) -%>

    __pcc_vars[__pcc_index].value = ____ if __pcc_vars
  end

  def do_action(thunks, values, index)
    thunks.each do |thunk|
      case thunk.type
      when :leaf
        public_send(thunk.action, thunk, values, index)
      when :node
        do_action(thunk.thunks, thunk.values, thunk.index)
      end
    end
  end

  <%-   end -%>
  <%- end -%>
  class LrTable
    def initialize
      super
      @buf = []
    end

    def shift(count)
      @buf[0, count] = []
    end

    def resize(len)
      (@buf.length...len).each do |i|
        @buf << nil
      end
    end

    def set_head(index, head)
      if index >= @buf.length
        resize(index + 1)
      end
      entry = @buf[index] ||= LrTableEntry.new
      entry.head = head
    end

    def hold_head(index, head)
      if index >= @buf.length
        resize(index + 1)
      end
      entry = @buf[index] ||= LrTableEntry.new
      head.hold, entry.hold_h = entry.hold_h, head
    end

    def set_answer(index, rule_name, answer)
      if index >= @buf.length
        resize(index + 1)
      end
      entry = @buf[index] ||= LrTableEntry.new
      entry.memos[rule_name] = answer
    end

    def hold_answer(index, answer)
      if index >= @buf.length
        resize(index + 1)
      end
      entry = @buf[index] ||= LrTableEntry.new
      answer.hold, entry.hold_a = entry.hold_a, answer
    end

    def get_head(index)
      @buf[index]&.head
    end

    def get_answer(index, rule_name)
      if index >= @buf.length
        return nil
      end
      entry = @buf[index]
      if !entry
        return nil
      end
      memos = entry.memos
      memos[rule_name]
    end
  end

  class LrTableEntry
    attr_accessor :head, :hold_a, :hold_h, :memos

    def initialize
      @memos = {}
    end
  end

  class LrHead
    attr_accessor :hold

    def initialize
      @invol = {}
      @eval = {}
    end

    def invol_to_eval
      @eval.clear
      @invol.each do |k, v|
        @eval[k] = true
      end
    end
  end

  class ThunkChunk
    def initialize
      super
      @thunks = []
      @capts = []
      @pos = 0
      @values = []
    end

    def resize_captures(len)
      (@capts.length...len).each do |i|
        @capts << Capture.new
      end
    end
  end

  class Thunk
    attr_accessor :type
  end

  class ThunkLeaf < Thunk
    attr_accessor :capt0, :capts, :value_refs, :action

    def initialize(action)
      @type = :leaf
      @value_refs = []
      @capts = []
      @capt0 = Capture.new
      @action = action
    end
  end

  class ThunkNode < Thunk
    attr_accessor :thunks, :values, :index

    def initialize(thunks, values, index)
      @type = :node
      @thunks = thunks
      @values = values
      @index = index
      values[index] ||= Value.new if values
    end
  end

  class LrEntry
  end

  class Capture
    attr_accessor :range_start, :range_end

    def initialize
      @range_start = 0
      @range_end = 0
      <%- if @location -%>
      @start_loc = Location.new
      @end_loc = Location.new
      <%- end -%>
    end

    def capture_string(buffer)
      @string ||= buffer[@range_start, @range_end - @range_start]
    end
  end

  class LrAnswer
    attr_accessor :hold, :lr, :chunk

    def initialize(type, pos<% if @location %>, pos_loc<% end %>)
      @type = type
      @pos = pos
      <%- if @location -%>
      @pos_loc = pos_loc
      <%- end -%>
    end

    def set_chunk(chunk)
      a = LrAnswer.new(@type, @pos<% if @location %>, @pos_loc<% end %>)
      if @type == :lr
        a.lr = @lr
      elsif @type == :chunk
        a.chunk = @chunk
      end
      a.hold = @hold
      @hold = a
      @type = :chunk
      @chunk = chunk
    end
  end

  class Value
    attr_accessor :value
  end
end

require_relative "<%= prefix%>.so"
