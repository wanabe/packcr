# A packrat parser generated by PackCR <%= Packcr::VERSION %>

class <%= class_name %>
  def initialize(debug: false)
    <%- if @utf8 -%>
    @buffer = +""
    <%- else -%>
    @buffer = +"".b
    <%- end %>
    @pos = 0
    @cur = 0
    @level = 0
    @lrstack = []
    @thunk = ThunkNode.new([], nil, 0)
    @lrtable = LrTable.new
    @debug = debug
    <%- if @location -%>
    @pos_loc = Location.new
    @cur_loc = Location.new
    <%- end -%>
    <%-   @init.each do |code| -%>
    <%- %><%= sstream.get_code_block(code, 4, @iname) -%>
    <%-   end -%>
  end

  def debug
    yield if @debug
  end

  def refill_buffer(num, mode = nil)
    len = @buffer.length
    if len >= @cur + num
      return len - @cur
    end
    while len < @cur + num
      <%- if @utf8 -%>
      c = $stdin.getc
      <%- else -%>
      if mode == :utf8
        c = $stdin.getc&.b
      else
        begin
          c = $stdin.readbyte.chr
        rescue EOFError
          c = nil
        end
      end
      <%- end -%>
      break if !c
      @buffer << c
      len = @buffer.length
    end
    return len - @cur
  end

  def commit_buffer
    @buffer = @buffer[@cur, @buffer.length - @cur]
    @pos += @cur
    @lrtable.shift(@cur)
    @cur = 0
    <%- if @location -%>
    @pos_loc = @pos_loc + @cur_loc
    @cur_loc = Location.new
    <%- end -%>
  end

  def parse
    <%- if !@rules.empty? -%>
    if apply_rule(:evaluate_rule_<%= @rules[0].name %>, @thunk.thunks, nil, 0)
      @thunk.do_action(self, nil, 0)
    else
      raise SyntaxError, "can't parse"
    end
    commit_buffer
    <%- end -%>
    @thunk.clear
    refill_buffer(1) >= 1
  end

  def run
    nil while parse
  end

  <%- @rules.each do |rule| -%>
  <%-   rule.codes.each do |code| -%>
  def action_<%= rule.name %>_<%= code.index %>(__pcc_in, __pcc_vars, __pcc_index)
    ____ = (__pcc_vars[__pcc_index] ||= Value.new).value if __pcc_vars
    <%-   code.vars.each do |ref| -%>
    <%= ref.var %> = (__pcc_in.value_refs[<%= ref.index %>]  ||= Value.new).value
    <%-   end -%>
    __0 = __pcc_in.capt0.capture_string(@buffer)
    __0s = @pos + __pcc_in.capt0.range_start
    __0e = @pos + __pcc_in.capt0.range_end
    <%-     if @location -%>
    __0sl = @pos_loc + __pcc_in.capt0.start_loc
    __0el = @pos_loc + __pcc_in.capt0.end_loc
    <%-     end -%>
    <%-   code.capts.each do |capture| -%>
    __<%= capture.index + 1 %> = __pcc_in.capts[<%= capture.index %>].capture_string(@buffer)
    __<%= capture.index + 1 %>s = @pos + __pcc_in.capts[<%= capture.index %>].range_start
    __<%= capture.index + 1 %>e = @pos + __pcc_in.capts[<%= capture.index %>].range_end
    <%-     if @location -%>
    __<%= capture.index + 1 %>sl = @pos_loc + __pcc_in.capts[<%= capture.index %>].start_loc
    __<%= capture.index + 1 %>el = @pos_loc + __pcc_in.capts[<%= capture.index %>].end_loc
    <%-     end -%>
    <%-   end -%>
    <%- %><%=   sstream.get_code_block(code.code, 4, @iname) -%>

    __pcc_vars[__pcc_index].value = ____ if __pcc_vars
  end

  <%-   end -%>
  <%- end -%>
  <%- @rules.each do |node| -%>
  def evaluate_rule_<%= node.name %>
    chunk = ThunkChunk.new
    chunk.pos = @cur
    <%- if @location -%>
    chunk.pos_loc = @cur_loc
    <%- end -%>
    debug { warn "#{ "  " * @level}EVAL    <%= node.name %> #{chunk.pos} #{@buffer[chunk.pos..-1].inspect}" }
    @level += 1
    chunk.resize_captures(<%= node.capts.length %>)
    <%-   if node.vars.length > 0 -%>
    chunk.values = []
    <%-   end -%>
    catch(0) do
      <%-   g = ::Packcr::Generator.new(node, @ascii, @location, :rb) -%>
      <%-   r, code = g.generate_code_str(node.expr, 0, 6, false) -%>
      <%- %><%= code -%>
      debug { warn "#{ "  " * @level}MATCH   <%= node.name %> #{chunk.pos} #{@buffer[chunk.pos...@cur].inspect}" }
      return chunk
    ensure
      @level -= 1
    end
    <%-   if r != Packcr::CODE_REACH__ALWAYS_SUCCEED -%>
    debug { warn "#{ "  " * @level}NOMATCH <%= node.name %> #{chunk.pos} #{@buffer[chunk.pos...@cur].inspect}" }
    return nil
    <%-   end -%>
  end

  <%- end -%>

  def apply_rule(rule, thunks, values, index)
    pos = @pos + @cur
    <%- if @location -%>
    p_loc = @pos_loc + @cur_loc
    <%- end -%>
    b = true
    a = @lrtable.get_answer(pos, rule)
    h = @lrtable.get_head(pos)
    if h
      invol = h.invol
      if !a && rule != h.rule_name && !invol[rule]
        b = false
        c = nil
      else
        if h.eval.delete(rule)
          c = public_send(rule)
          b = false
          a = LrAnswer.new(:chunk, @pos + @cur<% if @location %>, @pos_loc + @cur_loc<% end %>)
          a.chunk = c
          @lrtable.hold_answer(pos, a)
        end
      end
    end

    if b
      if a
        @cur = a.pos - @pos
        <%- if @location -%>
        @cur_loc = a.pos_loc - @pos_loc
        <%- end -%>
        type = a.type
        if type == :lr
          lr = a.lr
          head = lr.head
          if !head
            head = LrHead.new
            lr.head = head
            head.rule_name = rule
            @lrtable.hold_head(pos, head)
          end
          @lrstack.reverse_each do |lrentry|
            entry_head = lrentry.head
            lr = a.lr
            answer_head = lr.head
            if entry_head == answer_head
              break
            end
            lrentry.head = answer_head
            invol = answer_head.invol
            invol[lrentry.rule] = true
          end
          lr = a.lr
          c = lr.seed
        elsif type == :chunk
          c = a.chunk
        end
      else
        entry = LrEntry.new
        entry.rule = rule
        @lrstack.push(entry)
        a = LrAnswer.new(:lr, pos<% if @location %>, p_loc<% end %>)
        a.lr = entry
        @lrtable.set_answer(pos, rule, a)
        c = public_send(rule)
        @lrstack.pop
        a.pos = @pos + @cur
        <%- if @location -%>
        a.pos_loc = @pos_loc + @cur_loc
        <%- end -%>
        if !entry.head
          a.set_chunk(c)
        else
          lr = a.lr
          entry.seed = c
          h = lr.head
          if h.rule_name != rule
            c = lr.seed
            a = LrAnswer.new(:chunk, @pos + @cur<% if @location %>, @pos_loc + @cur_loc<% end %>)
            a.chunk = c
            @lrtable.hold_answer(pos, a)
          else
            seed = lr.seed
            a.set_chunk(seed)
            chunk = a.chunk
            if !chunk
              c = nil
            else
              @lrtable.set_head(pos, h)
              while true
                @cur = pos - @pos
                <%- if @location -%>
                @cur_loc = p_loc - @pos_loc
                <%- end -%>
                h.invol_to_eval
                c = public_send(rule)
                if !c || @pos + @cur <= a.pos
                  break
                end
                a.set_chunk(c)
                a.pos = @pos + @cur
                <%- if @location -%>
                a.pos_loc = @pos_loc + @cur_loc
                <%- end -%>
              end
              @lrtable.set_head(pos, nil)
              @cur = a.pos - @pos
              <%- if @location -%>
              @cur_loc = a.pos_loc - @pos_loc
              <%- end -%>
              c = a.chunk
            end
          end
        end
      end
    end

    if !c
      return false
    end
    t = ThunkNode.new(c.thunks, values, index)
    thunks << t
    return true
  end

  def do_action(thunks, values, index)
    thunks.each do |thunk|
      thunk.do_action(self, values, index)
    end
  end

  <%-   @location&.each do |code| -%>
  <%- %><%= sstream.get_code_block(code, 2, @iname) -%>
  <%-   end -%>

  class LrTable
    def initialize
      super
      @buf = []
    end

    def shift(count)
      @buf[0, count] = []
    end

    def resize(len)
      (@buf.length...len).each do |i|
        @buf << nil
      end
    end

    def set_head(index, head)
      if index >= @buf.length
        resize(index + 1)
      end
      entry = @buf[index] ||= LrTableEntry.new
      entry.head = head
    end

    def hold_head(index, head)
      if index >= @buf.length
        resize(index + 1)
      end
      entry = @buf[index] ||= LrTableEntry.new
      head.hold, entry.hold_h = entry.hold_h, head
    end

    def set_answer(index, rule_name, answer)
      if index >= @buf.length
        resize(index + 1)
      end
      entry = @buf[index] ||= LrTableEntry.new
      entry.memos[rule_name] = answer
    end

    def hold_answer(index, answer)
      if index >= @buf.length
        resize(index + 1)
      end
      entry = @buf[index] ||= LrTableEntry.new
      answer.hold, entry.hold_a = entry.hold_a, answer
    end

    def get_head(index)
      @buf[index]&.head
    end

    def get_answer(index, rule_name)
      if index >= @buf.length
        return nil
      end
      entry = @buf[index]
      if !entry
        return nil
      end
      memos = entry.memos
      memos[rule_name]
    end
  end

  class LrTableEntry
    attr_accessor :head, :hold_a, :hold_h, :memos

    def initialize
      @memos = {}
    end
  end

  class LrHead
    attr_accessor :hold, :rule_name, :invol, :eval

    def initialize
      @invol = {}
      @eval = {}
    end

    def invol_to_eval
      @eval.clear
      @invol.each do |k, v|
        @eval[k] = true
      end
    end
  end

  class ThunkChunk
    attr_accessor :thunks, :capts, :pos, :values
    <%- if @location -%>
    attr_accessor :pos_loc
    <%- end -%>

    def initialize
      super
      @thunks = []
      @capts = []
      @pos = 0
      @values = []
    end

    def resize_captures(len)
      (@capts.length...len).each do |i|
        @capts << Capture.new
      end
    end
  end

  class Thunk
  end

  class ThunkLeaf < Thunk
    attr_accessor :capt0, :capts, :value_refs, :action

    def initialize(action)
      @value_refs = []
      @capts = []
      @capt0 = Capture.new
      @action = action
    end

    def do_action(ctx, values, index)
      ctx.public_send(action, self, values, index)
    end
  end

  class ThunkNode < Thunk
    attr_accessor :thunks, :values, :index

    def initialize(thunks, values, index)
      @thunks = thunks
      @values = values
      @index = index
      values[index] ||= Value.new if values
    end

    def do_action(ctx, _values, _index)
      @thunks.each do |thunk|
        thunk.do_action(ctx, @values, @index)
      end
    end

    def clear
      @thunks.clear
    end
  end

  class LrEntry
    attr_accessor :rule, :head, :seed
  end

  class Capture
    attr_accessor :range_start, :range_end
    <%- if @location -%>
    attr_accessor :start_loc, :end_loc
    <%- end -%>

    def initialize(range_start = 0, range_end = 0<% if @location %>, start_loc = nil, end_loc = nil<% end%>)
      @range_start = range_start
      @range_end = range_end
      <%- if @location -%>
      @start_loc = start_loc || Location.new
      @end_loc = end_loc || Location.new
      <%- end -%>
    end

    def capture_string(buffer)
      @string ||= buffer[@range_start, @range_end - @range_start]
    end
  end

  class LrAnswer
    attr_accessor :hold, :lr, :chunk, :pos, :type
    <%- if @location -%>
    attr_accessor :pos_loc
    <%- end -%>

    def initialize(type, pos<% if @location %>, pos_loc<% end %>)
      @type = type
      @pos = pos
      <%- if @location -%>
      @pos_loc = pos_loc
      <%- end -%>
    end

    def set_chunk(chunk)
      a = LrAnswer.new(@type, @pos<% if @location %>, @pos_loc<% end %>)
      if @type == :lr
        a.lr = @lr
      elsif @type == :chunk
        a.chunk = @chunk
      end
      a.hold = @hold
      @hold = a
      @type = :chunk
      @chunk = chunk
    end
  end

  class Value
    attr_accessor :value
  end
end
<%- if !@lsource.empty? -%>

<%-   @lsource.each do |code| -%>
<%=     sstream.get_code_block(code, 0, @iname) -%>
<%-   end -%>
<%- end -%>
