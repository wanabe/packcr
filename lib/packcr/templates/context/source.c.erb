/* A packrat parser generated by PackCR <%= Packcr::VERSION %> */

<%- if !code_block(:esource).empty? -%>
<%-   code_block(:esource).each do |code| -%>
<%=     stream.get_code_block(code, 0, @iname) -%>
<%-   end -%>

<%- end -%>
#ifdef _MSC_VER
#undef _CRT_SECURE_NO_WARNINGS
#define _CRT_SECURE_NO_WARNINGS
#endif /* _MSC_VER */
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#ifndef _MSC_VER
#if defined __GNUC__ && defined _WIN32 /* MinGW */
#ifndef PACKCR_USE_SYSTEM_STRNLEN
#define strnlen(str, maxlen) packcr_strnlen(str, maxlen)
static size_t packcr_strnlen(const char *str, size_t maxlen) {
    size_t i;
    for (i = 0; i < maxlen && str[i]; i++);
    return i;
}
#endif /* !PACKCR_USE_SYSTEM_STRNLEN */
#endif /* defined __GNUC__ && defined _WIN32 */
#endif /* !_MSC_VER */

#include "<%= @hname %>"
<%- if !code_block(:location).empty? -%>

<%-   code_block(:location).each do |code| -%>
<%=     stream.get_code_block(code, 4, @iname) -%>
<%-   end -%>
<%- end -%>

<%- code_block(:source).each do |code| -%>
<%=   stream.get_code_block(code, 0, @iname) -%>
<%- end -%>
#if !defined __has_attribute || defined _MSC_VER
#define __attribute__(x)
#endif

#ifdef _MSC_VER
#define MARK_FUNC_AS_USED __pragma(warning(suppress:4505))
#else
#define MARK_FUNC_AS_USED __attribute__((__unused__))
#endif

#ifndef PACKCR_BUFFER_MIN_SIZE
#define PACKCR_BUFFER_MIN_SIZE 256
#endif /* !PACKCR_BUFFER_MIN_SIZE */

#ifndef PACKCR_ARRAY_MIN_SIZE
#define PACKCR_ARRAY_MIN_SIZE 2
#endif /* !PACKCR_ARRAY_MIN_SIZE */

#ifndef PACKCR_POOL_MIN_SIZE
#define PACKCR_POOL_MIN_SIZE 65536
#endif /* !PACKCR_POOL_MIN_SIZE */

#define PACKCR_DBG_EVALUATE 0
#define PACKCR_DBG_MATCH    1
#define PACKCR_DBG_NOMATCH  2

#define PACKCR_VOID_VALUE (~(size_t)0)

typedef enum packcr_bool_tag {
    PACKCR_FALSE = 0,
    PACKCR_TRUE
} packcr_bool_t;

typedef struct packcr_char_array_tag {
    char *buf;
    size_t max;
    size_t len;
} packcr_char_array_t;

typedef struct packcr_range_tag {
    size_t start;
    size_t end;
<%- if @location -%>
    packcr_location_t start_loc;
    packcr_location_t end_loc;
<%- end -%>
} packcr_range_t;

typedef <%= value_def %>packcr_value_t;

typedef <%= auxil_def %>packcr_auxil_t;

<% if prefix != "packcr" -%>
typedef <%= prefix%>_context_t packcr_context_t;

<% end -%>
typedef struct packcr_value_table_tag {
    packcr_value_t *buf;
    size_t max;
    size_t len;
} packcr_value_table_t;

typedef struct packcr_value_refer_table_tag {
    packcr_value_t **buf;
    size_t max;
    size_t len;
} packcr_value_refer_table_t;

typedef struct packcr_capture_tag {
    packcr_range_t range;
    char *string; /* mutable */
} packcr_capture_t;

typedef struct packcr_capture_table_tag {
    packcr_capture_t *buf;
    size_t max;
    size_t len;
} packcr_capture_table_t;

typedef struct packcr_capture_const_table_tag {
    const packcr_capture_t **buf;
    size_t max;
    size_t len;
} packcr_capture_const_table_t;

typedef struct packcr_thunk_tag packcr_thunk_t;
typedef struct packcr_thunk_array_tag packcr_thunk_array_t;

typedef void (*packcr_action_t)(packcr_context_t *, packcr_thunk_t *, packcr_value_t *);

typedef enum packcr_thunk_type_tag {
    PACKCR_THUNK_LEAF,
    PACKCR_THUNK_NODE
} packcr_thunk_type_t;

typedef struct packcr_thunk_leaf_tag {
    packcr_value_refer_table_t values;
    packcr_capture_const_table_t capts;
    packcr_capture_t capt0;
    packcr_action_t action;
} packcr_thunk_leaf_t;

typedef struct packcr_thunk_node_tag {
    const packcr_thunk_array_t *thunks; /* just a reference */
    packcr_value_t *value; /* just a reference */
} packcr_thunk_node_t;

typedef union packcr_thunk_data_tag {
    packcr_thunk_leaf_t leaf;
    packcr_thunk_node_t node;
} packcr_thunk_data_t;

struct packcr_thunk_tag {
    packcr_thunk_type_t type;
    packcr_thunk_data_t data;
};

struct packcr_thunk_array_tag {
    packcr_thunk_t **buf;
    size_t max;
    size_t len;
};

typedef struct packcr_thunk_chunk_tag {
    packcr_value_table_t values;
    packcr_capture_table_t capts;
    packcr_thunk_array_t thunks;
    size_t pos; /* the starting position in the character buffer */
<%- if @location -%>
    packcr_location_t pos_loc;
<%- end -%>
} packcr_thunk_chunk_t;

typedef struct packcr_lr_memo_tag packcr_lr_memo_t;

struct packcr_lr_memo_tag {
    size_t offset;
<%- if @location -%>
    packcr_location_t offset_loc;
<%- end -%>
    packcr_lr_memo_t *hold;
    packcr_thunk_chunk_t *chunk;
    packcr_bool_t fail;
    packcr_bool_t grow;
};

typedef struct packcr_rule_set_tag packcr_rule_set_t;

typedef packcr_thunk_chunk_t *(*packcr_rule_t)(packcr_context_t *, size_t<% if @location %>, packcr_location_t<% end %>, packcr_rule_set_t*);

typedef struct packcr_rule_set_tag {
    packcr_rule_t *buf;
    size_t max;
    size_t len;
} packcr_rule_set_t;

typedef struct packcr_lr_memo_map_entry_tag {
    packcr_rule_t rule;
    packcr_lr_memo_t *memo;
} packcr_lr_memo_map_entry_t;

typedef struct packcr_lr_memo_map_tag {
    packcr_lr_memo_map_entry_t *buf;
    size_t max;
    size_t len;
} packcr_lr_memo_map_t;

typedef struct packcr_lr_table_tag {
    packcr_lr_memo_map_t **buf;
    size_t max;
    size_t len;
    size_t ofs;
} packcr_lr_table_t;

typedef struct packcr_memory_entry_tag packcr_memory_entry_t;
typedef struct packcr_memory_pool_tag packcr_memory_pool_t;

struct packcr_memory_entry_tag {
    packcr_memory_entry_t *next;
};

struct packcr_memory_pool_tag {
    packcr_memory_pool_t *next;
    size_t allocated;
    size_t unused;
};

typedef struct packcr_memory_recycler_tag {
    packcr_memory_pool_t *pool_list;
    packcr_memory_entry_t *entry_list;
    size_t element_size;
} packcr_memory_recycler_t;

struct <%= prefix %>_context_tag {
    size_t buffer_start_position; /* the position in the input of the first character currently buffered */
    size_t position_offset; /* the current parsing position in the character buffer */
    <%- if @location -%>
    packcr_location_t buffer_start_position_loc;
    packcr_location_t position_offset_loc;
    <%- end -%>
    size_t level;
    packcr_char_array_t buffer;
    packcr_lr_table_t lrtable;
    packcr_thunk_array_t thunks;
    packcr_auxil_t auxil;
    packcr_memory_recycler_t thunk_chunk_recycler;
    packcr_memory_recycler_t lr_memo_recycler;
};

#ifndef PACKCR_ERROR
#define PACKCR_ERROR(auxil) packcr_error()
MARK_FUNC_AS_USED
static void packcr_error(void) {
    fprintf(stderr, "Syntax error\n");
    exit(1);
}
#endif /* !PACKCR_ERROR */

#ifndef PACKCR_GETCHAR
#define PACKCR_GETCHAR(auxil) getchar()
#endif /* !PACKCR_GETCHAR */

#ifndef PACKCR_MALLOC
#define PACKCR_MALLOC(auxil, size) packcr_malloc_e(size)
static void *packcr_malloc_e(size_t size) {
    void *const p = malloc(size);
    if (p == NULL) {
        fprintf(stderr, "Out of memory\n");
        exit(1);
    }
    return p;
}
#endif /* !PACKCR_MALLOC */

#ifndef PACKCR_REALLOC
#define PACKCR_REALLOC(auxil, ptr, size) packcr_realloc_e(ptr, size)
static void *packcr_realloc_e(void *ptr, size_t size) {
    void *const p = realloc(ptr, size);
    if (p == NULL) {
        fprintf(stderr, "Out of memory\n");
        exit(1);
    }
    return p;
}
#endif /* !PACKCR_REALLOC */

#ifndef PACKCR_FREE
#define PACKCR_FREE(auxil, ptr) free(ptr)
#endif /* !PACKCR_FREE */

#ifndef PACKCR_DEBUG
#define PACKCR_DEBUG(auxil, event, rule, level, pos, buffer, length) ((void)0)
#endif /* !PACKCR_DEBUG */

static char *packcr_strndup_e(packcr_auxil_t auxil, const char *str, size_t len) {
    const size_t m = strnlen(str, len);
    char *const s = (char *)PACKCR_MALLOC(auxil, m + 1);
    memcpy(s, str, m);
    s[m] = '\0';
    return s;
}

static void packcr_char_array__init(packcr_auxil_t auxil, packcr_char_array_t *array) {
    array->len = 0;
    array->max = 0;
    array->buf = NULL;
}

static void packcr_char_array__add(packcr_auxil_t auxil, packcr_char_array_t *array, char ch) {
    if (array->max <= array->len) {
        const size_t n = array->len + 1;
        size_t m = array->max;
        if (m == 0) m = PACKCR_BUFFER_MIN_SIZE;
        while (m < n && m != 0) m <<= 1;
        if (m == 0) m = n;
        array->buf = (char *)PACKCR_REALLOC(auxil, array->buf, m);
        array->max = m;
    }
    array->buf[array->len++] = ch;
}

static void packcr_char_array__term(packcr_auxil_t auxil, packcr_char_array_t *array) {
    PACKCR_FREE(auxil, array->buf);
}

static void packcr_value_table__init(packcr_auxil_t auxil, packcr_value_table_t *table) {
    table->len = 0;
    table->max = 0;
    table->buf = NULL;
}

MARK_FUNC_AS_USED
static void packcr_value_table__resize(packcr_auxil_t auxil, packcr_value_table_t *table, size_t len) {
    if (table->max < len) {
        size_t m = table->max;
        if (m == 0) m = PACKCR_ARRAY_MIN_SIZE;
        while (m < len && m != 0) m <<= 1;
        if (m == 0) m = len;
        table->buf = (packcr_value_t *)PACKCR_REALLOC(auxil, table->buf, sizeof(packcr_value_t) * m);
        table->max = m;
    }
    table->len = len;
}

MARK_FUNC_AS_USED
static void packcr_value_table__clear(packcr_auxil_t auxil, packcr_value_table_t *table) {
    memset(table->buf, 0, sizeof(packcr_value_t) * table->len);
}

static void packcr_value_table__term(packcr_auxil_t auxil, packcr_value_table_t *table) {
    PACKCR_FREE(auxil, table->buf);
}

static void packcr_value_refer_table__init(packcr_auxil_t auxil, packcr_value_refer_table_t *table) {
    table->len = 0;
    table->max = 0;
    table->buf = NULL;
}

static void packcr_value_refer_table__resize(packcr_auxil_t auxil, packcr_value_refer_table_t *table, size_t len) {
    size_t i;
    if (table->max < len) {
        size_t m = table->max;
        if (m == 0) m = PACKCR_ARRAY_MIN_SIZE;
        while (m < len && m != 0) m <<= 1;
        if (m == 0) m = len;
        table->buf = (packcr_value_t **)PACKCR_REALLOC(auxil, table->buf, sizeof(packcr_value_t *) * m);
        table->max = m;
    }
    for (i = table->len; i < len; i++) table->buf[i] = NULL;
    table->len = len;
}

static void packcr_value_refer_table__term(packcr_auxil_t auxil, packcr_value_refer_table_t *table) {
    PACKCR_FREE(auxil, table->buf);
}

static void packcr_capture_table__init(packcr_auxil_t auxil, packcr_capture_table_t *table) {
    table->len = 0;
    table->max = 0;
    table->buf = NULL;
}

MARK_FUNC_AS_USED
static void packcr_capture_table__resize(packcr_auxil_t auxil, packcr_capture_table_t *table, size_t len) {
    size_t i;
    for (i = len; i < table->len; i++) PACKCR_FREE(auxil, table->buf[i].string);
    if (table->max < len) {
        size_t m = table->max;
        if (m == 0) m = PACKCR_ARRAY_MIN_SIZE;
        while (m < len && m != 0) m <<= 1;
        if (m == 0) m = len;
        table->buf = (packcr_capture_t *)PACKCR_REALLOC(auxil, table->buf, sizeof(packcr_capture_t) * m);
        table->max = m;
    }
    for (i = table->len; i < len; i++) {
        table->buf[i].range.start = 0;
        table->buf[i].range.end = 0;
<%- if @location -%>
        packcr_location_init(&table->buf[i].range.start_loc);
        packcr_location_init(&table->buf[i].range.end_loc);
<%- end -%>
        table->buf[i].string = NULL;
    }
    table->len = len;
}

static void packcr_capture_table__term(packcr_auxil_t auxil, packcr_capture_table_t *table) {
    while (table->len > 0) {
        table->len--;
        PACKCR_FREE(auxil, table->buf[table->len].string);
    }
    PACKCR_FREE(auxil, table->buf);
}

static void packcr_capture_const_table__init(packcr_auxil_t auxil, packcr_capture_const_table_t *table) {
    table->len = 0;
    table->max = 0;
    table->buf = NULL;
}

static void packcr_capture_const_table__resize(packcr_auxil_t auxil, packcr_capture_const_table_t *table, size_t len) {
    size_t i;
    if (table->max < len) {
        size_t m = table->max;
        if (m == 0) m = PACKCR_ARRAY_MIN_SIZE;
        while (m < len && m != 0) m <<= 1;
        if (m == 0) m = len;
        table->buf = (const packcr_capture_t **)PACKCR_REALLOC(auxil, (packcr_capture_t **)table->buf, sizeof(const packcr_capture_t *) * m);
        table->max = m;
    }
    for (i = table->len; i < len; i++) table->buf[i] = NULL;
    table->len = len;
}

static void packcr_capture_const_table__term(packcr_auxil_t auxil, packcr_capture_const_table_t *table) {
    PACKCR_FREE(auxil, (void *)table->buf);
}

MARK_FUNC_AS_USED
static packcr_thunk_t *packcr_thunk__create_leaf(packcr_auxil_t auxil, packcr_action_t action, size_t valuec, size_t captc) {
    packcr_thunk_t *const thunk = (packcr_thunk_t *)PACKCR_MALLOC(auxil, sizeof(packcr_thunk_t));
    thunk->type = PACKCR_THUNK_LEAF;
    packcr_value_refer_table__init(auxil, &thunk->data.leaf.values);
    packcr_value_refer_table__resize(auxil, &thunk->data.leaf.values, valuec);
    packcr_capture_const_table__init(auxil, &thunk->data.leaf.capts);
    packcr_capture_const_table__resize(auxil, &thunk->data.leaf.capts, captc);
    thunk->data.leaf.capt0.range.start = 0;
    thunk->data.leaf.capt0.range.end = 0;
<%- if @location -%>
    packcr_location_init(&thunk->data.leaf.capt0.range.start_loc);
    packcr_location_init(&thunk->data.leaf.capt0.range.end_loc);
<%- end -%>
    thunk->data.leaf.capt0.string = NULL;
    thunk->data.leaf.action = action;
    return thunk;
}

static packcr_thunk_t *packcr_thunk__create_node(packcr_auxil_t auxil, const packcr_thunk_array_t *thunks, packcr_value_t *value) {
    packcr_thunk_t *const thunk = (packcr_thunk_t *)PACKCR_MALLOC(auxil, sizeof(packcr_thunk_t));
    thunk->type = PACKCR_THUNK_NODE;
    thunk->data.node.thunks = thunks;
    thunk->data.node.value = value;
    return thunk;
}

static void packcr_thunk__destroy(packcr_auxil_t auxil, packcr_thunk_t *thunk) {
    if (thunk == NULL) return;
    switch (thunk->type) {
    case PACKCR_THUNK_LEAF:
        PACKCR_FREE(auxil, thunk->data.leaf.capt0.string);
        packcr_capture_const_table__term(auxil, &thunk->data.leaf.capts);
        packcr_value_refer_table__term(auxil, &thunk->data.leaf.values);
        break;
    case PACKCR_THUNK_NODE:
        break;
    default: /* unknown */
        break;
    }
    PACKCR_FREE(auxil, thunk);
}

static void packcr_thunk_array__init(packcr_auxil_t auxil, packcr_thunk_array_t *array) {
    array->len = 0;
    array->max = 0;
    array->buf = NULL;
}

static void packcr_thunk_array__add(packcr_auxil_t auxil, packcr_thunk_array_t *array, packcr_thunk_t *thunk) {
    if (array->max <= array->len) {
        const size_t n = array->len + 1;
        size_t m = array->max;
        if (m == 0) m = PACKCR_ARRAY_MIN_SIZE;
        while (m < n && m != 0) m <<= 1;
        if (m == 0) m = n;
        array->buf = (packcr_thunk_t **)PACKCR_REALLOC(auxil, array->buf, sizeof(packcr_thunk_t *) * m);
        array->max = m;
    }
    array->buf[array->len++] = thunk;
}

static void packcr_thunk_array__revert(packcr_auxil_t auxil, packcr_thunk_array_t *array, size_t len) {
    while (array->len > len) {
        array->len--;
        packcr_thunk__destroy(auxil, array->buf[array->len]);
    }
}

static void packcr_thunk_array__term(packcr_auxil_t auxil, packcr_thunk_array_t *array) {
    while (array->len > 0) {
        array->len--;
        packcr_thunk__destroy(auxil, array->buf[array->len]);
    }
    PACKCR_FREE(auxil, array->buf);
}

static void packcr_memory_recycler__init(packcr_auxil_t auxil, packcr_memory_recycler_t *recycler, size_t element_size) {
    recycler->pool_list = NULL;
    recycler->entry_list = NULL;
    recycler->element_size = element_size;
}

static void *packcr_memory_recycler__supply(packcr_auxil_t auxil, packcr_memory_recycler_t *recycler) {
    if (recycler->entry_list) {
        packcr_memory_entry_t *const tmp = recycler->entry_list;
        recycler->entry_list = tmp->next;
        return tmp;
    }
    if (!recycler->pool_list || recycler->pool_list->unused == 0) {
        size_t size = PACKCR_POOL_MIN_SIZE;
        if (recycler->pool_list) {
            size = recycler->pool_list->allocated << 1;
            if (size == 0) size = recycler->pool_list->allocated;
        }
        {
            packcr_memory_pool_t *const pool = (packcr_memory_pool_t *)PACKCR_MALLOC(
                auxil, sizeof(packcr_memory_pool_t) + recycler->element_size * size
            );
            pool->allocated = size;
            pool->unused = size;
            pool->next = recycler->pool_list;
            recycler->pool_list = pool;
        }
    }
    recycler->pool_list->unused--;
    return (char *)recycler->pool_list + sizeof(packcr_memory_pool_t) + recycler->element_size * recycler->pool_list->unused;
}

static void packcr_memory_recycler__recycle(packcr_auxil_t auxil, packcr_memory_recycler_t *recycler, void *ptr) {
    packcr_memory_entry_t *const tmp = (packcr_memory_entry_t *)ptr;
    tmp->next = recycler->entry_list;
    recycler->entry_list = tmp;
}

static void packcr_memory_recycler__term(packcr_auxil_t auxil, packcr_memory_recycler_t *recycler) {
    while (recycler->pool_list) {
        packcr_memory_pool_t *const tmp = recycler->pool_list;
        recycler->pool_list = tmp->next;
        PACKCR_FREE(auxil, tmp);
    }
}

MARK_FUNC_AS_USED
static packcr_thunk_chunk_t *packcr_thunk_chunk__create(packcr_context_t *ctx) {
    packcr_thunk_chunk_t *const chunk = (packcr_thunk_chunk_t *)packcr_memory_recycler__supply(ctx->auxil, &ctx->thunk_chunk_recycler);
    packcr_value_table__init(ctx->auxil, &chunk->values);
    packcr_capture_table__init(ctx->auxil, &chunk->capts);
    packcr_thunk_array__init(ctx->auxil, &chunk->thunks);
    chunk->pos = 0;
    return chunk;
}

static void packcr_thunk_chunk__destroy(packcr_context_t *ctx, packcr_thunk_chunk_t *chunk) {
    if (chunk == NULL) return;
    packcr_thunk_array__term(ctx->auxil, &chunk->thunks);
    packcr_capture_table__term(ctx->auxil, &chunk->capts);
    packcr_value_table__term(ctx->auxil, &chunk->values);
    packcr_memory_recycler__recycle(ctx->auxil, &ctx->thunk_chunk_recycler, chunk);
}

static void packcr_rule_set__init(packcr_auxil_t auxil, packcr_rule_set_t *set) {
    set->len = 0;
    set->max = 0;
    set->buf = NULL;
}

static size_t packcr_rule_set__index(packcr_auxil_t auxil, const packcr_rule_set_t *set, packcr_rule_t rule) {
    size_t i;
    for (i = 0; i < set->len; i++) {
        if (set->buf[i] == rule) return i;
    }
    return PACKCR_VOID_VALUE;
}

static packcr_bool_t packcr_rule_set__add(packcr_auxil_t auxil, packcr_rule_set_t *set, packcr_rule_t rule) {
    const size_t i = packcr_rule_set__index(auxil, set, rule);
    if (i != PACKCR_VOID_VALUE) return PACKCR_FALSE;
    if (set->max <= set->len) {
        const size_t n = set->len + 1;
        size_t m = set->max;
        if (m == 0) m = PACKCR_ARRAY_MIN_SIZE;
        while (m < n && m != 0) m <<= 1;
        if (m == 0) m = n;
        set->buf = (packcr_rule_t *)PACKCR_REALLOC(auxil, set->buf, sizeof(packcr_rule_t) * m);
        set->max = m;
    }
    set->buf[set->len++] = rule;
    return PACKCR_TRUE;
}

static void packcr_rule_set__term(packcr_auxil_t auxil, packcr_rule_set_t *set) {
    PACKCR_FREE(auxil, set->buf);
}

static packcr_lr_memo_t *packcr_lr_memo__create(packcr_context_t *ctx, size_t offset<% if @location %>, packcr_location_t offset_loc<% end %>) {
    packcr_lr_memo_t *memo = (packcr_lr_memo_t *)packcr_memory_recycler__supply(ctx->auxil, &ctx->lr_memo_recycler);
    memo->offset = offset;
<%- if @location -%>
    memo->offset_loc = offset_loc;
<%- end -%>
    memo->chunk = NULL;
    memo->fail = PACKCR_TRUE;
    memo->grow = PACKCR_FALSE;
    memo->hold = NULL;
    return memo;
}

static void packcr_lr_memo__set_chunk(packcr_context_t *ctx, packcr_lr_memo_t *memo, packcr_thunk_chunk_t *chunk) {
    if (memo->chunk) {
        packcr_lr_memo_t *const new_hold_memo = packcr_lr_memo__create(ctx, memo->offset<% if @location %>, memo->offset_loc<% end %>);
        new_hold_memo->chunk = memo->chunk;
        new_hold_memo->hold = memo->hold;
        memo->hold = new_hold_memo;
    }
    memo->chunk = chunk;
    memo->fail = PACKCR_FALSE;
}

static void packcr_lr_memo__destroy(packcr_context_t *ctx, packcr_lr_memo_t *memo) {
    while (memo != NULL) {
        packcr_lr_memo_t *const hold_memo = memo->hold;
        packcr_thunk_chunk__destroy(ctx, memo->chunk);
        packcr_memory_recycler__recycle(ctx->auxil, &ctx->lr_memo_recycler, memo);
        memo = hold_memo;
    }
}

static void packcr_lr_memo_map__init(packcr_auxil_t auxil, packcr_lr_memo_map_t *map) {
    map->len = 0;
    map->max = 0;
    map->buf = NULL;
}

static size_t packcr_lr_memo_map__index(packcr_context_t *ctx, packcr_lr_memo_map_t *map, packcr_rule_t rule) {
    size_t i;
    for (i = 0; i < map->len; i++) {
        if (map->buf[i].rule == rule) return i;
    }
    return PACKCR_VOID_VALUE;
}

static void packcr_lr_memo_map__put(packcr_context_t *ctx, packcr_lr_memo_map_t *map, packcr_rule_t rule, packcr_lr_memo_t *memo) {
    const size_t i = packcr_lr_memo_map__index(ctx, map, rule);
    if (i != PACKCR_VOID_VALUE) {
        packcr_lr_memo__destroy(ctx, map->buf[i].memo);
        map->buf[i].memo = memo;
    }
    else {
        if (map->max <= map->len) {
            const size_t n = map->len + 1;
            size_t m = map->max;
            if (m == 0) m = PACKCR_ARRAY_MIN_SIZE;
            while (m < n && m != 0) m <<= 1;
            if (m == 0) m = n;
            map->buf = (packcr_lr_memo_map_entry_t *)PACKCR_REALLOC(ctx->auxil, map->buf, sizeof(packcr_lr_memo_map_entry_t) * m);
            map->max = m;
        }
        map->buf[map->len].rule = rule;
        map->buf[map->len].memo = memo;
        map->len++;
    }
}

static packcr_lr_memo_t *packcr_lr_memo_map__get(packcr_context_t *ctx, packcr_lr_memo_map_t *map, packcr_rule_t rule) {
    const size_t i = packcr_lr_memo_map__index(ctx, map, rule);
    return (i != PACKCR_VOID_VALUE) ? map->buf[i].memo : NULL;
}

static void packcr_lr_memo_map__term(packcr_context_t *ctx, packcr_lr_memo_map_t *map) {
    while (map->len > 0) {
        map->len--;
        packcr_lr_memo__destroy(ctx, map->buf[map->len].memo);
    }
    PACKCR_FREE(ctx->auxil, map->buf);
}

static packcr_lr_memo_map_t *packcr_lr_memo_map__create(packcr_context_t *ctx) {
    packcr_lr_memo_map_t *const memo = (packcr_lr_memo_map_t *)PACKCR_MALLOC(ctx->auxil, sizeof(packcr_lr_memo_map_t));
    packcr_lr_memo_map__init(ctx->auxil, memo);
    return memo;
}

static void packcr_lr_memo_map__destroy(packcr_context_t *ctx, packcr_lr_memo_map_t *memo) {
    if (memo == NULL) return;
    packcr_lr_memo_map__term(ctx, memo);
    PACKCR_FREE(ctx->auxil, memo);
}

static void packcr_lr_table__init(packcr_auxil_t auxil, packcr_lr_table_t *table) {
    table->ofs = 0;
    table->len = 0;
    table->max = 0;
    table->buf = NULL;
}

static void packcr_lr_table__resize(packcr_context_t *ctx, packcr_lr_table_t *table, size_t len) {
    size_t i;
    for (i = len; i < table->len; i++) packcr_lr_memo_map__destroy(ctx, table->buf[i]);
    if (table->max < len) {
        size_t m = table->max;
        if (m == 0) m = PACKCR_ARRAY_MIN_SIZE;
        while (m < len && m != 0) m <<= 1;
        if (m == 0) m = len;
        table->buf = (packcr_lr_memo_map_t **)PACKCR_REALLOC(ctx->auxil, table->buf, sizeof(packcr_lr_memo_map_t *) * m);
        table->max = m;
    }
    for (i = table->len; i < len; i++) table->buf[i] = NULL;
    table->len = len;
}

static void packcr_lr_table__set_memo(packcr_context_t *ctx, packcr_lr_table_t *table, size_t index, packcr_rule_t rule, packcr_lr_memo_t *memo) {
    index += table->ofs;
    if (index >= table->len) packcr_lr_table__resize(ctx, table, index + 1);
    if (table->buf[index] == NULL) table->buf[index] = packcr_lr_memo_map__create(ctx);
    packcr_lr_memo_map__put(ctx, table->buf[index], rule, memo);
}

static packcr_lr_memo_t *packcr_lr_table__get_memo(packcr_context_t *ctx, packcr_lr_table_t *table, size_t index, packcr_rule_t rule) {
    index += table->ofs;
    if (index >= table->len || table->buf[index] == NULL) return NULL;
    return packcr_lr_memo_map__get(ctx, table->buf[index], rule);
}

static void packcr_lr_table__shift(packcr_context_t *ctx, packcr_lr_table_t *table, size_t count) {
    size_t i;
    if (count > table->len - table->ofs) count = table->len - table->ofs;
    for (i = 0; i < count; i++) packcr_lr_memo_map__destroy(ctx, table->buf[table->ofs++]);
    if (table->ofs > (table->max >> 1)) {
        memmove(table->buf, table->buf + table->ofs, sizeof(packcr_lr_memo_map_t *) * (table->len - table->ofs));
        table->len -= table->ofs;
        table->ofs = 0;
    }
}

static void packcr_lr_table__term(packcr_context_t *ctx, packcr_lr_table_t *table) {
    while (table->len > table->ofs) {
        table->len--;
        packcr_lr_memo_map__destroy(ctx, table->buf[table->len]);
    }
    PACKCR_FREE(ctx->auxil, table->buf);
}

static packcr_context_t *packcr_context__create(packcr_auxil_t auxil) {
    packcr_context_t *const ctx = (packcr_context_t *)PACKCR_MALLOC(auxil, sizeof(packcr_context_t));
    ctx->buffer_start_position = 0;
    ctx->position_offset = 0;
<%- if @location -%>
    packcr_location_init(&ctx->buffer_start_position_loc);
    packcr_location_init(&ctx->position_offset_loc);
<%- end -%>
    ctx->level = 0;
    packcr_char_array__init(auxil, &ctx->buffer);
    packcr_lr_table__init(auxil, &ctx->lrtable);
    packcr_thunk_array__init(auxil, &ctx->thunks);
    packcr_memory_recycler__init(auxil, &ctx->thunk_chunk_recycler, sizeof(packcr_thunk_chunk_t));
    packcr_memory_recycler__init(auxil, &ctx->lr_memo_recycler, sizeof(packcr_lr_memo_t));
    ctx->auxil = auxil;
    return ctx;
}

static void packcr_context__destroy(packcr_context_t *ctx) {
    if (ctx == NULL) return;
    packcr_thunk_array__term(ctx->auxil, &ctx->thunks);
    packcr_lr_table__term(ctx, &ctx->lrtable);
    packcr_char_array__term(ctx->auxil, &ctx->buffer);
    packcr_memory_recycler__term(ctx->auxil, &ctx->thunk_chunk_recycler);
    packcr_memory_recycler__term(ctx->auxil, &ctx->lr_memo_recycler);
    PACKCR_FREE(ctx->auxil, ctx);
}

static size_t packcr_refill_buffer(packcr_context_t *ctx, size_t num) {
    if (ctx->buffer.len >= ctx->position_offset + num) return ctx->buffer.len - ctx->position_offset;
    while (ctx->buffer.len < ctx->position_offset + num) {
        const int c = PACKCR_GETCHAR(ctx->auxil);
        if (c < 0) break;
        packcr_char_array__add(ctx->auxil, &ctx->buffer, (char)c);
    }
    return ctx->buffer.len - ctx->position_offset;
}

MARK_FUNC_AS_USED
static void packcr_commit_buffer(packcr_context_t *ctx) {
    memmove(ctx->buffer.buf, ctx->buffer.buf + ctx->position_offset, ctx->buffer.len - ctx->position_offset);
    ctx->buffer.len -= ctx->position_offset;
    ctx->buffer_start_position += ctx->position_offset;
    packcr_lr_table__shift(ctx, &ctx->lrtable, ctx->position_offset);
    ctx->position_offset = 0;
<%- if @location -%>
    ctx->buffer_start_position_loc = packcr_location_add(ctx->buffer_start_position_loc, ctx->position_offset_loc);
    packcr_location_init(&ctx->position_offset_loc);
<%- end -%>
}

MARK_FUNC_AS_USED
static const char *packcr_get_capture_string(packcr_context_t *ctx, const packcr_capture_t *capt) {
    if (capt->string == NULL)
        ((packcr_capture_t *)capt)->string =
            packcr_strndup_e(ctx->auxil, ctx->buffer.buf + capt->range.start, capt->range.end - capt->range.start);
    return capt->string;
}

<% if @utf8 -%>
static size_t packcr_get_char_as_utf32(packcr_context_t *ctx, int *out) { /* with checking UTF-8 validity */
    int c, u;
    size_t n;
    if (packcr_refill_buffer(ctx, 1) < 1) return 0;
    c = (int)(unsigned char)ctx->buffer.buf[ctx->position_offset];
    n = (c < 0x80) ? 1 :
        ((c & 0xe0) == 0xc0) ? 2 :
        ((c & 0xf0) == 0xe0) ? 3 :
        ((c & 0xf8) == 0xf0) ? 4 : 0;
    if (n < 1) return 0;
    if (packcr_refill_buffer(ctx, n) < n) return 0;
    switch (n) {
    case 1:
        u = c;
        break;
    case 2:
        u = c & 0x1f;
        c = (int)(unsigned char)ctx->buffer.buf[ctx->position_offset + 1];
        if ((c & 0xc0) != 0x80) return 0;
        u <<= 6; u |= c & 0x3f;
        if (u < 0x80) return 0;
        break;
    case 3:
        u = c & 0x0f;
        c = (int)(unsigned char)ctx->buffer.buf[ctx->position_offset + 1];
        if ((c & 0xc0) != 0x80) return 0;
        u <<= 6; u |= c & 0x3f;
        c = (int)(unsigned char)ctx->buffer.buf[ctx->position_offset + 2];
        if ((c & 0xc0) != 0x80) return 0;
        u <<= 6; u |= c & 0x3f;
        if (u < 0x800) return 0;
        break;
    case 4:
        u = c & 0x07;
        c = (int)(unsigned char)ctx->buffer.buf[ctx->position_offset + 1];
        if ((c & 0xc0) != 0x80) return 0;
        u <<= 6; u |= c & 0x3f;
        c = (int)(unsigned char)ctx->buffer.buf[ctx->position_offset + 2];
        if ((c & 0xc0) != 0x80) return 0;
        u <<= 6; u |= c & 0x3f;
        c = (int)(unsigned char)ctx->buffer.buf[ctx->position_offset + 3];
        if ((c & 0xc0) != 0x80) return 0;
        u <<= 6; u |= c & 0x3f;
        if (u < 0x10000 || u > 0x10ffff) return 0;
        break;
    default:
        return 0;
    }
    if (out) *out = u;
    return n;
}

<% end -%>
static void packcr_grow_lr(packcr_context_t *ctx, packcr_rule_t rule, size_t offset<% if @location %>, packcr_location_t offset_loc<% end %>) {
    while(1) {
        const size_t old_offset = ctx->position_offset;
        packcr_thunk_chunk_t *chunk;
        packcr_lr_memo_t *memo;
        packcr_rule_set_t limits;
        ctx->position_offset = offset;
<%- if @location -%>
        ctx->position_offset_loc = offset_loc;
<%- end -%>
        packcr_rule_set__init(ctx->auxil, &limits);
        packcr_rule_set__add(ctx->auxil, &limits, rule);
        chunk = rule(ctx, offset<% if @location %>, offset_loc<% end %>, &limits);
        packcr_rule_set__term(ctx->auxil, &limits);
        if (!chunk)
            break;
        if (ctx->position_offset <= old_offset) {
            packcr_thunk_chunk__destroy(ctx, chunk);
            break;
        }
        memo = packcr_lr_table__get_memo(ctx, &ctx->lrtable, offset, rule);
        packcr_lr_memo__set_chunk(ctx, memo, chunk);
        memo->offset = ctx->position_offset;
        <%- if @location -%>
        memo->offset_loc = ctx->position_offset_loc;
        <%- end -%>
    }
}

MARK_FUNC_AS_USED
static packcr_thunk_chunk_t *packcr_get_rule_thunk_chunk(packcr_context_t *ctx, packcr_rule_t rule) {
    packcr_thunk_chunk_t *c = NULL;
    size_t offset = ctx->position_offset;
<%- if @location -%>
    packcr_location_t offset_loc = ctx->position_offset_loc;
<%- end -%>
    packcr_lr_memo_t *memo = packcr_lr_table__get_memo(ctx, &ctx->lrtable, offset, rule);

    if (memo == NULL) {
        memo = packcr_lr_memo__create(ctx, offset<% if @location %>, offset_loc<% end %>);
        packcr_lr_table__set_memo(ctx, &ctx->lrtable, offset, rule, memo);
        c = rule(ctx, offset<% if @location %>, offset_loc<% end %>, NULL);
        packcr_lr_memo__set_chunk(ctx, memo, c);
        memo->offset = ctx->position_offset;
<%- if @location -%>
        memo->offset_loc = ctx->position_offset_loc;
<%- end -%>
        if (memo->grow) {
            packcr_grow_lr(ctx, rule, offset<% if @location %>, offset_loc<% end %>);
            memo->grow = PACKCR_FALSE;
            ctx->position_offset = memo->offset;
<%- if @location -%>
            ctx->position_offset_loc = memo->offset_loc;
<%- end -%>
            return memo->chunk;
        }
        return c;
    } else if (memo->fail) {
        packcr_lr_memo__set_chunk(ctx, memo, NULL);
        memo->grow = PACKCR_TRUE;
        return NULL;
    }
    ctx->position_offset = memo->offset;
<%- if @location -%>
    ctx->position_offset_loc = memo->offset_loc;
<%- end -%>
    return memo->chunk;
}

MARK_FUNC_AS_USED
static packcr_bool_t packcr_apply_rule(packcr_context_t *ctx, packcr_rule_t rule, packcr_thunk_array_t *thunks, packcr_value_t *value, size_t offset<% if @location %>, packcr_location_t offset_loc<% end %>, packcr_rule_set_t *limits) {
    static packcr_value_t null;
    packcr_thunk_chunk_t *c;
    if (limits != NULL) {
        packcr_lr_memo_t *memo;
        packcr_rule_set__add(ctx->auxil, limits, rule);
        c = rule(ctx, offset<% if @location %>, offset_loc<% end %>, limits);
        memo = packcr_lr_table__get_memo(ctx, &ctx->lrtable, offset, rule);
        if (memo == NULL || ctx->position_offset <= memo->offset) {
            if (memo) {
                c = memo->chunk;
                ctx->position_offset = memo->offset;
                <%- if @location -%>
                ctx->position_offset_loc = memo->offset_loc;
                <%- end -%>
            }
        } else {
            packcr_lr_memo__set_chunk(ctx, memo, c);
            memo->offset = ctx->position_offset;
            <%- if @location -%>
            memo->offset_loc = ctx->position_offset_loc;
            <%- end -%>
        }
    } else {
        c = packcr_get_rule_thunk_chunk(ctx, rule);
    }
    if (c == NULL) return PACKCR_FALSE;
    if (value == NULL) value = &null;
    memset(value, 0, sizeof(packcr_value_t)); /* in case */
    packcr_thunk_array__add(ctx->auxil, thunks, packcr_thunk__create_node(ctx->auxil, &c->thunks, value));
    return PACKCR_TRUE;
}

MARK_FUNC_AS_USED
static void packcr_do_action(packcr_context_t *ctx, const packcr_thunk_array_t *thunks, packcr_value_t *value) {
    size_t i;
    for (i = 0; i < thunks->len; i++) {
        packcr_thunk_t *const thunk = thunks->buf[i];
        switch (thunk->type) {
        case PACKCR_THUNK_LEAF:
            thunk->data.leaf.action(ctx, thunk, value);
            break;
        case PACKCR_THUNK_NODE:
            packcr_do_action(ctx, thunk->data.node.thunks, thunk->data.node.value);
            break;
        default: /* unknown */
            break;
        }
    }
}

<%= prefix %>_context_t *<%= prefix %>_create(<%= auxil_def %>auxil) {
    return packcr_context__create(auxil);
}

void <%= prefix %>_destroy(<%= prefix %>_context_t *ctx) {
    packcr_context__destroy(ctx);
}
<%- if !@root.rules.empty? -%>

<%-   @root.rules.each do |rule| -%>
static packcr_thunk_chunk_t *packcr_evaluate_rule_<%= rule.name %>(packcr_context_t *ctx, size_t offset<% if @location %>, packcr_location_t offset_loc<% end %>, packcr_rule_set_t *limits);
<%-   end -%>
<%- end -%>

int <%= prefix %>_parse(<%= prefix %>_context_t *ctx, <%= value_def %>*ret) {
    size_t pos = ctx->buffer_start_position;
<%- if !@root.rules.empty? -%>
    if (packcr_apply_rule(ctx, packcr_evaluate_rule_<%= @root.rules[0].name %>, &ctx->thunks, ret, ctx->position_offset<% if @location %>, ctx->position_offset_loc<% end %>, NULL))
        packcr_do_action(ctx, &ctx->thunks, ret);
    else
        PACKCR_ERROR(ctx->auxil);
    packcr_commit_buffer(ctx);
<%- end -%>
    packcr_thunk_array__revert(ctx->auxil, &ctx->thunks, 0);
    return pos != ctx->buffer_start_position && packcr_refill_buffer(ctx, 1) >= 1;
}

<%- @root.rules.each do |rule| -%>
<%-   rule.actions.each do |action| -%>
static void packcr_action_<%= rule.name %>_<%= action.index %>(<%= prefix %>_context_t *__packcr_ctx, packcr_thunk_t *__packcr_in, packcr_value_t *__packcr_out) {
#define auxil (__packcr_ctx->auxil)
#define __ (*__packcr_out)
<%-     action.vars.each do |ref| -%>
#define <%= ref.var %> (*__packcr_in->data.leaf.values.buf[<%= ref.index %>])
<%      end -%>
#define _0 packcr_get_capture_string(__packcr_ctx, &__packcr_in->data.leaf.capt0)
#define _0s ((const size_t)(__packcr_ctx->buffer_start_position + __packcr_in->data.leaf.capt0.range.start))
#define _0e ((const size_t)(__packcr_ctx->buffer_start_position + __packcr_in->data.leaf.capt0.range.end))
<%-     if @location -%>
#define _0sl ((const packcr_location_t)(packcr_location_add(__packcr_ctx->buffer_start_position_loc, __packcr_in->data.leaf.capt0.range.start_loc)))
#define _0el ((const packcr_location_t)(packcr_location_add(__packcr_ctx->buffer_start_position_loc, __packcr_in->data.leaf.capt0.range.end_loc)))
<%-     end -%>
<%-     if @capture_in_code -%>
#define _0c __packcr_in->data.leaf.capt0
<%-     end -%>
<%      action.capts.each do |capture| -%>
#define _<%= capture.index + 1 %> packcr_get_capture_string(__packcr_ctx, __packcr_in->data.leaf.capts.buf[<%= capture.index %>])
#define _<%= capture.index + 1 %>s ((const size_t)(__packcr_ctx->buffer_start_position + __packcr_in->data.leaf.capts.buf[<%= capture.index %>]->range.start))
#define _<%= capture.index + 1 %>e ((const size_t)(__packcr_ctx->buffer_start_position + __packcr_in->data.leaf.capts.buf[<%= capture.index %>]->range.end))
<%-       if @location -%>
#define _<%= capture.index + 1 %>sl ((const packcr_location_t)(packcr_location_add(__packcr_ctx->buffer_start_position_loc, __packcr_in->data.leaf.capts.buf[<%= capture.index %>]->range.start_loc)))
#define _<%= capture.index + 1 %>el ((const packcr_location_t)(packcr_location_add(__packcr_ctx->buffer_start_position_loc, __packcr_in->data.leaf.capts.buf[<%= capture.index %>]->range.end_loc)))
<%-       end -%>
<%-       if @capture_in_code -%>
#define _<%= capture.index + 1 %>c (*__packcr_in->data.leaf.capts.buf[<%= capture.index %>])
<%-       end -%>
<%-     end -%>
<%=     stream.get_code_block(action.code, 4, @iname) -%>
<%-     action.capts.reverse_each do |capture| -%>
<%-       if @location -%>
#undef _<%= capture.index + 1 %>el
#undef _<%= capture.index + 1 %>sl
<%-       end -%>
#undef _<%= capture.index + 1 %>e
#undef _<%= capture.index + 1 %>s
#undef _<%= capture.index + 1 %>
<%-     end -%>
#undef _0e
#undef _0s
#undef _0
<%- action.vars.reverse_each do |ref| -%>
#undef <%= ref.var %>
<%-     end -%>
#undef __
#undef auxil
}

<%-   end -%>
<%- end -%>

<%- @root.rules.each do |rule| -%>
<%-   gen = ::Packcr::Generator.new(rule, @ascii, @location) -%>
<%=   gen.generate_code(rule, 0, 0, false) -%>

<%- end -%>
<%- if !code_block(:lsource).empty? -%>

<%-   code_block(:lsource).each do |code| -%>
<%=     stream.get_code_block(code, 0, @iname) -%>
<%-   end -%>
<%- end -%>
