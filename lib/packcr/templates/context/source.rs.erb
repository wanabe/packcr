/* A packrat parser generated by PackCR <%= Packcr::VERSION %> */
<%- if !code(:esource).empty? -%>

<%-   code(:esource).each do |code| -%>
<%=     stream.get_code_block(code, 0, @iname) -%>
<%-   end -%>
<%- end -%>
#[derive(Clone)]
struct <%= class_name %> {
}

impl <%= class_name %> {
  pub fn new() -> Self {
    <%= class_name %> {
    }
  }

  pub fn parse(&self, input: &mut impl io::BufRead) -> Option<<%= class_name %>> {
    let mut line = String::new();
    if let Ok(bytes_read) = input.read_line(&mut line) {
      if bytes_read > 0 {
        println!("parse: {}", line.trim());
        return Some(self.clone());
      }
    }
    None
  }

  pub fn run(self, mut input: impl io::BufRead) -> <%= class_name %> {
    let mut input_ref = &mut input;
    std::iter::successors(Some(self.clone()), |calc| calc.parse(&mut input_ref))
      .last()
      .unwrap()
  }
  <%- @root.rules.each do |rule| -%>

  <%-   gen = ::Packcr::Generator.new(rule, @ascii, @location, :rs) -%>
  <%=   gen.generate_code(rule, 0, 2, false) -%>
  <%- end -%>

}
<%- if !code(:lsource).empty? -%>

<%-   code(:lsource).each do |code| -%>
<%=     stream.get_code_block(code, 0, @iname) -%>
<%-   end -%>
<%- end -%>
